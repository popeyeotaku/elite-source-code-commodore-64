; ******************************************************************************
;
; COMMODORE 64 ELITE GAME SOURCE
;
; Commodore 64 Elite was written by Ian Bell and David Braben and is copyright
; D. Braben and I. Bell 1985
;
; The code on this site is identical to the source disks released on Ian Bell's
; personal website at http://www.elitehomepage.org/ (it's just been reformatted
; to be more readable)
;
; The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
; in the documentation are entirely my fault
;
; The terminology and notations used in this commentary are explained at
; https://elite.bbcelite.com/terminology
;
; The deep dive articles referred to in this commentary can be found at
; https://elite.bbcelite.com/deep_dives
;
; ------------------------------------------------------------------------------
;
; This source file produces the following binary files:
;
;   * ELTA.bin
;   * ELTB.bin
;   * ELTC.bin
;   * ELTD.bin
;   * ELTE.bin
;   * ELTF.bin
;   * ELTG.bin
;   * ELTH.bin
;   * ELTI.bin
;   * ELTJ.bin
;   * ELTK.bin
;
; ******************************************************************************

 INCLUDE "1-source-files/main-sources/elite-build-options.asm"

 _GMA85_NTSC            = (_VARIANT = 1)
 _GMA86_PAL             = (_VARIANT = 2)
 _SOURCE_DISK_BUILD     = (_VARIANT = 3)
 _SOURCE_DISC_FILES     = (_VARIANT = 4)

; ******************************************************************************
;
; Configuration variables
;
; ******************************************************************************

 CODE% = $1D00          ; The address where the code will be run

 LOAD% = $1D00          ; The address where the code will be loaded

 Q% = _MAX_COMMANDER    ; Set Q% to TRUE to max out the default commander, FALSE
                        ; for the standard default commander

 VIC = $D000
 SID = $D400
 CIA = $DC00
 CIA2 = $DD00
 l1 = 1
 KEY1 = $36
 KEY2 = $49
 USA% = TRUE            ; Strangely, GMA86 PAL does not change this
 PALCK = 311 MOD 256

IF _GMA85_NTSC OR _GMA86_PAL

 C% = $6A00

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 C% = $7300

ENDIF

 W% = $A700
 L% = $2000
 Z = 0
 SNE = $AC0
 ACT = $AE0
 FONT = $B00
 TAP% = $CF00
 NTY = 33
 D% = $D000
;E% = D%+2*NTY
;KWL% = E%+NTY
;KWH% = E%+2*NTY

IF _GMA85_NTSC OR _GMA86_PAL

 DSTORE% = $EF90
 K% = $F900

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 DSTORE% = $6800
 K% = $F000

ENDIF

 LS% = $FFC0
 QQ18 = $700
 SCBASE = $4000
 DLOC% = SCBASE+18*8*40
 NMIV = $318
 BRKV = $316
 IRQV = $314
 KERNALSETLFS = $FFBA
 KERNALSETNAM = $FFBD
 KERNALSVE = $FFD8
 KERNALSETMSG = $FF90
 KERNALLOAD = $FFD5
 CHRV = $326
 LP = K%+$400
 MSL = 1
 SST = 2
 ESC = 3
 PLT = 4
 OIL = 5
 AST = 7
 SPL = 8
 SHU = 9
 CYL = 11
 ANA = 14
 HER = 15
 COPS = 16
 SH3 = 17
 KRA = 19
 ADA = 20
 WRM = 23
 CYL2 = 24
 ASP = 25
 THG = 29
 TGL = 30
 CON = 31
 COU = 32
 DOD = 33
 NOST = 12
 NOSH = 10
;NOST = 18
;NOSH = 20
 JL = ESC
 JH = SHU+2
 PACK = SH3
 NI% = 37
 POW = 15
 B = $30
 Armlas = INT(128.5+1.5*POW)
 Mlas = 50
;NRU% = 26
 NRU% = 0 ; Bug
 VE = $57
 LL = 30
 RED = $55
 YELLOW = $AA
 GREEN = $FF
; Colours Masks for Dials
 RED2 = $27
 GREEN2 = $57
 YELLOW2 = $87
 BLACK2 = $B7
; Colours for Missile Blobs
 MAG2 = $40
; Colour for player input
 BLUE = YELLOW
 CYAN = YELLOW
 MAG = YELLOW
 WHITE = $5A
 sfxplas = 0
 sfxelas = 1
 sfxhit = 2
 sfxexpl = 3
 sfxwhosh = 4
 sfxbeep = 5
 sfxboop = 6
 sfxhyp1 = 7
 sfxeng = 8
 sfxecm = 9
 sfxblas = 10
 sfxalas = 11
 sfxmlas = 12
 sfxbomb = 13
 sfxtrib = 14
 sfxelas2 = 15
;XX21 = D%
;OSWRCH = $FFEE
 OSBYTE = $FFF4
 OSWORD = $FFF1
 OSFILE = $FFDD
 SCLI = $FFF7
 SETXC = $85
 SETYC = $86
 clyns = $87
 DODIALS = $8A
 RDPARAMS = $88
 DOmsbar = 242
 wscn = 243
 onescan = 244
 DOhfx = $84
 DOdot = 245
 DOFE21 = $83
 VIAE = $8B
 DOBULB = $8C
 DODKS4 = 246
 DOCATF = $8D
 SETCOL = $8E
 SETVDU19 = $8F
 DOsvn = $90
 X = 128
 Y = 72
 conhieght = 80

 TKN1 = $E00
 RUTOK = TKN1+$C5C
 RUPLA = TKN1+$C28
 RUGAL = TKN1+$C42

 DINT = $2E
 FINT = $2B
 HINT = $23
 OINT = $1A
 YINT = $27
 f1 = $08
 f2 = $05
 f3 = $38
 f4 = $35
 f5 = $30
 f6 = $2D
 f7 = $28
 f8 = $25
 f9 = $20
 f0 = $3C
 f12 = $3B
 f22 = $3A
 f32 = $3D

 XX3 = $100

; ******************************************

 ORG $0002

.ZP

.RAND

 SKIP 4

.T1

 SKIP 1

.SC

 SKIP 2

 SCH = SC+1

.INWK

 SKIP NI%

 NEWB = INWK+36
 XX19 = INWK+33
 XX1 = INWK

.P

 SKIP 3

.XC

 SKIP 1

.COL

 SKIP 1

.YC

 SKIP 1

.QQ17

 SKIP 1

.XX2

 SKIP 16

 K3 = XX2
 K4 = XX2+14

.XX16

 SKIP 18

; ZP up to K3+1 always paged in

.XX0

 SKIP 2

.INF

 SKIP 2

.V

 SKIP 2

.XX

 SKIP 2

.YY

 SKIP 2

.SUNX

 SKIP 2

.BETA

 SKIP 1

.BET1

 SKIP 1

.QQ22

 SKIP 2

.ECMA

 SKIP 1

.ALP1

 SKIP 1

.ALP2

 SKIP 2

.XX15

 SKIP 6

.XX12

 SKIP 6

 X1 = XX15
 Y1 = X1+1
 X2 = Y1+1
 Y2 = X2+1

.K

 SKIP 4

.LAS

 SKIP 1

.MSTG

 SKIP 1

.thiskey

 SKIP 1

.LSP

 SKIP 1

.QQ15

 SKIP 6

.XX18

 SKIP 9

.QQ19

 SKIP 6

 K5 = XX18
 K6 = K5+4

.BET2

 SKIP 2

.DELTA

 SKIP 1

.DELT4

 SKIP 2

.U

 SKIP 1

.Q

 SKIP 1

.R

 SKIP 1

.S

 SKIP 1

.XSAV

 SKIP 1

.YSAV

 SKIP 1

.XX17

 SKIP 1

.QQ11

 SKIP 1

.ZZ

 SKIP 1

.XX13

 SKIP 1

.MCNT

 SKIP 1

.DL

 SKIP 1

.TYPE

 SKIP 1

.ALPHA

 SKIP 1

;.PBUP
;
;SKIP 1
;
;.HBUP
;
;SKIP 1
;
;.LBUP
;
;SKIP 1

.QQ12

 SKIP 1

.TGT

 SKIP 1

.FLAG

 SKIP 1

.CNT

 SKIP 1

.CNT2

 SKIP 1

.STP

 SKIP 1

.XX4

 SKIP 1

.XX20

 SKIP 1

.XX14

 SKIP 1

.RAT

 SKIP 1

.RAT2

 SKIP 1

.K2

 SKIP 4

.widget

 SKIP 1

.dontclip

 SKIP 1

.Yx2M1

 SKIP 1

.messXC

 SKIP 1

.newzp

 SKIP 1

.T

 SKIP 1

; Zero page locations...

 SKIP 6

 .BDdataptr1

 SKIP 1

; Data pointers

 .BDdataptr2

 SKIP 1

 .BDdataptr3

 SKIP 1

 .BDdataptr4

 SKIP 1

 .counter

 SKIP 1 ; main counter

; Vibrato

 .vibrato2

 SKIP 1

 .vibrato3

 SKIP 1

; voice notes

 .voice2lo1

 SKIP 1

 .voice2hi1

 SKIP 1

 .voice2lo2

 SKIP 1

 .voice2hi2

 SKIP 1

 .voice3lo1

 SKIP 1

 .voice3hi1

 SKIP 1

 .voice3lo2

 SKIP 1

 .voice3hi2

 SKIP 1

 .BDBUFF

 SKIP 1

; ******************************************

 ORG $400

.UP

;.QQ16

 SKIP 65

.KL

 SKIP 17

.FRIN

 SKIP NOSH+1

.MANY

 SKIP NTY+1

 SSPR = MANY+SST

.JUNK

 SKIP 1

.auto

 SKIP 1

.ECMP

 SKIP 1

.MJ

 SKIP 1

.CABTMP

 SKIP 1

.LAS2

 SKIP 1

.MSAR

 SKIP 1

.VIEW

 SKIP 1

.LASCT

 SKIP 1

.GNTMP

 SKIP 1

.HFX

 SKIP 1

.EV

 SKIP 1

.DLY

 SKIP 1

.de

 SKIP 1

.JSTX

 SKIP 1

.JSTY

 SKIP 1

.XSAV2

 SKIP 1

.YSAV2

 SKIP 1

.NAME

 SKIP 8

.TP

 SKIP 1

.QQ0

 SKIP 1

.QQ1

 SKIP 1

.QQ21

 SKIP 6

.CASH

 SKIP 4

.QQ14

 SKIP 1

.COK

 SKIP 1

.GCNT

 SKIP 1

.LASER

 SKIP 6

.CRGO

 SKIP 1

.QQ20

 SKIP 17

.ECM

 SKIP 1

.BST

 SKIP 1

.BOMB

 SKIP 1

.ENGY

 SKIP 1

.DKCMP

 SKIP 1

.GHYP

 SKIP 1

.ESCP

 SKIP 2

.TRIBBLE

 SKIP 2

.TALLYL

 SKIP 1

.NOMSL

 SKIP 1

.FIST

 SKIP 1

.AVL

 SKIP 17

.QQ26

 SKIP 1

.TALLY

 SKIP 2

.SVC

 SKIP 1

 SKIP 1

 SKIP 1

 SKIP 1

.MCH

 SKIP 1

 NT% = MCH-1-TP

.FSH

 SKIP 1

.ASH

 SKIP 1

.ENERGY

 SKIP 1

.COMX

 SKIP 1

.COMY

 SKIP 1

.QQ24

 SKIP 1

.QQ25

 SKIP 1

.QQ28

 SKIP 1

.QQ29

 SKIP 1

.gov

 SKIP 1

.tek

 SKIP 1

.SLSP

 SKIP 2

.QQ2

 SKIP 6

.safehouse

 SKIP 6

.QQ3

 SKIP 1

.QQ4

 SKIP 1

.QQ5

 SKIP 1

.QQ6

 SKIP 2

.QQ7

 SKIP 2

.QQ8

 SKIP 2

.QQ9

 SKIP 1

.QQ10

 SKIP 1

.NOSTM

 SKIP 1

.COL2

 SKIP 1

.frump

 SKIP 1

.sprx

 SKIP 1

.spry

 SKIP 1

.TRIBCT

 SKIP 1

.TRIBVX

 SKIP 16

.TRIBVXH

 SKIP 16

.TRIBXH

 SKIP 16

; ******************************************

 ORG $580

.WP

.LSO

 SKIP 200

 LSX = LSO

.BUF

 SKIP 90

.SX

 SKIP NOST+1

.SXL

 SKIP NOST+1

.SY

 SKIP NOST+1

.SYL

 SKIP NOST+1

.SZ

 SKIP NOST+1

.SZL

 SKIP NOST+1

; $70

.LASX

 SKIP 1

.LASY

 SKIP 1

.XX24

 SKIP 1

.ALTIT

 SKIP 1

.SWAP

 SKIP 1

.XP

 SKIP 1

.YP

 SKIP 1

.YS

 SKIP 1

.BALI

 SKIP 1

.UPO

 SKIP 1

.boxsize

 SKIP 1

.distaway

 SKIP 1

; ******************************************************************************
;
; ELITE A FILE
;
; Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 ORG CODE%

 LOAD_A% = LOAD%

.MOS

 SKIP 1

.COMC

 SKIP 1

.MUTOKOLD

 SKIP 1

.MUPLA

 SKIP 1

.DFLAG

 SKIP 1

.DNOIZ

 SKIP 1

.DAMP

 SKIP 1 ; runstop

.DJD

 SKIP 1 ; A

.PATG

 SKIP 1 ; X

.FLH

 SKIP 1 ; F

.JSTGY

 SKIP 1 ; Y

.JSTE

 SKIP 1 ; J

.JSTK

 SKIP 1 ; K

.MUTOK

 SKIP 1 ; M

.DISK

 SKIP 1 ; D

.PLTOG

 SKIP 1 ; P

.MUFOR

 SKIP 1 ; C

IF _GMA85_NTSC OR _GMA86_PAL

 SKIP 1

ENDIF

.MUSILLY

 SKIP 1 ; B

IF _GMA85_NTSC OR _GMA86_PAL

.L1D13

 SKIP 1

ENDIF

.TGINT

 EQUB $01
 EQUB $36
 EQUB $29
 EQUB $2B
 EQUB $27
 EQUB $1E
 EQUB $1B
 EQUB $1C
 EQUB $2E
 \  RS       A       X       F       Y       J       K      M       D
 EQUB $17
 EQUB $2C

IF _GMA85_NTSC OR _GMA86_PAL

 EQUB $32

ENDIF

 EQUB $24
 \   P       C       B
 RTS  ;checksum here

.S%

 CLD
 LDX #2

.ZONKPZERO

 LDA 0,X
 STA $CE00,X
 INX
 BNE ZONKPZERO ; shove over loader prog
 JSR DEEOR
 JSR COLD
;JSR Checksum
 JMP BEGIN

.DEEOR

 LDA #((G%-1)MOD 256)
 STA FRIN
 LDA #((G%-1)DIV 256)
 STA FRIN+1
 LDA #((R%-1)DIV 256)
 LDY #((R%-1)MOD 256)
 LDX #KEY1
 JSR DEEORS
 LDA #((C%-1)MOD 256)
 STA FRIN
 LDA #((C%-1)DIV 256)
 STA FRIN+1
 LDA #((F%-1)DIV 256)
 LDY #((F%-1)MOD 256)
 LDX #KEY2

.DEEORS

 STX T
 STA SC+1
 LDA #0
 STA SC

.DEEORL

 LDA (SC),Y
 SEC
 SBC T
 STA (SC),Y
 STA T
 TYA
 BNE P%+4
 DEC SC+1
 DEY
 CPY FRIN
 BNE DEEORL
 LDA SC+1
 CMP FRIN+1
 BNE DEEORL
 RTS
 EQUD &2345AAB7 ;red herring

.G%

 \mutilate from here to R% and from C% to F%

.DOENTRY

 \after dock
 JSR RES2
 JSR LAUN
 LDA #0
 STA DELTA
;STA ALPHA
;STA BETA
;STA ALP1
;STA BET1
 STA GNTMP
 STA QQ22+1
 LDA #$FF
 STA FSH
 STA ASH
 STA ENERGY
;JSR HALL
 LDY #44
 JSR DELAY
 LDA TP
 AND #3
 BNE EN1
 LDA TALLY+1
 BEQ EN4
 LDA GCNT
 LSR A
 BNE EN4
 JMP BRIEF

.EN1

 CMP #3
 BNE EN2
 JMP DEBRIEF

.EN2

 LDA GCNT
 CMP #2
 BNE EN4
 LDA TP
 AND #$F
 CMP #2
 BNE EN3
 LDA TALLY+1
 CMP #5
 BCC EN4
 JMP BRIEF2

.EN3

 CMP #6
 BNE EN5
 LDA QQ0
 CMP #215
 BNE EN4
 LDA QQ1
 CMP #84
 BNE EN4
 JMP BRIEF3

.EN5

 CMP #10
 BNE EN4
 LDA QQ0
 CMP #63
 BNE EN4
 LDA QQ1
 CMP #72
 BNE EN4
 JMP DEBRIEF2

.EN4

 LDA CASH+2
 CMP #$C4
 BCC EN6
 LDA TP
 AND #$10
 BNE EN6
 JMP TBRIEF

.EN6

 JMP BAY

.BRKBK

 LDA #(BRBR MOD 256)
 SEI
 STA BRKV
 LDA #(BRBR DIV 256)
 STA BRKV+1
 CLI
 RTS

.TRIBDIR

 EQUB 0
 EQUB 1
 EQUB $FF
 EQUB 0

.TRIBDIRH

 EQUB 0
 EQUB 0
 EQUB $FF
 EQUB 0

.SPMASK

 EQUW $04FB
 EQUW $08F7
 EQUW $10EF
 EQUW $20DF
 EQUW $40BF
 EQUW $807F

.MVTRIBS

 LDA MCNT
 AND #7
 CMP TRIBCT
 BCC P%+5
 JMP NOMVETR
;STA T
 ASL A
 TAY
 LDA #5
 JSR SETL1
 JSR DORND
 CMP #235
 BCC MVTR1
 AND #3
 TAX
 LDA TRIBDIR,X
 STA TRIBVX,Y
 LDA TRIBDIRH,X
 STA TRIBVXH,Y
 JSR DORND
 AND #3
 TAX
 LDA TRIBDIR,X
 STA TRIBVX+1,Y

.MVTR1

 LDA SPMASK,Y
 AND VIC+$10
 STA VIC+$10
 LDA VIC+5,Y
 CLC
 ADC TRIBVX+1,Y
 STA VIC+5,Y
 CLC
 LDA VIC+4,Y
 ADC TRIBVX,Y
 STA T
 LDA TRIBXH,Y
 ADC TRIBVXH,Y
 BPL nominus
 LDA #$48
 STA T
 LDA #1

.nominus

 AND #1
 BEQ oktrib
 LDA T
 CMP #$50
 LDA #1
 BCC oktrib
 LDA #0
 STA T

.oktrib

 STA TRIBXH,Y
 BEQ NOHIBIT
 LDA SPMASK+1,Y
 ORA VIC+$10
 SEI
 STA VIC+$10

.NOHIBIT

 LDA T
 STA VIC+4,Y
 CLI
 LDA #4
 JSR SETL1
 JMP NOMVETR

.M%

 LDA K%
 STA RAND
 LDA TRIBCT
 BEQ NOMVETR
 JMP MVTRIBS

.NOMVETR

 LDX JSTX
 JSR cntr
 JSR cntr
 TXA
 EOR #128
 TAY
 AND #128
 STA ALP2
 STX JSTX
 EOR #128
 STA ALP2+1
 TYA
 BPL P%+7
 EOR #$FF
 CLC
 ADC #1
 LSR A
 LSR A
 CMP #8
 BCS P%+3
 LSR A
 STA ALP1
 ORA ALP2
 STA ALPHA
 LDX JSTY
 JSR cntr
 TXA
 EOR #128
 TAY
 AND #128
 STX JSTY
 STA BET2+1
 EOR #128
 STA BET2
 TYA
 BPL P%+4
 EOR #$FF
 ADC #4
 LSR A
 LSR A
 LSR A
 LSR A
 CMP #3
 BCS P%+3
 LSR A
 STA BET1
 ORA BET2
 STA BETA
 LDA KY2
 BEQ MA17
 LDA DELTA
 CMP #40
 BCS MA17
 INC DELTA

.MA17

 LDA KY1
 BEQ MA4
 DEC DELTA
 BNE MA4
 INC DELTA

.MA4

 LDA KY15
 AND NOMSL
 BEQ MA20
 LDY #GREEN2
 JSR ABORT
 LDY #sfxboop
 JSR NOISE
 LDA #0
 STA MSAR

.MA20

 LDA MSTG
 BPL MA25
 LDA KY14
 BEQ MA25
 LDX NOMSL
 BEQ MA25
 STA MSAR
 LDY #YELLOW2
 JSR MSBAR

.MA25

 LDA KY16
 BEQ MA24
 LDA MSTG
 BMI MA64
 JSR FRMIS

.MA24

 LDA KY12
 BEQ MA76
 ASL BOMB
 BEQ MA76
 LDY #$D0
 STY moonflower
 LDY #sfxbomb
 JSR NOISE

.MA76

 LDA KY20
 BEQ MA78
 LDA #0
 STA auto
 JSR stopbd

.MA78

 LDA KY13
 AND ESCP
 BEQ noescp
 LDA MJ
 BNE noescp
 JMP ESCAPE

.noescp

 LDA KY18
 BEQ P%+5
 JSR WARP
 LDA KY17
 AND ECM
 BEQ MA64
 LDA ECMA
 BNE MA64
 DEC ECMP
 JSR ECBLB2

.MA64

 LDA KY19
 AND DKCMP
 BEQ MA68
 EOR KLO+$29
 BEQ MA68
 STA auto
 JSR startbd

.MA68

 \kill phantom Cs
 LDA #0
 STA LAS
 STA DELT4
 LDA DELTA
 LSR A
 ROR DELT4
 LSR A
 ROR DELT4
 STA DELT4+1
 LDA LASCT
 BNE MA3
 LDA KY7
 BEQ MA3
 LDA GNTMP
 CMP #242
 BCS MA3
 LDX VIEW
 LDA LASER,X
 BEQ MA3
 PHA
 AND #127
 STA LAS
 STA LAS2
 LDY #sfxplas
 PLA
 PHA
 BMI bmorarm
 CMP #Mlas
 BNE P%+4
 LDY #sfxmlas
 BNE custard

.bmorarm

 CMP #Armlas
 BEQ P%+5
 LDY #sfxblas
 EQUB $2C
 LDY #sfxalas

.custard

 JSR NOISE
 JSR LASLI
 PLA
 BPL ma1
 LDA #0

.ma1

 AND #$FA
 STA LASCT

.MA3

 LDX #0

.MAL1

 STX XSAV
 LDA FRIN,X
 BNE P%+5
 JMP MA18
 STA TYPE
 JSR GINF
 LDY #(NI%-1)

.MAL2

 LDA (INF),Y
 STA INWK,Y
 DEY
 BPL MAL2
 LDA TYPE
 BMI MA21
 ASL A
 TAY
 LDA XX21-2,Y
 STA XX0
 LDA XX21-1,Y
 STA XX0+1
 LDA BOMB
 BPL MA21
 CPY #2*SST
 BEQ MA21
 CPY #2*THG
 BEQ MA21
 CPY #2*CON
 BCS MA21
 LDA INWK+31
 AND #32
 BNE MA21
 ASL INWK+31
 SEC
 ROR INWK+31
 LDX TYPE
 JSR EXNO2

.MA21

 JSR MVEIT
 LDY #(NI%-1)

.MAL3

 LDA INWK,Y
 STA (INF),Y
 DEY
 BPL MAL3
 LDA INWK+31
 AND #$A0
 JSR MAS4
 BNE MA65
 LDA INWK
 ORA INWK+3
 ORA INWK+6
 BMI MA65
 LDX TYPE
 BMI MA65
 CPX #SST
 BEQ ISDK
 AND #$C0
 BNE MA65
 CPX #MSL
 BEQ MA65
 LDA BST
 AND INWK+5
 BPL MA58
 CPX #OIL
 BEQ oily
 LDY #0
 LDA (XX0),Y
 LSR A
 LSR A
 LSR A
 LSR A
 BEQ MA58
 ADC #1
 BNE slvy2

.oily

 JSR DORND
 AND #7

.slvy2

 JSR tnpr1
 LDY #78
 BCS MA59
 LDY QQ29
 ADC QQ20,Y
 STA QQ20,Y
 TYA
 ADC #208
 JSR MESS
 ASL NEWB
 SEC
 ROR NEWB

.MA65

 JMP MA26

.ISDK

 LDA K%+NI%+36
 AND #4
 BNE MA62
 LDA INWK+14
 CMP #$D6
 BCC MA62
 JSR SPS1
 LDA XX15+2
 CMP #89 ;86
 BCC MA62
 LDA INWK+16
 AND #$7F
 CMP #80
 BCC MA62

.GOIN

 JSR stopbd
 JMP DOENTRY

.MA62

 LDA DELTA
 CMP #5
 BCC MA67
 JMP DEATH

.MA59

 JSR EXNO3

.MA60

 ASL INWK+31
 SEC
 ROR INWK+31

.MA61

 BNE MA26

.MA67

 LDA #1
 STA DELTA
 LDA #5
 BNE MA63

.MA58

 ASL INWK+31
 SEC
 ROR INWK+31
 LDA INWK+35
 SEC
 ROR A

.MA63

 JSR OOPS
 JSR EXNO3

.MA26

 LDA NEWB
 BPL P%+5
 JSR SCAN
 LDA QQ11
 BNE MA15
 JSR PLUT
 JSR HITCH
 BCC MA8
 LDA MSAR
 BEQ MA47
 JSR BEEP
 LDX XSAV
 LDY #RED2
 JSR ABORT2

.MA47

 LDA LAS
 BEQ MA8
 LDX #15
 JSR EXNO
 LDA TYPE
 CMP #SST
 BEQ MA14+2
 CMP #CON
 BCC BURN
 LDA LAS
 CMP #(Armlas AND127)
 BNE MA14+2
 LSR LAS
 LSR LAS

.BURN

 LDA INWK+35
 SEC
 SBC LAS
 BCS MA14
 ASL INWK+31
 SEC
 ROR INWK+31
 LDA TYPE
 CMP #AST
 BNE nosp
 LDA LAS
 CMP #Mlas
 BNE nosp
 JSR DORND
 LDX #SPL
 AND #3
 JSR SPIN2

.nosp

 LDY #PLT
 JSR SPIN
 LDY #OIL
 JSR SPIN
 LDX TYPE
 JSR EXNO2

.MA14

 STA INWK+35
 LDA TYPE
 JSR ANGRY

.MA8

 JSR LL9

.MA15

 LDY #35
 LDA INWK+35
 STA (INF),Y
 LDA NEWB
 BMI KS1S
 LDA INWK+31
 BPL MAC1
 AND #$20
 BEQ MAC1
 LDA NEWB
 AND #64
 ORA FIST
 STA FIST
 LDA DLY
 ORA MJ
 BNE KS1S
 LDY #10
 LDA (XX0),Y
 BEQ KS1S
 TAX
 INY
 LDA (XX0),Y
 TAY
 JSR MCASH
 LDA #0
 JSR MESS

.KS1S

 JMP KS1

.MAC1

 LDA TYPE
 BMI MA27
 JSR FAROF
 BCC KS1S

.MA27

 LDY #31
 LDA INWK+31
 STA (INF),Y
 LDX XSAV
 INX
 JMP MAL1

.MA18

 LDA BOMB
 BPL MA77
 ASL BOMB
 BMI MA77
 JSR BOMBOFF

.MA77

 LDA MCNT
 AND #7
 BNE MA22
 LDX ENERGY
 BPL b
 LDX ASH
 JSR SHD
 STX ASH
 LDX FSH
 JSR SHD
 STX FSH

.b

 SEC
 LDA ENGY
 ADC ENERGY
 BCS P%+5
 STA ENERGY
 LDA MJ
 BNE MA23S
 LDA MCNT
 AND #31
 BNE MA93
 LDA SSPR
 BNE MA23S
 TAY
 JSR MAS2
 BNE MA23S
 LDX #28

.MAL4

 LDA K%,X
 STA INWK,X
 DEX
 BPL MAL4
 INX
 LDY #9
 JSR MAS1
 BNE MA23S
 LDX #3
 LDY #11
 JSR MAS1
 BNE MA23S
 LDX #6
 LDY #13
 JSR MAS1
 BNE MA23S
 LDA #$C0
 JSR FAROF2
 BCC MA23S
 JSR WPLS
 JSR NWSPS

.MA23S

 JMP MA23

.MA22

 LDA MJ
 BNE MA23S
 LDA MCNT
 AND #31

.MA93

 CMP #10
 BNE MA29
 LDA #50
 CMP ENERGY
 BCC P%+6
 ASL A
 JSR MESS
 LDY #$FF
 STY ALTIT
 INY
 JSR m
 BNE MA23
 JSR MAS3
 BCS MA23
 SBC #$24
 BCC MA28
 STA R
 JSR LL5
 LDA Q
 STA ALTIT
 BNE MA23

.MA28

 JMP DEATH

.MA29

 CMP #15
 BNE MA33
 LDA auto
 BEQ MA23
 LDA #123
 BNE MA34

.MA33

 CMP #20
 BNE MA23
 LDA #30
 STA CABTMP
 LDA SSPR
 BNE MA23
 LDY #NI%
 JSR MAS2
 BNE MA23
 JSR MAS3
 EOR #$FF
 ADC #30
 STA CABTMP
 BCS MA28
 CMP #$E0
 BCC MA23
 CMP #$F0
 BCC nokilltr
 LDA #5
 JSR SETL1
 LDA VIC+$15
 AND #$3
 STA VIC+$15
 LDA #4
 JSR SETL1
 LSR TRIBBLE+1
 ROR TRIBBLE

.nokilltr

 LDA BST
 BEQ MA23
 LDA DELT4+1
 LSR A
 ADC QQ14
 CMP #70
 BCC P%+4
 LDA #70
 STA QQ14
 LDA #160

.MA34

 JSR MESS  ;--BT

.MA23

 LDA LAS2
 BEQ MA16
 LDA LASCT
 CMP #8
 BCS MA16
 JSR LASLI2
 LDA #0
 STA LAS2

.MA16

 LDA ECMP
 BEQ MA69
 JSR DENGY
 BEQ MA70

.MA69

 LDA ECMA
 BEQ MA66
 DEC ECMA
 BNE MA66

.MA70

 JSR ECMOF

.MA66

 LDA QQ11
 BNE oh
 JMP STARS
;JMP PBFL

.SPIN

 JSR DORND
 BPL oh
 TYA
 TAX
 LDY #0
 AND (XX0),Y
 AND #15

.SPIN2

 STA CNT

.spl

 BEQ oh
 LDA #0
 JSR SFS1
 DEC CNT
 BNE spl+2

.oh

 RTS

.BOMBOFF

 LDA #$C0
 STA moonflower
 LDA #0
 STA welcome
 RTS

.MT27

 LDA #217
 BNE P%+4

.MT28

 LDA #220
 CLC
 ADC GCNT
 BNE DETOK

.DETOK3

 PHA
 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 LDA #(RUTOK MOD 256)
 STA V
 LDA #(RUTOK DIV 256)
 BNE DTEN
 \.....................

.DETOK

 PHA
 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 LDA #(TKN1 MOD 256)
 STA V
 LDA #(TKN1 DIV 256)

.DTEN

 STA V+1
 LDY #0

.DTL1

 LDA (V),Y
 EOR #VE
 BNE DT1
 DEX
 BEQ DTL2

.DT1

 INY
 BNE DTL1
 INC V+1
 BNE DTL1

.DTL2

 INY
 BNE P%+4
 INC V+1
 LDA (V),Y
 EOR #VE
 BEQ DTEX
 JSR DETOK2
 JMP DTL2

.DTEX

 PLA
 STA V+1
 PLA
 STA V
 PLA
 TAY
 PLA
 RTS
 \.............

.DETOK2

 CMP #32
 BCC DT3
 BIT DTW3
 BPL DT8
 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 TXA
 JSR TT27
 JMP DT7 ;TT27

.DT8

 CMP #91
 BCC DTS
 CMP #129
 BCC DT6
 CMP #215
 BCC DETOK
 SBC #215
 ASL A
 PHA
 TAX
 LDA TKN2,X
 JSR DTS
 PLA
 TAX
 LDA TKN2+1,X ;letter pair

.DTS

 CMP #$41
 BCC DT9
 BIT DTW6
 BMI DT10
 BIT DTW2
 BMI DT5

.DT10

 ORA DTW1

.DT5

 AND DTW8

.DT9

 JMP DASC ;ascii

.DT3

 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA  ;Magic
 TXA
 ASL A
 TAX
 LDA JMTB-2,X
 STA DTM+1
 LDA JMTB-1,X
 STA DTM+2
 TXA
 LSR A

.DTM

 JSR DASC

.DT7

 PLA
 STA V+1
 PLA
 STA V
 PLA
 TAY
 RTS

.DT6

 STA SC
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 JSR DORND
 TAX
 LDA #0
 CPX #51
 ADC #0
 CPX #102
 ADC #0
 CPX #153
 ADC #0
 CPX #204
 LDX SC
 ADC MTIN-91,X
 JSR DETOK
 JMP DT7 ;Multitoken
 \....................

.MT1

 LDA #0
 EQUB $2C

.MT2

 LDA #32
 STA DTW1
 LDA #0
 STA DTW6
 RTS

.MT8

 LDA #6
 JSR DOXC
 LDA #$FF
 STA DTW2
 RTS

.MT9

 LDA #1
 JSR DOXC
 JMP TT66

.MT13

 LDA #128
 STA DTW6
 LDA #32
 STA DTW1
 RTS

.MT6

 LDA #128
 STA QQ17
 LDA #$FF
 EQUB $2C

.MT5

 LDA #0
 STA DTW3
 RTS

.MT14

 LDA #128
 EQUB $2C

.MT15

 LDA #0
 STA DTW4
 ASL A
 STA DTW5
 RTS

.MT17

 LDA QQ17
 AND #191
 STA QQ17
 LDA #3
 JSR TT27
 LDX DTW5
 LDA BUF-1,X
 JSR VOWEL
 BCC MT171
 DEC DTW5

.MT171

 LDA #153
 JMP DETOK

.MT18

 JSR MT19
 JSR DORND
 AND #3
 TAY

.MT18L

 JSR DORND
 AND #62
 TAX
 LDA TKN2+2,X
 JSR DTS
 LDA TKN2+3,X
 JSR DTS
 DEY
 BPL MT18L
 RTS

.MT19

 LDA #$DF
 STA DTW8
 RTS

.VOWEL

 ORA #32
 CMP #'a'
 BEQ VRTS
 CMP #'e'
 BEQ VRTS
 CMP #'i'
 BEQ VRTS
 CMP #'o'
 BEQ VRTS
 CMP #'u'
 BEQ VRTS
 CLC

.VRTS

 RTS

.WHITETEXT

;LDA #32
;JSR DOVDU19
;LDA #RED
;JMP DOCOL
 RTS
 \............

.JMTB

 EQUW MT1
 EQUW MT2
 EQUW TT27
 EQUW TT27
 EQUW MT5
 EQUW MT6
 EQUW DASC
 EQUW MT8
 EQUW MT9
 EQUW DASC
 EQUW NLIN4
 EQUW DASC
 EQUW MT13
 EQUW MT14
 EQUW MT15
 EQUW MT16
 EQUW MT17
 EQUW MT18
 EQUW MT19
 EQUW DASC
 EQUW CLYNS
 EQUW PAUSE
 EQUW MT23
 EQUW PAUSE2
 EQUW BRIS
 EQUW MT26
 EQUW MT27
 EQUW MT28
 EQUW MT29
 EQUW FILEPR
 EQUW OTHERFILEPR
 EQUW DASC
 \.............

.TKN2

 EQUB 12
 EQUB 10
 EQUS "ABOUSEITILETSTONLONUTHNO"

.QQ16

 EQUS "ALLEXEGEZACEBISOUSESARMAINDIREA?ERATENBERALAVETIEDORQUANTEISRION"
 \.............
 EQUS ":0.E."

.NA%

 EQUS ("jameson")
 EQUB 13
 EQUB 0
 EQUD 0
 EQUD 0 ;Base seed
 EQUD 0 ;Cash
 EQUW 0
 EQUB 0 ;Fuel-Gal
 EQUD 0
 EQUW 0
 EQUB 0 ;Laser-Cargo
 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUB 0 ; crgo
 EQUD 0 ; ECM-ENGY
 EQUW 0
 EQUB 0 ;DCK-escp
 EQUD 0 ; EXPAND
 EQUB 0 ; MISSILES
 EQUB 0 ; FIST
 EQUB 16
 EQUB 15
 EQUB 17
 EQUB 0
 EQUB 3
 EQUB 28
 EQUB 14
 EQUW 0
 EQUB 10
 EQUB 0
 EQUB 17
 EQUB 58
 EQUB 7
 EQUB 9
 EQUB 8
 EQUB 0
 EQUB 0 ;QQ26
 EQUW 0 ;TALLY
 EQUB 128 ;SVC

.CHK2

 EQUB 0

.CHK3

 EQUB 0

.CHK

 EQUB 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 \.........

 \ZIP

.S1%

 EQUS ":0.E."

.NA2%

 EQUS ("JAMESON")
 EQUB 13
 EQUB 0
 EQUB 20 ; QQ0
 EQUB 173 ; QQ1
 EQUD &2485A4A ; QQ21
 EQUW $B753 ;Base seed
 EQUD (((&E8030000) AND (NOT(Q%))) + ((&CA9A3B) AND Q%))\CASH,&80969800
 EQUB 70 ;fuel
 EQUB Q%AND128 ;COK-UP
 EQUB 0 ;GALACTIC COUNT
 EQUB (Armlas AND Q%)+(POW AND(NOT(Q%)))
 EQUB (POW)ANDQ%
 EQUB (POW+128)ANDQ%
 EQUB Mlas ANDQ%
 EQUW 0 ;LASER
 EQUB 22+(15ANDQ%) ;37 CRGO
 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUB 0 ; crgo
 EQUB Q% ;ECM
 EQUB Q% ;BST
 EQUB Q%AND127 ;BOMB
 EQUB Q%AND1 ;ENGY++
 EQUB Q% ;DCK COMP
 EQUB Q% ;GHYP
 EQUB Q% ;ESCP
 EQUD FALSE ;EXPAND
 EQUB 3+(Q%AND1) ;MISSILES
 EQUB FALSE ;FIST
 EQUB 16
 EQUB 15
 EQUB 17
 EQUB 0
 EQUB 3
 EQUB 28
 EQUB 14
 EQUW 0
 EQUB 10
 EQUB 0
 EQUB 17
 EQUB 58
 EQUB 7
 EQUB 9
 EQUB 8
 EQUB 0
 EQUB 0 ;QQ26
 EQUW 0
 \(20000ANDQ%) \TALLY
 EQUB 128 ;SVC

 \.CHK2

 EQUB $03 EOR $A9       ; The checksum value for the default commander, EOR'd
                        ; with $A9 to make it harder to tamper with the checksum
                        ; byte, #74

 \.CHK3

 EQUB $27

 \.CHK
 EQUB $03

 EQUD 0
 EQUD 0
 EQUD 0

.NAEND%

 EQUD 0

.scacol

 EQUB 0
 EQUB GREEN
 EQUB GREEN
 EQUB BLUE
 EQUB BLUE
 EQUB BLUE ;barrel
 EQUB RED
 EQUB RED
 EQUB RED
 EQUB CYAN
 EQUB CYAN ;transp
 EQUB CYAN
 EQUB MAG
 EQUB MAG
 EQUB MAG
 EQUB RED
 EQUB CYAN ;Viper
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB BLUE ;Wor
 EQUB CYAN
 EQUB CYAN
 EQUB MAG
 EQUB CYAN
 EQUB CYAN ;Moray
 EQUB WHITE
 EQUB CYAN
 EQUB CYAN ;Con
 EQUB 0
 EQUB CYAN
 EQUD 0

.LSX2 

IF _MATCH_ORIGINAL_BINARIES

 IF _GMA85_NTSC OR _GMA86_PAL

  EQUB $76, $85, $9C, $A5, $8B, $85, $9A, $A5
  EQUB $8D, $20, $0C, $9A, $B0, $D2, $85, $6F
  EQUB $A5, $9C, $85, $70, $A5, $6B, $85, $9B
  EQUB $A5, $72, $85, $9C, $A5, $85, $85, $9A
  EQUB $A5, $87, $20, $0C, $9A, $B0, $B9, $85
  EQUB $6B, $A5, $9C, $85, $6C, $A5, $6D, $85
  EQUB $9B, $A5, $74, $85, $9C, $A5, $88, $85
  EQUB $9A, $A5, $8A, $20, $0C, $9A, $B0, $A0
  EQUB $85, $6D, $A5, $9C, $85, $6E, $A5, $71
  EQUB $85, $9A, $A5, $6B, $20, $EA, $39, $85
  EQUB $BB, $A5, $72, $45, $6C, $85, $9C, $A5
  EQUB $73, $85, $9A, $A5, $6D, $20, $EA, $39
  EQUB $85, $9A, $A5, $BB, $85, $9B, $A5, $74
  EQUB $45, $6E, $20, $0C, $9A, $85, $BB, $A5
  EQUB $75, $85, $9A, $A5, $6F, $20, $EA, $39
  EQUB $85, $9A, $A5, $BB, $85, $9B, $A5, $70
  EQUB $45, $76, $20, $0C, $9A, $48, $98, $4A
  EQUB $4A, $AA, $68, $24, $9C, $30, $02, $A9
  EQUB $00, $95, $35, $C8, $C4, $AE, $B0, $FE
  EQUB $4C, $F2, $9B, $A4, $47, $A6, $48, $A5
  EQUB $4B, $85, $47, $A5, $4C, $85, $48, $84
  EQUB $4B, $86, $4C, $A4, $49, $A6, $4A, $A5
  EQUB $51, $85, $49, $A5, $52, $85, $4A, $84
  EQUB $51, $86, $52, $A4, $4F, $A6, $50, $A5
  EQUB $53, $85, $4F, $A5, $54, $85, $50, $84
  EQUB $53, $86, $54, $A0, $08, $B1, $57, $85
  EQUB $AE, $A5, $57, $18, $69, $14, $85, $5B
  EQUB $A5, $58, $69, $00, $85, $5C, $A0, $00
  EQUB $84, $AA, $84, $9F, $B1, $5B, $85, $6B
  EQUB $C8, $B1, $5B, $85, $6D, $C8, $B1, $5B
  EQUB $85, $6F, $C8, $B1, $5B, $85, $BB, $29
  EQUB $1F, $C5, $AD, $90, $FB, $C8, $B1, $5B

 ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

  EQUB $60, $6D, $A5, $8A, $85, $6E, $A5, $8B
  EQUB $85, $6F, $A5, $8D, $85, $70, $4C, $40
  EQUB $A5, $46, $85, $46, $8B, $46, $88, $A2
  EQUB $01, $A5, $71, $85, $6B, $A5, $73, $85
  EQUB $6D, $A5, $75, $CA, $30, $FE, $46, $6B
  EQUB $46, $6D, $4A, $CA, $10, $F8, $85, $9B
  EQUB $A5, $76, $85, $9C, $A5, $8B, $85, $9A
  EQUB $A5, $8D, $20, $0C, $A3, $B0, $D2, $85
  EQUB $6F, $A5, $9C, $85, $70, $A5, $6B, $85
  EQUB $9B, $A5, $72, $85, $9C, $A5, $85, $85
  EQUB $9A, $A5, $87, $20, $0C, $A3, $B0, $B9
  EQUB $85, $6B, $A5, $9C, $85, $6C, $A5, $6D
  EQUB $85, $9B, $A5, $74, $85, $9C, $A5, $88
  EQUB $85, $9A, $A5, $8A, $20, $0C, $A3, $B0
  EQUB $A0, $85, $6D, $A5, $9C, $85, $6E, $A5
  EQUB $71, $85, $9A, $A5, $6B, $20, $E7, $39
  EQUB $85, $BB, $A5, $72, $45, $6C, $85, $9C
  EQUB $A5, $73, $85, $9A, $A5, $6D, $20, $E7
  EQUB $39, $85, $9A, $A5, $BB, $85, $9B, $A5
  EQUB $74, $45, $6E, $20, $0C, $A3, $85, $BB
  EQUB $A5, $75, $85, $9A, $A5, $6F, $20, $E7
  EQUB $39, $85, $9A, $A5, $BB, $85, $9B, $A5
  EQUB $70, $45, $76, $20, $0C, $A3, $48, $98
  EQUB $4A, $4A, $AA, $68, $24, $9C, $30, $02
  EQUB $A9, $00, $95, $35, $C8, $C4, $AE, $B0
  EQUB $FE, $4C, $F2, $A4, $A4, $47, $A6, $48
  EQUB $A5, $4B, $85, $47, $A5, $4C, $85, $48
  EQUB $84, $4B, $86, $4C, $A4, $49, $A6, $4A
  EQUB $A5, $51, $85, $49, $A5, $52, $85, $4A
  EQUB $84, $51, $86, $52, $A4, $4F, $A6, $50
  EQUB $A5, $53, $85, $4F, $A5, $54, $85, $50
  EQUB $84, $53, $86, $54, $A0, $08, $B1, $57

 ENDIF

ELSE
 
 SKIP 256               ; The ball line heap for storing x-coordinates (see the
                        ; deep dive on "The ball line heap" for details)

ENDIF

.LSY2

IF _MATCH_ORIGINAL_BINARIES

 IF _GMA85_NTSC OR _GMA86_PAL

  EQUB $85, $2E, $29, $0F, $AA, $B5, $35, $D0
  EQUB $FE, $A5, $2E, $4A, $4A, $4A, $4A, $AA
  EQUB $B5, $35, $D0, $FE, $C8, $B1, $5B, $85
  EQUB $2E, $29, $0F, $AA, $B5, $35, $D0, $FE
  EQUB $A5, $2E, $4A, $4A, $4A, $4A, $AA, $B5
  EQUB $35, $D0, $FE, $4C, $8E, $9D, $A5, $BB
  EQUB $85, $6C, $0A, $85, $6E, $0A, $85, $70
  EQUB $20, $2C, $9A, $A5, $0B, $85, $6D, $45
  EQUB $72, $30, $FE, $18, $A5, $71, $65, $09
  EQUB $85, $6B, $A5, $0A, $69, $00, $85, $6C
  EQUB $4C, $B3, $9D, $A5, $09, $38, $E5, $71
  EQUB $85, $6B, $A5, $0A, $E9, $00, $85, $6C
  EQUB $B0, $FE, $49, $FF, $85, $6C, $A9, $01
  EQUB $E5, $6B, $85, $6B, $90, $02, $E6, $6C
  EQUB $A5, $6D, $49, $80, $85, $6D, $A5, $0E
  EQUB $85, $70, $45, $74, $30, $FE, $18, $A5
  EQUB $73, $65, $0C, $85, $6E, $A5, $0D, $69
  EQUB $00, $85, $6F, $4C, $EE, $9D, $A5, $0C
  EQUB $38, $E5, $73, $85, $6E, $A5, $0D, $E9
  EQUB $00, $85, $6F, $B0, $FE, $49, $FF, $85
  EQUB $6F, $A5, $6E, $49, $FF, $69, $01, $85
  EQUB $6E, $A5, $70, $49, $80, $85, $70, $90
  EQUB $FE, $E6, $6F, $A5, $76, $30, $FE, $A5
  EQUB $75, $18, $65, $0F, $85, $BB, $A5, $10
  EQUB $69, $00, $85, $99, $4C, $27, $9E, $A6
  EQUB $9A, $F0, $FE, $A2, $00, $4A, $E8, $C5
  EQUB $9A, $B0, $FA, $86, $9C, $20, $AF, $99
  EQUB $A6, $9C, $A5, $9B, $0A, $26, $99, $30
  EQUB $FE, $CA, $D0, $F8, $85, $9B, $60, $A9
  EQUB $32, $85, $9B, $85, $99, $60, $A9, $80
  EQUB $38, $E5, $9B, $9D, $00, $01, $E8, $A9
  EQUB $00, $E5, $99, $9D, $00, $01, $4C, $61

 ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

  EQUB $85, $AE, $A5, $57, $18, $69, $14, $85
  EQUB $5B, $A5, $58, $69, $00, $85, $5C, $A0
  EQUB $00, $84, $AA, $84, $9F, $B1, $5B, $85
  EQUB $6B, $C8, $B1, $5B, $85, $6D, $C8, $B1
  EQUB $5B, $85, $6F, $C8, $B1, $5B, $85, $BB
  EQUB $29, $1F, $C5, $AD, $90, $FB, $C8, $B1
  EQUB $5B, $85, $2E, $29, $0F, $AA, $B5, $35
  EQUB $D0, $FE, $A5, $2E, $4A, $4A, $4A, $4A
  EQUB $AA, $B5, $35, $D0, $FE, $C8, $B1, $5B
  EQUB $85, $2E, $29, $0F, $AA, $B5, $35, $D0
  EQUB $FE, $A5, $2E, $4A, $4A, $4A, $4A, $AA
  EQUB $B5, $35, $D0, $FE, $4C, $8E, $A6, $A5
  EQUB $BB, $85, $6C, $0A, $85, $6E, $0A, $85
  EQUB $70, $20, $2C, $A3, $A5, $0B, $85, $6D
  EQUB $45, $72, $30, $FE, $18, $A5, $71, $65
  EQUB $09, $85, $6B, $A5, $0A, $69, $00, $85
  EQUB $6C, $4C, $B3, $A6, $A5, $09, $38, $E5
  EQUB $71, $85, $6B, $A5, $0A, $E9, $00, $85
  EQUB $6C, $B0, $FE, $49, $FF, $85, $6C, $A9
  EQUB $01, $E5, $6B, $85, $6B, $90, $02, $E6
  EQUB $6C, $A5, $6D, $49, $80, $85, $6D, $A5
  EQUB $0E, $85, $70, $45, $74, $30, $FE, $18
  EQUB $A5, $73, $65, $0C, $85, $6E, $A5, $0D
  EQUB $69, $00, $85, $6F, $4C, $EE, $A6, $A5
  EQUB $0C, $38, $E5, $73, $85, $6E, $A5, $0D
  EQUB $E9, $00, $85, $6F, $B0, $FE, $49, $FF
  EQUB $85, $6F, $A5, $6E, $49, $FF, $69, $01
  EQUB $85, $6E, $A5, $70, $49, $80, $85, $70
  EQUB $90, $FE, $E6, $6F, $A5, $76, $30, $FE
  EQUB $A5, $75, $18, $65, $0F, $85, $BB, $A5
  EQUB $10, $69, $00, $85, $99, $4C, $27, $A7
  EQUB $A6, $9A, $F0, $FE, $A2, $00, $4A, $E8

 ENDIF

ELSE
 
 SKIP 256               ; The ball line heap for storing y-coordinates (see the
                        ; deep dive on "The ball line heap" for details)

ENDIF

; ******************************************************************************
;
; Save ELTA.bin
;
; ******************************************************************************

 PRINT "ELITE A"
 PRINT "Assembled at ", ~CODE%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_A%

 PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
 SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%

; ******************************************************************************
;
; ELITE B FILE
;
; Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_B% = P%

 LOAD_B% = LOAD% + P% - CODE%

.UNIV

 FOR I%, 0, NOSH

  EQUW K% + I% * NI%    ; Address of block no. I%, of size NI%, in workspace K%

 NEXT

.TWOS

 EQUD &10204080
 EQUD &01020408
 EQUW $4080

.DTWOS

 EQUD &030C30C0

.TWOS2

 EQUD &3060C0C0
 EQUD &03060C18

.CTWOS

 EQUD &030C30C0
 EQUB $C0

.FLKB

 LDA #15
 TAX
;JMP OSBYTE
 RTS

.NLIN3

 JSR TT27

.NLIN4

 LDA #19
 BNE NLIN2

.NLIN

 LDA #23
 JSR INCYC

.NLIN2

 STA Y1
 STA Y2
;LDA #YELLOW
;JSR DOCOL
 LDX #0
 STX X1
 DEX
 STX X2
 JMP LL30
;LDA #CYAN
;JMP DOCOL
;RTS 

.HLOIN2

 JSR EDGES
 STY Y1
 LDA #0
 STA LSO,Y
 JMP HLOIN

.TWFL

 EQUD &F0E0C080
 EQUW $FCF8
 EQUB $FE

.TWFR

 EQUD &1F3F7FFF
 EQUD &0103070F

.PIX1

 JSR ADD
 STA YY+1
 TXA
 STA SYL,Y

.PIXEL2

 LDA X1
 BPL PX1
 EOR #$7F
 CLC
 ADC #1

.PX1

 EOR #128
 TAX
 LDA Y1
 AND #127
 CMP #Y
 BCS PX4
 LDA Y1
 BPL PX2
 EOR #$7F
 ADC #1

.PX2

 STA T
 LDA #(Y+1)
 SBC T

.PIXEL

 STY T1
 TAY
 TXA
 AND #$F8
 CLC
 ADC ylookupl,Y
 STA SC
 LDA ylookuph,Y
 ADC #0
 STA SC+1
 TYA
 AND #7
 TAY
 TXA
 AND #7
 TAX
 LDA ZZ
 CMP #$90
 BCS PX3
 LDA TWOS2,X
 EOR (SC),Y
 STA (SC),Y
 LDA ZZ
 CMP #$50
 BCS PX13
 DEY
 BPL PX3
 LDY #1

.PX3

 LDA TWOS2,X
 EOR (SC),Y
 STA (SC),Y

.PX13

 LDY T1

.PX4

 RTS

.BLINE

 TXA
 ADC K4
 STA K6+2
 LDA K4+1
 ADC T
 STA K6+3
 LDA FLAG
 BEQ BL1
 INC FLAG

.BL5

 LDY LSP
 LDA #$FF
 CMP LSY2-1,Y
 BEQ BL7
 STA LSY2,Y
 INC LSP
 BNE BL7

.BL1

 LDA K5
 STA XX15
 LDA K5+1
 STA XX15+1
 LDA K5+2
 STA XX15+2
 LDA K5+3
 STA XX15+3
 LDA K6
 STA XX15+4
 LDA K6+1
 STA XX15+5
 LDA K6+2
 STA XX12
 LDA K6+3
 STA XX12+1
 JSR LL145
 BCS BL5
 LDA SWAP
 BEQ BL9
 LDA X1
 LDY X2
 STA X2
 STY X1
 LDA Y1
 LDY Y2
 STA Y2
 STY Y1

.BL9

 LDY LSP
 LDA LSY2-1,Y
 CMP #$FF
 BNE BL8
 LDA X1
 STA LSX2,Y
 LDA Y1
 STA LSY2,Y
 INY

.BL8

 LDA X2
 STA LSX2,Y
 LDA Y2
 STA LSY2,Y
 INY
 STY LSP
 JSR LOIN
 LDA XX13
 BNE BL5

.BL7

 LDA K6
 STA K5
 LDA K6+1
 STA K5+1
 LDA K6+2
 STA K5+2
 LDA K6+3
 STA K5+3
 LDA CNT
 CLC
 ADC STP
 STA CNT
 RTS

.FLIP

;LDA MJ
;BNE FLIP-1
 LDY NOSTM

.FLL1

 LDX SY,Y
 LDA SX,Y
 STA Y1
 STA SY,Y
 TXA
 STA X1
 STA SX,Y
 LDA SZ,Y
 STA ZZ
 JSR PIXEL2
 DEY
 BNE FLL1
 RTS

.STARS

 LDX VIEW
 BEQ STARS1
 DEX
 BNE ST11
 JMP STARS6

.ST11

 JMP STARS2

.STARS1

 LDY NOSTM

.STL1

 JSR DV42
 LDA R
 LSR P
 ROR A
 LSR P
 ROR A
 ORA #1
 STA Q
 LDA SZL,Y
 SBC DELT4
 STA SZL,Y
 LDA SZ,Y
 STA ZZ
 SBC DELT4+1
 STA SZ,Y
 JSR MLU1
 STA YY+1
 LDA P
 ADC SYL,Y
 STA YY
 STA R
 LDA Y1
 ADC YY+1
 STA YY+1
 STA S
 LDA SX,Y
 STA X1
 JSR MLU2
 STA XX+1
 LDA P
 ADC SXL,Y
 STA XX
 LDA X1
 ADC XX+1
 STA XX+1
 EOR ALP2+1
 JSR MLS1
 JSR ADD
 STA YY+1
 STX YY
 EOR ALP2
 JSR MLS2
 JSR ADD
 STA XX+1
 STX XX
 LDX BET1
 LDA YY+1
 EOR BET2+1
 JSR MULTS-2
 STA Q
 JSR MUT2
 ASL P
 ROL A
 STA T
 LDA #0
 ROR A
 ORA T
 JSR ADD
 STA XX+1
 TXA
 STA SXL,Y
 LDA YY
 STA R
 LDA YY+1
 STA S
;JSR MAD
;STA  SSTXR
 LDA #0
 STA P
 LDA BETA
 EOR #128
 JSR PIX1
 LDA XX+1
 STA X1
 STA SX,Y
 AND #127
 CMP #120
 BCS KILL1
 LDA YY+1
 STA SY,Y
 STA Y1
 AND #127
 CMP #120
 BCS KILL1
 LDA SZ,Y
 CMP #16
 BCC KILL1
 STA ZZ

.STC1

 JSR PIXEL2
 DEY
 BEQ P%+5
 JMP STL1
 RTS

.KILL1

 JSR DORND
 ORA #4
 STA Y1
 STA SY,Y
 JSR DORND
 ORA #8
 STA X1
 STA SX,Y
 JSR DORND
 ORA #$90
 STA SZ,Y
 STA ZZ
 LDA Y1
 JMP STC1

.STARS6

 LDY NOSTM

.STL6

 JSR DV42
 LDA R
 LSR P
 ROR A
 LSR P
 ROR A
 ORA #1
 STA Q
 LDA SX,Y
 STA X1
 JSR MLU2
 STA XX+1
 LDA SXL,Y
 SBC P
 STA XX
 LDA X1
 SBC XX+1
 STA XX+1
 JSR MLU1
 STA YY+1
 LDA SYL,Y
 SBC P
 STA YY
 STA R
 LDA Y1
 SBC YY+1
 STA YY+1
 STA S
 LDA SZL,Y
 ADC DELT4
 STA SZL,Y
 LDA SZ,Y
 STA ZZ
 ADC DELT4+1
 STA SZ,Y
 LDA XX+1
 EOR ALP2
 JSR MLS1
 JSR ADD
 STA YY+1
 STX YY
 EOR ALP2+1
 JSR MLS2
 JSR ADD
 STA XX+1
 STX XX
 LDA YY+1
 EOR BET2+1
 LDX BET1
 JSR MULTS-2
 STA Q
 LDA XX+1
 STA S
 EOR #128
 JSR MUT1
 ASL P
 ROL A
 STA T
 LDA #0
 ROR A
 ORA T
 JSR ADD
 STA XX+1
 TXA
 STA SXL,Y
 LDA YY
 STA R
 LDA YY+1
 STA S
;EOR #128
;JSR MAD
;STA SSTXR
 LDA #0
 STA P
 LDA BETA
 JSR PIX1
 LDA XX+1
 STA X1
 STA SX,Y
 LDA YY+1
 STA SY,Y
 STA Y1
 AND #127
 CMP #110
 BCS KILL6
 LDA SZ,Y
 CMP #160
 BCS KILL6
 STA ZZ

.STC6

 JSR PIXEL2
 DEY
 BEQ ST3
 JMP STL6

.ST3

 RTS

.KILL6

 JSR DORND
 AND #127
 ADC #10
 STA SZ,Y
 STA ZZ
 LSR A
 BCS ST4
 LSR A
 LDA #$FC
 ROR A
 STA X1
 STA SX,Y
 JSR DORND
 STA Y1
 STA SY,Y
 JMP STC6

.ST4

 JSR DORND
 STA X1
 STA SX,Y
 LSR A
 LDA #230
 ROR A
 STA Y1
 STA SY,Y
 BNE STC6

.MAS1

 LDA INWK,Y
 ASL A
 STA K+1
 LDA INWK+1,Y
 ROL A
 STA K+2
 LDA #0
 ROR A
 STA K+3
 JSR MVT3
 STA INWK+2,X
 LDY K+1
 STY INWK,X
 LDY K+2
 STY INWK+1,X
 AND #127

.MA9

 RTS

.m

 LDA #0

.MAS2

 ORA K%+2,Y
 ORA K%+5,Y
 ORA K%+8,Y
 AND #127
 RTS

.MAS3

 LDA K%+1,Y
 JSR SQUA2
 STA R
 LDA K%+4,Y
 JSR SQUA2
 ADC R
 BCS MA30
 STA R
 LDA K%+7,Y
 JSR SQUA2
 ADC R
 BCC P%+4

.MA30

 LDA #$FF
 RTS

.wearedocked

 LDA #205
 JSR DETOK
 JSR TT67_copy ; Is TT67 in source, needs to point to high memory version
 JMP st6+3

.st4

 LDX #9
 CMP #25
 BCS st3
 DEX
 CMP #10
 BCS st3
 DEX
 CMP #2
 BCS st3
 DEX
 BNE st3

.STATUS

 LDA #8
 JSR TRADEMODE
 JSR TT111
 LDA #7
 JSR DOXC
 LDA #126
 JSR NLIN3
 LDA #15
 LDY QQ12
 BNE wearedocked
 LDA #230
 LDY JUNK
 LDX FRIN+2,Y
 BEQ st6
 LDY ENERGY
 CPY #128
 ADC #1

.st6

 JSR plf
 LDA #125
 JSR spc
 LDA #19
 LDY FIST
 BEQ st5
 CPY #50
 ADC #1

.st5

 JSR plf
 LDA #16
 JSR spc
 LDA TALLY+1
 BNE st4
 TAX
 LDA TALLY
 LSR A
 LSR A
 INX
 LSR A
 BNE P%-2

.st3

 TXA
 CLC
 ADC #21
 JSR plf
 LDA #18
 JSR plf2
 LDA ESCP
 BEQ P%+7
 LDA #112
 JSR plf2
 LDA BST
 BEQ P%+7
 LDA #111
 JSR plf2
 LDA ECM
 BEQ P%+7
 LDA #$6C
 JSR plf2
 LDA #113
 STA XX4

.stqv

 TAY
 LDX BOMB-113,Y
 BEQ P%+5
 JSR plf2
 INC XX4
 LDA XX4
 CMP #117
 BCC stqv
 LDX #0

.st

 STX CNT
 LDY LASER,X
 BEQ st1
 TXA
 CLC
 ADC #96
 JSR spc
 LDA #103
 LDX CNT
 LDY LASER,X
 CPY #128+POW
 BNE P%+4
 LDA #104
 CPY #Armlas
 BNE P%+4
 LDA #117
 CPY #Mlas
 BNE P%+4
 LDA #118
 JSR plf2

.st1

 LDX CNT
 INX
 CPX #4
 BCC st
 RTS

.plf2

 JSR plf
 LDA #6
 JMP DOXC

.MVT3

 LDA K+3
 STA S
 AND #128
 STA T
 EOR INWK+2,X
 BMI MV13
 LDA K+1
 CLC
 ADC INWK,X
 STA K+1
 LDA K+2
 ADC INWK+1,X
 STA K+2
 LDA K+3
 ADC INWK+2,X
 AND #127
 ORA T
 STA K+3
 RTS

.MV13

 LDA S
 AND #127
 STA S
 LDA INWK,X
 SEC
 SBC K+1
 STA K+1
 LDA INWK+1,X
 SBC K+2
 STA K+2
 LDA INWK+2,X
 AND #127
 SBC S
 ORA #128
 EOR T
 STA K+3
 BCS MV14
 LDA #1
 SBC K+1
 STA K+1
 LDA #0
 SBC K+2
 STA K+2
 LDA #0
 SBC K+3
 AND #127
 ORA T
 STA K+3

.MV14

 RTS

.MVS5

 LDA INWK+1,X
 AND #127
 LSR A
 STA T
 LDA INWK,X
 SEC
 SBC T
 STA R
 LDA INWK+1,X
 SBC #0
 STA S
 LDA INWK,Y
 STA P
 LDA INWK+1,Y
 AND #128
 STA T
 LDA INWK+1,Y
 AND #127
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 ORA T
 EOR RAT2
 STX Q
 JSR ADD
 STA K+1
 STX K
 LDX Q
 LDA INWK+1,Y
 AND #127
 LSR A
 STA T
 LDA INWK,Y
 SEC
 SBC T
 STA R
 LDA INWK+1,Y
 SBC #0
 STA S
 LDA INWK,X
 STA P
 LDA INWK+1,X
 AND #128
 STA T
 LDA INWK+1,X
 AND #127
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 ORA T
 EOR #128
 EOR RAT2
 STX Q
 JSR ADD
 STA INWK+1,Y
 STX INWK,Y
 LDX Q
 LDA K
 STA INWK,X
 LDA K+1
 STA INWK+1,X
 RTS

.TENS

 EQUD &E87648

.pr2

 LDA #3
 LDY #0

.TT11

 STA U
 LDA #0
 STA K
 STA K+1
 STY K+2
 STX K+3

.BPRNT

 LDX #11
 STX T
 PHP
 BCC TT30
 DEC T
 DEC U

.TT30

 LDA #11
 SEC
 STA XX17
 SBC U
 STA U
 INC U
 LDY #0
 STY S
 JMP TT36

.TT35

 ASL K+3
 ROL K+2
 ROL K+1
 ROL K
 ROL S
 LDX #3

.tt35

 LDA K,X
 STA XX15,X
 DEX
 BPL tt35
 LDA S
 STA XX15+4
 ASL K+3
 ROL K+2
 ROL K+1
 ROL K
 ROL S
 ASL K+3
 ROL K+2
 ROL K+1
 ROL K
 ROL S
 CLC
 LDX #3

.tt36

 LDA K,X
 ADC XX15,X
 STA K,X
 DEX
 BPL tt36
 LDA XX15+4
 ADC S
 STA S
 LDY #0

.TT36

 LDX #3
 SEC

.tt37

 LDA K,X
 SBC TENS,X
 STA XX15,X
 DEX
 BPL tt37
 LDA S
 SBC #23
 STA XX15+4
 BCC TT37
 LDX #3

.tt38

 LDA XX15,X
 STA K,X
 DEX
 BPL tt38
 LDA XX15+4
 STA S
 INY
 JMP TT36

.TT37

 TYA
 BNE TT32
 LDA T
 BEQ TT32
 DEC U
 BPL TT34
 LDA #32
 BNE tt34

.TT32

 LDY #0
 STY T
 CLC
 ADC #B

.tt34

 JSR TT26

.TT34

 DEC T
 BPL P%+4
 INC T
 DEC XX17
 BMI rT10
 BNE P%+10
 PLP
 BCC P%+7
 LDA #$2E
 JSR TT26
 JMP TT35

.rT10

 RTS

.DTW1

 EQUB 32

.DTW2

 EQUB $FF

.DTW3

 EQUB 0

.DTW4

 EQUB 0

.DTW5

 EQUB 0

.DTW6

 EQUB 0

.DTW8

 EQUB $FF

.FEED

 LDA #12
 EQUB $2C

.MT16

 LDA #65

 DTW7 = MT16+1

 \ New TT26 entry for right justified text

.DASC 

.TT26

 STX SC
 LDX #$FF
 STX DTW8
 CMP #'.'
 BEQ DA8
 CMP #':'
 BEQ DA8
 CMP #10
 BEQ DA8
 CMP #12
 BEQ DA8
 CMP #32
 BEQ DA8
 INX

.DA8

 STX DTW2
 LDX SC
 BIT DTW4
 BMI P%+5
 JMP CHPR
 BIT DTW4
 BVS P%+6
 CMP #12
 BEQ DA1
 LDX DTW5
 STA BUF,X
 LDX SC
 INC DTW5
 CLC
 RTS

.DA1

 TXA
 PHA
 TYA
 PHA

.DA5

 LDX DTW5
 BEQ DA6+3
 CPX #(LL+1)
 BCC DA6
 LSR SC+1

.DA11

 LDA SC+1
 BMI P%+6
 LDA #64
 STA SC+1
 LDY #(LL-1)

.DAL1

 LDA BUF+LL
 CMP #32
 BEQ DA2

.DAL2

 DEY
 BMI DA11
 BEQ DA11
 LDA BUF,Y
 CMP #32
 BNE DAL2
 ASL SC+1
 BMI DAL2
 STY SC
 LDY DTW5

.DAL6

 LDA BUF,Y
 STA BUF+1,Y
 DEY
 CPY SC
 BCS DAL6
 INC DTW5
;LDA #32

.DAL3

 CMP BUF,Y
 BNE DAL1
 DEY
 BPL DAL3
 BMI DA11

.DA2

 LDX #LL
 JSR DAS1
 LDA #12
 JSR CHPR
 LDA DTW5
;CLC 
 SBC #LL
 STA DTW5
 TAX
 BEQ DA6+3
 LDY #0
 INX

.DAL4

 LDA BUF+LL+1,Y
 STA BUF,Y
 INY
 DEX
 BNE DAL4
 BEQ DA5

.DAS1

 LDY #0

.DAL5

 LDA BUF,Y
 JSR CHPR
 INY
 DEX
 BNE DAL5

.dec27

 RTS

.DA6

 JSR DAS1
 STX DTW5
 PLA
 TAY
 PLA
 TAX
 LDA #12

.DA7

 EQUB $2C

.BELL

 LDA #7
 JMP CHPR
 \..........
 \ ............... DIALS .......................... 

.DIALS

 LDA #((DLOC%+$F0)MOD 256)
 STA SC
 LDA #((DLOC%+$F0)DIV 256)
 STA SC+1
 JSR PZW
 STX K+1
 STA K
 LDA #14
 STA T1
 LDA DELTA
;LSR A
 JSR DIL-1
 LDA #0
 STA R
 STA P
 LDA #8
 STA S
 LDA ALP1
 LSR A
 LSR A
 ORA ALP2
 EOR #128
 JSR ADD
 JSR DIL2
 LDA BETA
 LDX BET1
 BEQ P%+4
 SBC #1
 JSR ADD
 JSR DIL2
 LDA MCNT
 AND #3
 BNE dec27
 LDY #0
 JSR PZW
 STX K
 STA K+1
 LDX #3
 STX T1

.DLL23

 STY XX12,X
 DEX
 BPL DLL23
 LDX #3
 LDA ENERGY
 LSR A
 LSR A
 STA Q

.DLL24

 SEC
 SBC #16
 BCC DLL26
 STA Q
 LDA #16
 STA XX12,X
 LDA Q
 DEX
 BPL DLL24
 BMI DLL9

.DLL26

 LDA Q
 STA XX12,X

.DLL9

 LDA XX12,Y
 STY P
 JSR DIL
 LDY P
 INY
 CPY #4
 BNE DLL9
 LDA #((DLOC%+$30)MOD 256)
 STA SC
 LDA #((DLOC%+$30)DIV 256)
 STA SC+1
 LDA #YELLOW
 STA K
 STA K+1
 LDA FSH
 JSR DILX
 LDA ASH
 JSR DILX
 LDA QQ14
 JSR DILX+2
 JSR PZW
 STX K+1
 STA K
 LDX #11
 STX T1
 LDA CABTMP
 JSR DILX
 LDA GNTMP
 JSR DILX
 LDA #$F0
 STA T1
;STA K+1
 LDA ALTIT
 JSR DILX
 JMP COMPAS

.PZW

 LDX #YELLOW
 LDA MCNT
 AND #8
 AND FLH
 BEQ P%+4
 TXA
 EQUB $2C
 LDA #RED
 RTS

.DILX

 LSR A
 LSR A
 LSR A
 LSR A

.DIL

 STA Q
 LDX #$FF
 STX R
 CMP T1
 BCS DL30
 LDA K+1
 BNE DL31

.DL30

 LDA K

.DL31

 STA COL
 LDY #2
 LDX #3

.DL1

 LDA Q
 CMP #4
 BCC DL2
 SBC #4
 STA Q
 LDA R

.DL5

 AND COL
 STA (SC),Y
 INY
 STA (SC),Y
 INY
 STA (SC),Y
 TYA
 CLC
 ADC #6
 BCC P%+4
 INC SC+1
 TAY
 DEX
 BMI DL6
 BPL DL1

.DL2

 EOR #3
 STA Q
 LDA R

.DL3

 ASL A
 ASL A
 DEC Q
 BPL DL3
 PHA
 LDA #0
 STA R
 LDA #99
 STA Q
 PLA
 JMP DL5

.DL6

 LDA SC
 CLC
 ADC #$40
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1

.DL9

 RTS

.DIL2

 LDY #1
 STA Q

.DLL10

 SEC
 LDA Q
 SBC #4
 BCS DLL11
 LDA #$FF
 LDX Q
 STA Q
 LDA CTWOS,X
 AND #YELLOW
 JMP DLL12

.DLL11

 STA Q
 LDA #0

.DLL12

 STA (SC),Y
 INY
 STA (SC),Y
 INY
 STA (SC),Y
 INY
 STA (SC),Y
 TYA
 CLC
 ADC #5
 TAY
 CPY #30
 BCC DLL10
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 RTS

.ESCAPE

 JSR RES2
 LDX #CYL
 STX TYPE
 JSR FRS1
 BCS ES1
 LDX #CYL2
 JSR FRS1

.ES1

 LDA #8
 STA INWK+27
 LDA #$C2
 STA INWK+30
 LSR A
 STA INWK+32

.ESL1

 JSR MVEIT
 JSR LL9
 DEC INWK+32
 BNE ESL1
 JSR SCAN
 LDA #0
 LDX #16

.ESL2

 STA QQ20,X
 DEX
 BPL ESL2
 STA FIST
 STA ESCP
 LDA TRIBBLE
 ORA TRIBBLE+1
 BEQ nosurviv
 JSR DORND
 AND #7
 ORA #1
 STA TRIBBLE
 LDA #0
 STA TRIBBLE+1

.nosurviv

 LDA #70
 STA QQ14
 JMP GOIN

.HME2

;LDA #CYAN
;JSR DOCOL
 LDA #14
 JSR DETOK
 JSR TT103
 JSR TT81
 LDA #0
 STA XX20

.HME3

 JSR MT14
 JSR cpl
 LDX DTW5
 LDA INWK+5,X
 CMP #13
 BNE HME6

.HME4

 DEX
 LDA INWK+5,X
 ORA #32
 CMP BUF,X
 BEQ HME4
 TXA
 BMI HME5

.HME6

 JSR TT20
 INC XX20
 BNE HME3
 JSR TT111
 JSR TT103
 LDY #sfxboop
 JSR NOISE
 LDA #215
 JMP DETOK
 \Not found

.HME5

 LDA QQ15+3
 STA QQ9
 LDA QQ15+1
 STA QQ10
 JSR TT111
 JSR TT103
 JSR MT15
 JMP T95

; ******************************************************************************
;
; Save ELTB.bin
;
; ******************************************************************************

 PRINT "ELITE B"
 PRINT "Assembled at ", ~CODE_B%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_B%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_B%

 PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
 SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%

; ******************************************************************************
;
; ELITE C FILE
;
; Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_C% = P%

 LOAD_C% = LOAD% +P% - CODE%

.TA352

 LDA INWK
 ORA INWK+3
 ORA INWK+6
 BNE TA872
 LDA #80
 JSR OOPS

.TA872

 LDX #PLT
 BNE TA353

.TA34

 LDA #0
 JSR MAS4
 BEQ P%+5
 JMP TN4 ;fix
 JSR TA873
 JSR EXNO3
 LDA #250
 JMP OOPS

.TA18 ; msl

 LDA ECMA
 BNE TA352
 LDA INWK+32
 ASL A
 BMI TA34
 LSR A
 TAX
 LDA UNIV,X
 STA V
 LDA UNIV+1,X
 JSR VCSUB
 LDA K3+2
 ORA K3+5
 ORA K3+8
 AND #127
 ORA K3+1
 ORA K3+4
 ORA K3+7
 BNE TA64
 LDA INWK+32
 CMP #$82
 BEQ TA352
 LDY #31
 LDA (V),Y
 BIT M32+1
 BNE TA35
 ORA #128
 STA (V),Y

.TA35

 LDA INWK
 ORA INWK+3
 ORA INWK+6
 BNE TA87
 LDA #80
 JSR OOPS

.TA87

 LDA INWK+32
 AND #127
 LSR A
 TAX

.TA353

 JSR EXNO2

.TA873

 ASL INWK+31
 SEC
 ROR INWK+31

.TA1

 RTS

.TA64

 JSR DORND
 CMP #16
 BCS TA19S

.M32

 LDY #32
 LDA (V),Y
 LSR A
 BCS P%+5

.TA19S

 JMP TA19
 JMP ECBLB2

.TACTICS

 LDA #3
 STA RAT
 LDA #4
 STA RAT2
 LDA #22
 STA CNT2
 CPX #MSL
 BEQ TA18
 CPX #SST
 BNE TA13
 LDA NEWB
 AND #4
 BNE TN5
 LDA MANY+SHU+1
 BNE TA1
 JSR DORND
 CMP #253
 BCC TA1
 AND #1
 ADC #SHU-1
 TAX
 BNE TN6

.TN5

 JSR DORND
 CMP #240
 BCC TA1
 LDA MANY+COPS
 CMP #4 ; <<
 BCS TA22
 LDX #COPS

.TN6

 LDA #$F1
 JMP SFS1

.TA13

 CPX #HER
 BNE TA17
 JSR DORND
 CMP #200
 BCC TA22
 LDX #0
 STX INWK+32
 LDX #$24
 STX NEWB
 AND #3
 ADC #SH3
 TAX
 JSR TN6
 LDA #0
 STA INWK+32
 RTS

.TA17

 LDY #14
 LDA INWK+35
 CMP (XX0),Y
 BCS TA21
 INC INWK+35

.TA21

 CPX #TGL
 BNE TA14
 LDA MANY+THG
 BNE TA14
 LSR INWK+32
 ASL INWK+32
 LSR INWK+27

.TA22

 RTS

.TA14

 JSR DORND
 LDA NEWB
 LSR A
 BCC TN1
 CPX #50
 BCS TA22

.TN1

 LSR A
 BCC TN2
 LDX FIST
 CPX #40
 BCC TN2
 LDA NEWB
 ORA #4
 STA NEWB
 LSR A
 LSR A

.TN2

 LSR A
 BCS TN3
 LSR A
 LSR A
 BCC GOPL
 JMP DOCKIT

.GOPL

 JSR SPS1
 JMP TA151

.TN3

 LSR A
 BCC TN4
 LDA SSPR
 BEQ TN4
 LDA INWK+32
 AND #129
 STA INWK+32

.TN4

 LDX #8

.TAL1

 LDA INWK,X
 STA K3,X
 DEX
 BPL TAL1

.TA19

 JSR TAS2 ; XX15 = r~96
 LDY #10
 JSR TAS3
 STA CNT
 LDA TYPE
 CMP #MSL
 BNE P%+5
 JMP TA20
 CMP #ANA
 BNE TN7
 JSR DORND
 CMP #200
 BCC TN7
 JSR DORND
 LDX #WRM
 CMP #100
 BCS P%+4
 LDX #SH3
 JMP TN6

.TN7

 JSR DORND
 CMP #250
 BCC TA7
 JSR DORND
 ORA #$68
 STA INWK+29

.TA7 ; VRol

 LDY #14
 LDA (XX0),Y
 LSR A
 CMP INWK+35
 BCC TA3
 LSR A
 LSR A
 CMP INWK+35
 BCC ta3
 JSR DORND
 CMP #230
 BCC ta3
 LDX TYPE
 LDA E%-1,X
 BPL ta3
 LDA NEWB
 AND #$F0
 STA NEWB
 LDY #36
 STA (INF),Y
 \**
 LDA #0
 STA INWK+32
 JMP SESCP

.ta3

 LDA INWK+31
 AND #7
 BEQ TA3
 STA T
 JSR DORND
 AND #31
 CMP T
 BCS TA3
 LDA ECMA
 BNE TA3
 DEC INWK+31
 LDA TYPE
 CMP #THG
 BNE TA16
 LDX #TGL
 LDA INWK+32
 JMP SFS1

.TA16

 JMP SFRMIS

.TA3

 LDA #0
 JSR MAS4
 AND #$E0
 BNE TA4
 LDX CNT
;BPL TA4
 CPX #160
 BCC TA4
 LDY #19
 LDA (XX0),Y
 AND #$F8
 BEQ TA4
 LDA INWK+31
 ORA #64
 STA INWK+31
 CPX #163
 BCC TA4
;LDY #19
 LDA (XX0),Y
 LSR A
 JSR OOPS
 DEC INWK+28
 LDA ECMA
 BNE TA9-1
 LDY #sfxelas
 JSR NOISE
 LDY #sfxelas2
 JMP NOISE
 \frLs

.TA4

 LDA INWK+7
 CMP #3
 BCS TA5
 LDA INWK+1
 ORA INWK+4
 AND #$FE
 BEQ TA15

.TA5

 JSR DORND
 ORA #128
 CMP INWK+32
 BCS TA15

.TA20

 JSR TAS6
 LDA CNT
 EOR #128

.TA152

 STA CNT

.TA15 ; ^XX15

 LDY #16
 JSR TAS3
 TAX
 EOR #128
 AND #128
 STA INWK+30
 TXA
 ASL A
 CMP RAT2
 BCC TA11
 LDA RAT
 ORA INWK+30
 STA INWK+30

.TA11

 LDA INWK+29
 ASL A
 CMP #32
 BCS TA6
 LDY #22
 JSR TAS3
 TAX
 EOR INWK+30
 AND #128
 EOR #128
 STA INWK+29
 TXA
 ASL A
 CMP RAT2
 BCC TA12
 LDA RAT
 ORA INWK+29
 STA INWK+29

.TA12

.TA6

 LDA CNT
 BMI TA9
 CMP CNT2
 BCC TA9

.PH10E

 LDA #3
 STA INWK+28
 RTS

.TA9

 AND #127
 CMP #18
 BCC TA10
 LDA #$FF
 LDX TYPE
 CPX #MSL
 BNE P%+3
 ASL A
 STA INWK+28

.TA10

 RTS

.TA151

 LDY #10
 JSR TAS3
 CMP #$98
 BCC ttt
 LDX #0
 STX RAT2

.ttt

 JMP TA152

.DOCKIT

 LDA #6
 STA RAT2
 LSR A
 STA RAT
 LDA #$1D
 STA CNT2
 LDA SSPR
 BNE P%+5

.GOPLS

 JMP GOPL
 JSR VCSU1 ;K3 = ship-spc.stn
 LDA K3+2
 ORA K3+5
 ORA K3+8
 AND #127
 BNE GOPLS
 JSR TA2
 LDA Q
 STA K
 JSR TAS2
 LDY #10
 JSR TAS4
 BMI PH1
 CMP #$23
 BCC PH1 ; fss.r
 LDY #10
 JSR TAS3
 CMP #$A2 ; fpl.r
 BCS PH3
 LDA K
;BEQ PH10
 CMP #$9D
 BCC PH2
 LDA TYPE
 BMI PH3

.PH2

 JSR TAS6
 JSR TA151

.PH22

 LDX #0
 STX INWK+28
 INX
 STX INWK+27
 RTS

.PH1

 JSR VCSU1
 JSR DCS1
 JSR DCS1
 JSR TAS2
 JSR TAS6
 JMP TA151 ;head for sp+

.TN11

 INC INWK+28
 LDA #127
 STA INWK+29
 BNE TN13

.PH3

 LDX #0
 STX RAT2
 STX INWK+30
 LDA TYPE
 BPL PH32
 EOR XX15
 EOR XX15+1
 ASL A
 LDA #2
 ROR A
 STA INWK+29
 LDA XX15
 ASL A
 CMP #12
 BCS PH22
 LDA XX15+1
 ASL A
 LDA #2
 ROR A
 STA INWK+30
 LDA XX15+1
 ASL A
 CMP #12
 BCS PH22

.PH32

 STX INWK+29
 LDA INWK+22
 STA XX15
 LDA INWK+24
 STA XX15+1
 LDA INWK+26
 STA XX15+2
 LDY #16
 JSR TAS4
 ASL A
 CMP #$42
 BCS TN11
 JSR PH22

.TN13

 LDA K3+10
 BNE TNRTS
 ASL NEWB
 SEC
 ROR NEWB

.TNRTS

 RTS ;Docked

.VCSU1

 LDA #((K%+NI%)MOD 256)
 STA V
 LDA #((K%+NI%)DIV 256)

.VCSUB

 STA V+1
 LDY #2
 JSR TAS1
 LDY #5
 JSR TAS1
 LDY #8

.TAS1

 LDA (V),Y
 EOR #128
 STA K+3
 DEY
 LDA (V),Y
 STA K+2
 DEY
 LDA (V),Y
 STA K+1
 STY U
 LDX U
 JSR MVT3
 LDY U
 STA K3+2,X
 LDA K+2
 STA K3+1,X
 LDA K+1
 STA K3,X
 RTS

.TAS4

 LDX K%+NI%,Y
 STX Q
 LDA XX15
 JSR MULT12
 LDX K%+NI%+2,Y
 STX Q
 LDA XX15+1
 JSR MAD
 STA S
 STX R
 LDX K%+NI%+4,Y
 STX Q
 LDA XX15+2
 JMP MAD

.TAS6

 LDA XX15
 EOR #128
 STA XX15
 LDA XX15+1
 EOR #128
 STA XX15+1
 LDA XX15+2
 EOR #128
 STA XX15+2
 RTS

.DCS1

 JSR P%+3
 LDA K%+NI%+10
 LDX #0
 JSR TAS7
 LDA K%+NI%+12
 LDX #3
 JSR TAS7
 LDA K%+NI%+14
 LDX #6

.TAS7

 ASL A
 STA R
 LDA #0
 ROR A
 EOR #128
 EOR K3+2,X
 BMI TS71
 LDA R
 ADC K3,X
 STA K3,X
 BCC TS72
 INC K3+1,X

.TS72

 RTS

.TS71

 LDA K3,X
 SEC
 SBC R
 STA K3,X
 LDA K3+1,X
 SBC #0
 STA K3+1,X
 BCS TS72
 LDA K3,X
 EOR #$FF
 ADC #1
 STA K3,X
 LDA K3+1,X
 EOR #$FF
 ADC #0
 STA K3+1,X
 LDA K3+2,X
 EOR #128
 STA K3+2,X
 JMP TS72

.HITCH

 CLC
 LDA INWK+8
 BNE HI1
 LDA TYPE
 BMI HI1
 LDA INWK+31
 AND #32
 ORA INWK+1
 ORA INWK+4
 BNE HI1
 LDA INWK
 JSR SQUA2
 STA S
 LDA P
 STA R
 LDA INWK+3
 JSR SQUA2
 TAX
 LDA P
 ADC R
 STA R
 TXA
 ADC S
 BCS TN10
 STA S
 LDY #2
 LDA (XX0),Y
 CMP S
 BNE HI1
 DEY
 LDA (XX0),Y
 CMP R

.HI1

 RTS

.TN10

 CLC
 RTS

.FRS1

 JSR ZINF
 LDA #28
 STA INWK+3
 LSR A
 STA INWK+6
 LDA #128
 STA INWK+5
 LDA MSTG
 ASL A
 ORA #128
 STA INWK+32

.fq1

 LDA #96
 STA INWK+14
 ORA #128
 STA INWK+22
 LDA DELTA
 ROL A
 STA INWK+27
 TXA
 JMP NWSHP

.FRMIS

 LDX #MSL
 JSR FRS1
 BCC FR1
 LDX MSTG
 JSR GINF
 LDA FRIN,X
 JSR ANGRY
 LDY #BLACK2
 JSR ABORT
 DEC NOMSL
 LDy #sfxwhosh
 JMP NOISE

.ANGRY

 CMP #SST
 BEQ AN2
 LDY #36
 LDA (INF),Y
 AND #32
 BEQ P%+5
 JSR AN2
 LDY #32
 LDA (INF),Y
 BEQ HI1
 ORA #128
 STA (INF),Y
 LDY #28
 LDA #2
 STA (INF),Y
 ASL A
 LDY #30
 STA (INF),Y
 LDA TYPE
 CMP #CYL
 BCC AN3
 LDY #36
 LDA (INF),Y
 ORA #4
 STA (INF),Y

.AN3

 RTS

.AN2

 LDA K%+NI%+36
 ORA #4
 STA K%+NI%+36
 RTS

.FR1

 LDA #201
 JMP MESS

.SESCP

 LDX #ESC
 LDA #$FE ;SFS1- in EliteI

.SFS1

 STA T1
 TXA
 PHA
 LDA XX0
 PHA
 LDA XX0+1
 PHA
 LDA INF
 PHA
 LDA INF+1
 PHA
 LDY #NI%-1

.FRL2

 LDA INWK,Y
 STA XX3,Y
 LDA (INF),Y
 STA INWK,Y
 DEY
 BPL FRL2
 LDA TYPE
 CMP #SST
 BNE rx
 TXA
 PHA
 LDA #32
 STA INWK+27
 LDX #0
 LDA INWK+10
 JSR SFS2
 LDX #3
 LDA INWK+12
 JSR SFS2
 LDX #6
 LDA INWK+14
 JSR SFS2
 PLA
 TAX

.rx

 LDA T1
 STA INWK+32
 LSR INWK+29
 ASL INWK+29
 TXA
 CMP #SPL+1
 BCS NOIL
 CMP #PLT
 BCC NOIL
 PHA
 JSR DORND
 ASL A
 STA INWK+30
 TXA
 AND #15
 STA INWK+27
 LDA #$FF
 ROR A
 STA INWK+29
 PLA

.NOIL

 JSR NWSHP
 PLA
 STA INF+1
 PLA
 STA INF
 LDX #NI%-1

.FRL3

 LDA XX3,X
 STA INWK,X
 DEX
 BPL FRL3
 PLA
 STA XX0+1
 PLA
 STA XX0
 PLA
 TAX
 RTS

.SFS2

 ASL A
 STA R
 LDA #0
 ROR A
 JMP MVT1

.LL164

 JSR HYPNOISE
 \ =  = Do hypcolours
 LDA #4
 JSR HFS2
 \ =  = Do hypcolours
 RTS

.LAUN

 LDY #sfxwhosh
 JSR NOISE
 LDA #8

.HFS2

 STA STP
 LDA QQ11
 PHA
 LDA #0
 JSR TT66
 PLA
 STA QQ11

.HFS1

 LDX #X
 STX K3
 LDX #Y
 STX K4
 LDX #0
 STX XX4
 STX K3+1
 STX K4+1

.HFL5

 JSR HFL1
 INC XX4
 LDX XX4
 CPX #8
 BNE HFL5
 RTS

.HFL1

 LDA XX4
 AND #7
 CLC
 ADC #8
 STA K

.HFL2

 LDA #1
 STA LSP
 JSR CIRCLE2
 ASL K
 BCS HF8
 LDA K
 CMP #160
 BCC HFL2

.HF8

 RTS

.STARS2

 LDA #0
 CPX #2
 ROR A
 STA RAT
 EOR #128
 STA RAT2
 JSR ST2
 LDY NOSTM

.STL2

 LDA SZ,Y
 STA ZZ
 LSR A
 LSR A
 LSR A
 JSR DV41
 LDA P
 STA newzp
 EOR RAT2
 STA S
 LDA SXL,Y
 STA P
 LDA SX,Y
 STA X1
 JSR ADD ;<<--
 STA S
 STX R
 LDA SY,Y
 STA Y1
 EOR BET2
 LDX BET1
 JSR MULTS-2
 JSR ADD
 STX XX
 STA XX+1
 LDX SYL,Y
 STX R
 LDX Y1
 STX S
 LDX BET1
 EOR BET2+1
 JSR MULTS-2
 JSR ADD
 STX YY
 STA YY+1
 LDX ALP1
 EOR ALP2
 JSR MULTS-2
 STA Q
 LDA XX
 STA R
 LDA XX+1
 STA S
 EOR #128
 JSR MAD
 STA XX+1
 TXA
 STA SXL,Y
 LDA YY
 STA R
 LDA YY+1
 STA S
 JSR MAD
 STA S
 STX R
 LDA #0
 STA P
 LDA ALPHA
 JSR PIX1
 LDA XX+1
 STA SX,Y
 STA X1
 AND #127
 EOR #$7F
 CMP newzp
 BCC KILL2
 BEQ KILL2
 LDA YY+1
 STA SY,Y
 STA Y1
 AND #127
 CMP #116
 BCS ST5

.STC2

 JSR PIXEL2
 DEY
 BEQ ST2
 JMP STL2 ;<<--

.ST2

 LDA ALPHA
 EOR RAT
 STA ALPHA
 LDA ALP2
 EOR RAT
 STA ALP2
 EOR #128
 STA ALP2+1
 LDA BET2
 EOR RAT
 STA BET2
 EOR #128
 STA BET2+1
 RTS

.KILL2

 JSR DORND
 STA Y1
 STA SY,Y
 LDA #115
 ORA RAT
 STA X1
 STA SX,Y
 BNE STF1

.ST5

 JSR DORND
 STA X1
 STA SX,Y
 LDA #110
 ORA ALP2+1
 STA Y1
 STA SY,Y

.STF1

 JSR DORND
 ORA #8
 STA ZZ
 STA SZ,Y
 BNE STC2

; ******************************************************************************
;
;       Name: MU5
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
;
; ------------------------------------------------------------------------------
;
; In practice this is only called via a BEQ following an AND instruction, in
; which case A = 0, so this routine effectively does this:
;
;   K(3 2 1 0) = 0
;
; ******************************************************************************

.MU5

 STA K                  ; Set K(3 2 1 0) to (A A A A)
 STA K+1
 STA K+2
 STA K+3

 CLC                    ; Clear the C flag

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MULT3
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Calculate the following multiplication between a signed 24-bit number and a
; signed 8-bit number, returning the result as a signed 32-bit number:
;
;   K(3 2 1 0) = (A P+1 P) * Q
;
; The algorithm is the same shift-and-add algorithm as in routine MULT1, but
; extended to cope with more bits.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.MULT3

 STA R                  ; Store the high byte of (A P+1 P) in R

 AND #%01111111         ; Set K+2 to |A|, the high byte of K(2 1 0)
 STA K+2

 LDA Q                  ; Set A to bits 0-6 of Q, so A = |Q|
 AND #%01111111

 BEQ MU5                ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
                        ; returning from the subroutine using a tail call

 SEC                    ; Set T = |Q| - 1
 SBC #1
 STA T

                        ; We now use the same shift-and-add algorithm as MULT1
                        ; to calculate the following:
                        ;
                        ; K(2 1 0) = K(2 1 0) * |Q|
                        ;
                        ; so we start with the first shift right, in which we
                        ; take (K+2 P+1 P) and shift it right, storing the
                        ; result in K(2 1 0), ready for the multiplication loop
                        ; (so the multiplication loop actually calculates
                        ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
                        ; (|A| P+1 P) shifted right)

 LDA P+1                ; Set A = P+1

 LSR K+2                ; Shift the high byte in K+2 to the right

 ROR A                  ; Shift the middle byte in A to the right and store in
 STA K+1                ; K+1 (so K+1 contains P+1 shifted right)

 LDA P                  ; Shift the middle byte in P to the right and store in
 ROR A                  ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
 STA K

                        ; We now use the same shift-and-add algorithm as MULT1
                        ; to calculate the following:
                        ;
                        ; K(2 1 0) = K(2 1 0) * |Q|

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 LDX #24                ; Set up a counter in X to count the 24 bits in K(2 1 0)

.MUL2

 BCC P%+4               ; If C (i.e. the next bit from K) is set, do the
 ADC T                  ; addition for this bit of K:
                        ;
                        ;   A = A + T + C
                        ;     = A + |Q| - 1 + 1
                        ;     = A + |Q|

 ROR A                  ; Shift A right by one place to catch the next digit
 ROR K+2                ; next digit of our result in the left end of K(2 1 0),
 ROR K+1                ; while also shifting K(2 1 0) right to fetch the next
 ROR K                  ; bit for the calculation into the C flag
                        ;
                        ; On the last iteration of this loop, the bit falling
                        ; off the end of K will be bit 0 of the original A, as
                        ; we did one shift before the loop and we are doing 24
                        ; iterations. We set A to 0 before looping, so this
                        ; means the loop exits with the C flag clear

 DEX                    ; Decrement the loop counter

 BNE MUL2               ; Loop back for the next bit until K(2 1 0) has been
                        ; rotated all the way

                        ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
                        ; but it is positive and doesn't have the correct sign
                        ; of the final result yet

 STA T                  ; Save the high byte of the result into T

 LDA R                  ; Fetch the sign byte from the original (A P+1 P)
                        ; argument that we stored in R

 EOR Q                  ; EOR with Q so the sign bit is the same as that of
                        ; (A P+1 P) * Q

 AND #%10000000         ; Extract the sign bit

 ORA T                  ; Apply this to the high byte of the result in T, so
                        ; that A now has the correct sign for the result, and
                        ; (A K+2 K+1 K) therefore contains the correctly signed
                        ; result

 STA K+3                ; Store A in K+3, so K(3 2 1 0) now contains the result

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MLS2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   (S R) = XX(1 0)
;
;   (A P) = A * ALP1
;
; where ALP1 is the magnitude of the current roll angle alpha, in the range
; 0-31.
;
; ******************************************************************************

.MLS2

 LDX XX                 ; Set (S R) = XX(1 0), starting with the low bytes
 STX R

 LDX XX+1               ; And then doing the high bytes
 STX S

                        ; Fall through into MLS1 to calculate (A P) = A * ALP1

; ******************************************************************************
;
;       Name: MLS1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = ALP1 * A
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   (A P) = ALP1 * A
;
; where ALP1 is the magnitude of the current roll angle alpha, in the range
; 0-31.
;
; This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
; use the same algorithm but with P set to ALP1 and X set to A. The unrolled
; version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
; only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
; shifts can be done without a test (for bits 5-7).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   MULTS-2             Calculate (A P) = X * A
;
; ******************************************************************************

.MLS1

 LDX ALP1               ; Set P to the roll angle alpha magnitude in ALP1
 STX P                  ; (0-31), so now we calculate P * A

.MULTS

 TAX                    ; Set X = A, so now we can calculate P * X instead of
                        ; P * A to get our result, and we can use the algorithm
                        ; from MU11 to do that, just unrolled (as MU11 returns
                        ; P * X)

 AND #%10000000         ; Set T to the sign bit of A
 STA T

 TXA                    ; Set A = |A|
 AND #127

 BEQ MU6                ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
                        ; from the subroutine using a tail call

 TAX                    ; Set T1 = X - 1
 DEX                    ;
 STX T1                 ; We subtract 1 as the C flag will be set when we want
                        ; to do an addition in the loop below

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 LSR P                  ; Set P = P >> 1
                        ; and C flag = bit 0 of P

                        ; We are now going to work our way through the bits of
                        ; P, and do a shift-add for any bits that are set,
                        ; keeping the running total in A, but instead of using a
                        ; loop like MU11, we just unroll it, starting with bit 0

 BCC P%+4               ; If C (i.e. the next bit from P) is set, do the
 ADC T1                 ; addition for this bit of P:
                        ;
                        ;   A = A + T1 + C
                        ;     = A + X - 1 + 1
                        ;     = A + X

 ROR A                  ; Shift A right to catch the next digit of our result,
                        ; which the next ROR sticks into the left end of P while
                        ; also extracting the next bit of P

 ROR P                  ; Add the overspill from shifting A to the right onto
                        ; the start of P, and shift P right to fetch the next
                        ; bit for the calculation into the C flag

 BCC P%+4               ; Repeat the shift-and-add loop for bit 1
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat the shift-and-add loop for bit 2
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat the shift-and-add loop for bit 3
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat the shift-and-add loop for bit 4
 ADC T1
 ROR A
 ROR P

 LSR A                  ; Just do the "shift" part for bit 5
 ROR P

 LSR A                  ; Just do the "shift" part for bit 6
 ROR P

 LSR A                  ; Just do the "shift" part for bit 7
 ROR P

 ORA T                  ; Give A the sign bit of the original argument A that
                        ; we put into T above

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MU6
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Set P(1 0) = (A A)
;
; ------------------------------------------------------------------------------
;
; In practice this is only called via a BEQ following an AND instruction, in
; which case A = 0, so this routine effectively does this:
;
;   P(1 0) = 0
;
; ******************************************************************************

.MU6

 STA P+1                ; Set P(1 0) = (A A)
 STA P

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SQUA
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Clear bit 7 of A and calculate (A P) = A * A
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of unsigned 8-bit numbers, after first
; clearing bit 7 of A:
;
;   (A P) = A * A
;
; ******************************************************************************

.SQUA

 AND #%01111111         ; Clear bit 7 of A and fall through into SQUA2 to set
                        ; (A P) = A * A

; ******************************************************************************
;
;       Name: SQUA2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = A * A
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of unsigned 8-bit numbers:
;
;   (A P) = A * A
;
; ******************************************************************************

.SQUA2

 STA P                  ; Copy A into P and X
 TAX

 BNE MU11               ; If X = 0 fall through into MU1 to return a 0,
                        ; otherwise jump to MU11 to return P * X

; ******************************************************************************
;
;       Name: MU1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Copy X into P and A, and clear the C flag
;
; ------------------------------------------------------------------------------
;
; Used to return a 0 result quickly from MULTU below.
;
; ******************************************************************************

.MU1

 CLC                    ; Clear the C flag

 STX P                  ; Copy X into P and A
 TXA

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MLU1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
;
; ------------------------------------------------------------------------------
;
; Do the following assignment, and multiply the Y-th stardust particle's
; y-coordinate with an unsigned number Q:
;
;   Y1 = y_hi
;
;   (A P) = |y_hi| * Q
;
; ******************************************************************************

.MLU1

 LDA SY,Y               ; Set Y1 the Y-th byte of SY
 STA Y1

                        ; Fall through into MLU2 to calculate:
                        ;
                        ;   (A P) = |A| * Q

; ******************************************************************************
;
;       Name: MLU2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = |A| * Q
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of a sign-magnitude 8-bit number P with an
; unsigned number Q:
;
;   (A P) = |A| * Q
;
; ******************************************************************************

.MLU2

 AND #%01111111         ; Clear the sign bit in P, so P = |A|
 STA P

                        ; Fall through into MULTU to calculate:
                        ;
                        ;   (A P) = P * Q
                        ;         = |A| * Q

; ******************************************************************************
;
;       Name: MULTU
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = P * Q
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of unsigned 8-bit numbers:
;
;   (A P) = P * Q
;
; ******************************************************************************

.MULTU

 LDX Q                  ; Set X = Q

 BEQ MU1                ; If X = Q = 0, jump to MU1 to copy X into P and A,
                        ; clear the C flag and return from the subroutine using
                        ; a tail call

                        ; Otherwise fall through into MU11 to set (A P) = P * X

; ******************************************************************************
;
;       Name: MU11
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = P * X
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of two unsigned 8-bit numbers:
;
;   (A P) = P * X
;
; This uses the same shift-and-add approach as MULT1, but it's simpler as we
; are dealing with unsigned numbers in P and X. See the deep dive on
; "Shift-and-add multiplication" for a discussion of how this algorithm works.
;
; ******************************************************************************

.MU11

 DEX                    ; Set T = X - 1
 STX T                  ;
                        ; We subtract 1 as the C flag will be set when we want
                        ; to do an addition in the loop below

 LDA #0                 ; Set A = 0 so we can start building the answer in A

;LDX #8                 ; This instruction is commented out in the original
                        ; source

 TAX                    ; Copy A into X. There is a comment in the original
                        ; source here that says "just in case", which refers to
                        ; the MU11 routine in the cassette and disc versions,
                        ; which set X to 0 (as they use X as a loop counter).
                        ; The version here doesn't use a loop, but this
                        ; instruction makes sure the unrolled version returns
                        ; the same results as the loop versions, just in case
                        ; something out there relies on MU11 returning X = 0

 LSR P                  ; Set P = P >> 1
                        ; and C flag = bit 0 of P

                        ; We now repeat the following four instruction block
                        ; eight times, one for each bit in P. In the cassette
                        ; and disc versions of Elite the following is done with
                        ; a loop, but it is marginally faster to unroll the loop
                        ; and have eight copies of the code, though it does take
                        ; up a bit more memory (though that isn't a concern when
                        ; you have a 6502 Second Processor)

 BCC P%+4               ; If C (i.e. bit 0 of P) is set, do the
 ADC T                  ; addition for this bit of P:
                        ;
                        ;   A = A + T + C
                        ;     = A + X - 1 + 1
                        ;     = A + X

 ROR A                  ; Shift A right to catch the next digit of our result,
                        ; which the next ROR sticks into the left end of P while
                        ; also extracting the next bit of P

 ROR P                  ; Add the overspill from shifting A to the right onto
                        ; the start of P, and shift P right to fetch the next
                        ; bit for the calculation into the C flag

 BCC P%+4               ; Repeat for the second time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the third time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fourth time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fifth time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the sixth time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the seventh time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the eighth time
 ADC T
 ROR A
 ROR P

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: FMLTU2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate A = K * sin(A)
;  Deep dive: The sine, cosine and arctan tables
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   A = K * sin(A)
;
; Because this routine uses the sine lookup table SNE, we can also call this
; routine to calculate cosine multiplication. To calculate the following:
;
;   A = K * cos(B)
;
; call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
;
; ******************************************************************************

.FMLTU2

 AND #%00011111         ; Restrict A to bits 0-5 (so it's in the range 0-31)

 TAX                    ; Set Q = sin(A) * 256
 LDA SNE,X
 STA Q

 LDA K                  ; Set A to the radius in K

                        ; Fall through into FMLTU to do the following:
                        ;
                        ;   (A ?) = A * Q
                        ;         = K * sin(A) * 256
                        ;
                        ; which is equivalent to:
                        ;
                        ;   A = K * sin(A)

; ******************************************************************************
;
;       Name: FMLTU
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate A = A * Q / 256
;  Deep dive: Multiplication and division using logarithms
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of two unsigned 8-bit numbers, returning only
; the high byte of the result:
;
;   (A ?) = A * Q
;
; or, to put it another way:
;
;   A = A * Q / 256
;
; The advanced versions of Elite use logarithms to speed up the multiplication
; process. See the deep dive on "Multiplication using logarithms" for more
; details.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is clear if A = 0, or set if we return a
;                       result from one of the log tables
;
; ******************************************************************************

.FMLTU

 STX P                  ; Store X in P so we can preserve it through the call to
                        ; FMULTU

 STA widget             ; Store A in widget, so now widget = argument A

 TAX                    ; Transfer A into X, so now X = argument A

 BEQ MU3                ; If A = 0, jump to MU3 to return a result of 0, as
                        ; 0 * Q / 256 is always 0

                        ; We now want to calculate La + Lq, first adding the low
                        ; bytes (from the logL table), and then the high bytes
                        ; (from the log table)

 LDA logL,X             ; Set A = low byte of La
                        ;       = low byte of La (as we set X to A above)

 LDX Q                  ; Set X = Q

 BEQ MU3again           ; If X = 0, jump to MU3again to return a result of 0, as
                        ; A * 0 / 256 is always 0

 CLC                    ; Set A = A + low byte of Lq
 ADC logL,X             ;       = low byte of La + low byte of Lq

 BMI oddlog             ; If A > 127, jump to oddlog

 LDA log,X              ; Set A = high byte of Lq

 LDX widget             ; Set A = A + C + high byte of La
 ADC log,X              ;       = high byte of Lq + high byte of La + C
                        ;
                        ; so we now have:
                        ;
                        ;   A = high byte of (La + Lq)

 BCC MU3again           ; If the addition fitted into one byte and didn't carry,
                        ; then La + Lq < 256, so we jump to MU3again to return a
                        ; result of 0 and the C flag clear

                        ; If we get here then the C flag is set, ready for when
                        ; we return from the subroutine below

 TAX                    ; Otherwise La + Lq >= 256, so we return the A-th entry
 LDA antilog,X          ; from the antilog table

 LDX P                  ; Restore X from P so it is preserved

 RTS                    ; Return from the subroutine

.oddlog

 LDA log,X              ; Set A = high byte of Lq

 LDX widget             ; Set A = A + C + high byte of La
 ADC log,X              ;       = high byte of Lq + high byte of La + C
                        ;
                        ; so we now have:
                        ;
                        ;   A = high byte of (La + Lq)

 BCC MU3again           ; If the addition fitted into one byte and didn't carry,
                        ; then La + Lq < 256, so we jump to MU3again to return a
                        ; result of 0 and the C flag clear

                        ; If we get here then the C flag is set, ready for when
                        ; we return from the subroutine below

 TAX                    ; Otherwise La + Lq >= 256, so we return the A-th entry
 LDA antilogODD,X       ; from the antilogODD table

.MU3

                        ; If we get here then A (our result) is already 0

 LDX P                  ; Restore X from P so it is preserved

 RTS                    ; Return from the subroutine

.MU3again

 LDA #0                 ; Set A = 0

 LDX P                  ; Restore X from P so it is preserved

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MLTU2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P+1 P) = (A ~P) * Q
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of an unsigned 16-bit number and an unsigned
; 8-bit number:
;
;   (A P+1 P) = (A ~P) * Q
;
; where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
; words, if you wanted to calculate $1234 * $56, you would:
;
;   * Set A to $12
;   * Set P to $34 EOR %11111111 = $CB
;   * Set Q to $56
;
; before calling MLTU2.
;
; This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
; inverted argument trick to work out whether or not to do an addition, and like
; MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
; extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
; the algorithm is still the shift-and-add approach explained in MULT1, just
; with more bits.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Q                   Q is preserved
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
;
; ******************************************************************************

 STX Q                  ; Store X in Q

.MLTU2

 EOR #%11111111         ; Flip the bits in A and rotate right, storing the
 LSR A                  ; result in P+1, so we now calculate (P+1 P) * Q
 STA P+1

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 LDX #16                ; Set up a counter in X to count the 16 bits in (P+1 P)

 ROR P                  ; Set P = P >> 1 with bit 7 = bit 0 of A
                        ; and C flag = bit 0 of P

.MUL7

 BCS MU21               ; If C (i.e. the next bit from P) is set, do not do the
                        ; addition for this bit of P, and instead skip to MU21
                        ; to just do the shifts

 ADC Q                  ; Do the addition for this bit of P:
                        ;
                        ;   A = A + Q + C
                        ;     = A + Q

 ROR A                  ; Rotate (A P+1 P) to the right, so we capture the next
 ROR P+1                ; digit of the result in P+1, and extract the next digit
 ROR P                  ; of (P+1 P) in the C flag

 DEX                    ; Decrement the loop counter

 BNE MUL7               ; Loop back for the next bit until P has been rotated
                        ; all the way

 RTS                    ; Return from the subroutine

.MU21

 LSR A                  ; Shift (A P+1 P) to the right, so we capture the next
 ROR P+1                ; digit of the result in P+1, and extract the next digit
 ROR P                  ; of (P+1 P) in the C flag

 DEX                    ; Decrement the loop counter

 BNE MUL7               ; Loop back for the next bit until P has been rotated
                        ; all the way

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MUT3
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: An unused routine that does the same as MUT2
;
; ------------------------------------------------------------------------------
;
; This routine is never actually called, but it is identical to MUT2, as the
; extra instructions have no effect.
;
; ******************************************************************************

.MUT3

 LDX ALP1               ; Set P = ALP1, though this gets overwritten by the
 STX P                  ; following, so this has no effect

                        ; Fall through into MUT2 to do the following:
                        ;
                        ;   (S R) = XX(1 0)
                        ;   (A P) = Q * A

; ******************************************************************************
;
;       Name: MUT2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
;
; ------------------------------------------------------------------------------
;
; Do the following assignment, and multiplication of two signed 8-bit numbers:
;
;   (S R) = XX(1 0)
;   (A P) = Q * A
;
; ******************************************************************************

.MUT2

 LDX XX+1               ; Set S = XX+1
 STX S

                        ; Fall through into MUT1 to do the following:
                        ;
                        ;   R = XX
                        ;   (A P) = Q * A

; ******************************************************************************
;
;       Name: MUT1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate R = XX and (A P) = Q * A
;
; ------------------------------------------------------------------------------
;
; Do the following assignment, and multiplication of two signed 8-bit numbers:
;
;   R = XX
;   (A P) = Q * A
;
; ******************************************************************************

.MUT1

 LDX XX                 ; Set R = XX
 STX R

                        ; Fall through into MULT1 to do the following:
                        ;
                        ;   (A P) = Q * A

; ******************************************************************************
;
;       Name: MULT1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = Q * A
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of two 8-bit sign-magnitude numbers:
;
;   (A P) = Q * A
;
; ******************************************************************************

.MULT1

 TAX                    ; Store A in X

 AND #%01111111         ; Set P = |A| >> 1
 LSR A                  ; and C flag = bit 0 of A
 STA P

 TXA                    ; Restore argument A

 EOR Q                  ; Set bit 7 of A and T if Q and A have different signs,
 AND #%10000000         ; clear bit 7 if they have the same signs, 0 all other
 STA T                  ; bits, i.e. T contains the sign bit of Q * A

 LDA Q                  ; Set A = |Q|
 AND #%01111111

 BEQ mu10               ; If |Q| = 0 jump to mu10 (with A set to 0)

 TAX                    ; Set T1 = |Q| - 1
 DEX                    ;
 STX T1                 ; We subtract 1 as the C flag will be set when we want
                        ; to do an addition in the loop below

                        ; We are now going to work our way through the bits of
                        ; P, and do a shift-add for any bits that are set,
                        ; keeping the running total in A. We already set up
                        ; the first shift at the start of this routine, as
                        ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
                        ; up a loop to sift through the other 7 bits in P

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 TAX                    ; Copy A into X. There is a comment in the original
                        ; source here that says "just in case", which refers to
                        ; the MULT1 routine in the cassette and disc versions,
                        ; which set X to 0 (as they use X as a loop counter).
                        ; The version here doesn't use a loop, but this
                        ; instruction makes sure the unrolled version returns
                        ; the same results as the loop versions, just in case
                        ; something out there relies on MULT1 returning X = 0

;.MUL4                  ; These instructions are commented out in the original
;                       ; source. They contain the original loop version of the
;BCC P%+4               ; code that's used in the disc and cassette versions
;ADC T1
;ROR A
;ROR P
;DEX
;BNE MUL4
;LSR A
;ROR P
;ORA T
;RTS
;
;.mu10
;STA P
;RTS

                        ; We now repeat the following four instruction block
                        ; seven times, one for each remaining bit in P. In the
                        ; cassette and disc versions of Elite the following is
                        ; done with a loop, but it is marginally faster to
                        ; unroll the loop and have seven copies of the code,
                        ; though it does take up a bit more memory

 BCC P%+4               ; If C (i.e. the next bit from P) is set, do the
 ADC T1                 ; addition for this bit of P:
                        ;
                        ;   A = A + T1 + C
                        ;     = A + |Q| - 1 + 1
                        ;     = A + |Q|

 ROR A                  ; As mentioned above, this ROR shifts A right and
                        ; catches bit 0 in C - giving another digit for our
                        ; result - and the next ROR sticks that bit into the
                        ; left end of P while also extracting the next bit of P
                        ; for the next addition

 ROR P                  ; Add the overspill from shifting A to the right onto
                        ; the start of P, and shift P right to fetch the next
                        ; bit for the calculation

 BCC P%+4               ; Repeat for the second time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the third time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fourth time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fifth time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the sixth time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the seventh time
 ADC T1
 ROR A
 ROR P

 LSR A                  ; Rotate (A P) once more to get the final result, as
 ROR P                  ; we only pushed 7 bits through the above process

 ORA T                  ; Set the sign bit of the result that we stored in T

 RTS                    ; Return from the subroutine

.mu10

 STA P                  ; If we get here, the result is 0 and A = 0, so set
                        ; P = 0 so (A P) = 0

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MULT12
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (S R) = Q * A
;
; ------------------------------------------------------------------------------
;
; Calculate:
;
;   (S R) = Q * A
;
; ******************************************************************************

.MULT12

 JSR MULT1              ; Set (A P) = Q * A

 STA S                  ; Set (S R) = (A P)
 LDA P                  ;           = Q * A
 STA R

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TAS3
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate the dot product of XX15 and an orientation vector
;
; ------------------------------------------------------------------------------
;
; Calculate the dot product of the vector in XX15 and one of the orientation
; vectors, as determined by the value of Y. If vect is the orientation vector,
; we calculate this:
;
;   (A X) = vect . XX15
;         = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The orientation vector:
;
;                         * If Y = 10, calculate nosev . XX15
;
;                         * If Y = 16, calculate roofv . XX15
;
;                         * If Y = 22, calculate sidev . XX15
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (A X)               The result of the dot product
;
; ******************************************************************************

.TAS3

 LDX INWK,Y             ; Set Q = the Y-th byte of INWK, i.e. vect_x
 STX Q

 LDA XX15               ; Set A = XX15

 JSR MULT12             ; Set (S R) = Q * A
                        ;           = vect_x * XX15

 LDX INWK+2,Y           ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
 STX Q

 LDA XX15+1             ; Set A = XX15+1

 JSR MAD                ; Set (A X) = Q * A + (S R)
                        ;           = vect_y * XX15+1 + vect_x * XX15

 STA S                  ; Set (S R) = (A X)
 STX R

 LDX INWK+4,Y           ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
 STX Q

 LDA XX15+2             ; Set A = XX15+2

                        ; Fall through into MAD to set:
                        ;
                        ;   (A X) = Q * A + (S R)
                        ;           = vect_z * XX15+2 + vect_y * XX15+1 +
                        ;             vect_x * XX15

; ******************************************************************************
;
;       Name: MAD
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A X) = Q * A + (S R)
;
; ------------------------------------------------------------------------------
;
; Calculate
;
;   (A X) = Q * A + (S R)
;
; ******************************************************************************

.MAD

 JSR MULT1              ; Call MULT1 to set (A P) = Q * A

                        ; Fall through into ADD to do:
                        ;
                        ;   (A X) = (A P) + (S R)
                        ;         = Q * A + (S R)

; ******************************************************************************
;
;       Name: ADD
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A X) = (A P) + (S R)
;  Deep dive: Adding sign-magnitude numbers
;
; ------------------------------------------------------------------------------
;
; Add two 16-bit sign-magnitude numbers together, calculating:
;
;   (A X) = (A P) + (S R)
;
; ******************************************************************************

.ADD

 STA T1                 ; Store argument A in T1

 AND #%10000000         ; Extract the sign (bit 7) of A and store it in T
 STA T

 EOR S                  ; EOR bit 7 of A with S. If they have different bit 7s
 BMI MU8                ; (i.e. they have different signs) then bit 7 in the
                        ; EOR result will be 1, which means the EOR result is
                        ; negative. So the AND, EOR and BMI together mean "jump
                        ; to MU8 if A and S have different signs"

                        ; If we reach here, then A and S have the same sign, so
                        ; we can add them and set the sign to get the result

 LDA R                  ; Add the least significant bytes together into X:
 CLC                    ;
 ADC P                  ;   X = P + R
 TAX

 LDA S                  ; Add the most significant bytes together into A. We
 ADC T1                 ; stored the original argument A in T1 earlier, so we
                        ; can do this with:
                        ;
                        ;   A = A  + S + C
                        ;     = T1 + S + C

 ORA T                  ; If argument A was negative (and therefore S was also
                        ; negative) then make sure result A is negative by
                        ; OR'ing the result with the sign bit from argument A
                        ; (which we stored in T)

 RTS                    ; Return from the subroutine

.MU8

                        ; If we reach here, then A and S have different signs,
                        ; so we can subtract their absolute values and set the
                        ; sign to get the result

 LDA S                  ; Clear the sign (bit 7) in S and store the result in
 AND #%01111111         ; U, so U now contains |S|
 STA U

 LDA P                  ; Subtract the least significant bytes into X:
 SEC                    ;
 SBC R                  ;   X = P - R
 TAX

 LDA T1                 ; Restore the A of the argument (A P) from T1 and
 AND #%01111111         ; clear the sign (bit 7), so A now contains |A|

 SBC U                  ; Set A = |A| - |S|

                        ; At this point we have |A P| - |S R| in (A X), so we
                        ; need to check whether the subtraction above was the
                        ; right way round (i.e. that we subtracted the smaller
                        ; absolute value from the larger absolute value)

 BCS MU9                ; If |A| >= |S|, our subtraction was the right way
                        ; round, so jump to MU9 to set the sign

                        ; If we get here, then |A| < |S|, so our subtraction
                        ; above was the wrong way round (we actually subtracted
                        ; the larger absolute value from the smaller absolute
                        ; value). So let's subtract the result we have in (A X)
                        ; from zero, so that the subtraction is the right way
                        ; round

 STA U                  ; Store A in U

 TXA                    ; Set X = 0 - X using two's complement (to negate a
 EOR #$FF               ; number in two's complement, you can invert the bits
 ADC #1                 ; and add one - and we know the C flag is clear as we
 TAX                    ; didn't take the BCS branch above, so the ADC will do
                        ; the correct addition)

 LDA #0                 ; Set A = 0 - A, which we can do this time using a
 SBC U                  ; subtraction with the C flag clear

 ORA #%10000000         ; We now set the sign bit of A, so that the EOR on the
                        ; next line will give the result the opposite sign to
                        ; argument A (as T contains the sign bit of argument
                        ; A). This is the same as giving the result the same
                        ; sign as argument S (as A and S have different signs),
                        ; which is what we want, as S has the larger absolute
                        ; value

.MU9

 EOR T                  ; If we get here from the BCS above, then |A| >= |S|,
                        ; so we want to give the result the same sign as
                        ; argument A, so if argument A was negative, we flip
                        ; the sign of the result with an EOR (to make it
                        ; negative)

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TIS1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A ?) = (-X * A + (S R)) / 96
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following expression between sign-magnitude numbers, ignoring
; the low byte of the result:
;
;   (A ?) = (-X * A + (S R)) / 96
;
; This uses the same shift-and-subtract algorithm as TIS2, just with the
; quotient A hard-coded to 96.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Q                   Gets set to the value of argument X
;
; ******************************************************************************

.TIS1

 STX Q                  ; Set Q = X

 EOR #%10000000         ; Flip the sign bit in A

 JSR MAD                ; Set (A X) = Q * A + (S R)
                        ;           = X * -A + (S R)

.DVID96

 TAX                    ; Set T to the sign bit of the result
 AND #%10000000
 STA T

 TXA                    ; Set A to the high byte of the result with the sign bit
 AND #%01111111         ; cleared, so (A ?) = |X * A + (S R)|

                        ; The following is identical to TIS2, except Q is
                        ; hard-coded to 96, so this does A = A / 96

 LDX #254               ; Set T1 to have bits 1-7 set, so we can rotate through
 STX T1                 ; 7 loop iterations, getting a 1 each time, and then
                        ; getting a 0 on the 8th iteration... and we can also
                        ; use T1 to catch our result bits into bit 0 each time

.DVL3

 ASL A                  ; Shift A to the left

 CMP #96                ; If A < 96 skip the following subtraction
 BCC DV4

 SBC #96                ; Set A = A - 96
                        ;
                        ; Going into this subtraction we know the C flag is
                        ; set as we passed through the BCC above, and we also
                        ; know that A >= 96, so the C flag will still be set
                        ; once we are done

.DV4

 ROL T1                 ; Rotate the counter in T1 to the left, and catch the
                        ; result bit into bit 0 (which will be a 0 if we didn't
                        ; do the subtraction, or 1 if we did)

 BCS DVL3               ; If we still have set bits in T1, loop back to DVL3 to
                        ; do the next iteration of 7

 LDA T1                 ; Fetch the result from T1 into A

 ORA T                  ; Give A the sign of the result that we stored above

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DV42
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P R) = 256 * DELTA / z_hi
;
; ------------------------------------------------------------------------------
;
; Calculate the following division and remainder:
;
;   P = DELTA / (the Y-th stardust particle's z_hi coordinate)
;
;   R = remainder as a fraction of A, where 1.0 = 255
;
; Another way of saying the above is this:
;
;   (P R) = 256 * DELTA / z_hi
;
; DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
; are removed at lower values than this), so this means P is between 0 and 2
; (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
;
; This uses the same shift-and-subtract algorithm as TIS2, but this time we
; keep the remainder.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The number of the stardust particle to process
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.DV42

 LDA SZ,Y               ; Fetch the Y-th dust particle's z_hi coordinate into A

                        ; Fall through into DV41 to do:
                        ;
                        ;   (P R) = 256 * DELTA / A
                        ;         = 256 * DELTA / Y-th stardust particle's z_hi

; ******************************************************************************
;
;       Name: DV41
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P R) = 256 * DELTA / A
;
; ------------------------------------------------------------------------------
;
; Calculate the following division and remainder:
;
;   P = DELTA / A
;
;   R = remainder as a fraction of A, where 1.0 = 255
;
; Another way of saying the above is this:
;
;   (P R) = 256 * DELTA / A
;
; This uses the same shift-and-subtract algorithm as TIS2, but this time we
; keep the remainder.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.DV41

 STA Q                  ; Store A in Q

 LDA DELTA              ; Fetch the speed from DELTA into A

                        ; Fall through into DVID4 to do:
                        ;
                        ;   (P R) = 256 * A / Q
                        ;         = 256 * DELTA / A

; ******************************************************************************
;
;       Name: DVID4
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P R) = 256 * A / Q
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following division and remainder:
;
;   P = A / Q
;
;   R = remainder as a fraction of Q, where 1.0 = 255
;
; Another way of saying the above is this:
;
;   (P R) = 256 * A / Q
;
; This uses the same shift-and-subtract algorithm as TIS2, but this time we
; keep the remainder and the loop is unrolled.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.DVID4

;LDX #8                 ; This instruction is commented out in the original
                        ; source

 ASL A                  ; Shift A left and store in P (we will build the result
 STA P                  ; in P)

 LDA #0                 ; Set A = 0 for us to build a remainder

;.DVL4                  ; This label is commented out in the original source

                        ; We now repeat the following five instruction block
                        ; eight times, one for each bit in P. In the cassette
                        ; and disc versions of Elite the following is done with
                        ; a loop, but it is marginally faster to unroll the loop
                        ; and have eight copies of the code, though it does take
                        ; up a bit more memory (though that isn't a concern when
                        ; you have a 6502 Second Processor)

 ROL A                  ; Shift A to the left

 CMP Q                  ; If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  ; A >= Q, so set A = A - Q

 ROL P                  ; Shift P to the left, pulling the C flag into bit 0

 ROL A                  ; Repeat for the second time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the third time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the fourth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the fifth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the sixth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the seventh time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the eighth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 LDX #0                 ; Set X = 0 so this unrolled version of DVID4 also
                        ; returns X = 0

 STA widget             ; This contains the code from the LL28+4 routine, so
 TAX                    ; this section is exactly equivalent to a JMP LL28+4
 BEQ LLfix22            ; call, but is slightly faster as it's been inlined
 LDA logL,X             ; (so it converts the remainder in A into an integer
 LDX Q                  ; representation of the fractional value A / Q, in R,
 SEC                    ; where 1.0 = 255, and it also clears the C flag
 SBC logL,X
 BMI noddlog22
 LDX widget
 LDA log,X
 LDX Q
 SBC log,X
 BCS LL222
 TAX
 LDA antilog,X

.LLfix22

 STA R                  ; This is also part of the inline LL28+4 routine
 RTS

.LL222

 LDA #255               ; This is also part of the inline LL28+4 routine
 STA R
 RTS

.noddlog22

 LDX widget             ; This is also part of the inline LL28+4 routine
 LDA log,X
 LDX Q
 SBC log,X
 BCS LL222
 TAX
 LDA antilogODD,X
 STA R
 RTS

; ******************************************************************************
;
;       Name: DVID3B2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
;
; The actual division here is done as an 8-bit calculation using LL31, but this
; routine shifts both the numerator (the top part of the division) and the
; denominator (the bottom part of the division) around to get the multi-byte
; result we want.
;
; Specifically, it shifts both of them to the left as far as possible, keeping a
; tally of how many shifts get done in each one - and specifically, the
; difference in the number of shifts between the top and bottom (as shifting
; both of them once in the same direction won't change the result). It then
; divides the two highest bytes with the simple 8-bit routine in LL31, and
; shifts the result by the difference in the number of shifts, which acts as a
; scale factor to get the correct result.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   K(3 2 1 0)          The result of the division
;
;   X                   X is preserved
;
; ******************************************************************************

.DVID3B2

 STA P+2                ; Set P+2 = A

 LDA INWK+6             ; Set Q = z_lo, making sure Q is at least 1
 ORA #1
 STA Q

 LDA INWK+7             ; Set R = z_hi
 STA R

 LDA INWK+8             ; Set S = z_sign
 STA S

.DVID3B

                        ; Given the above assignments, we now want to calculate
                        ; the following to get the result we want:
                        ;
                        ;   K(3 2 1 0) = P(2 1 0) / (S R Q)

 LDA P                  ; Make sure P(2 1 0) is at least 1
 ORA #1
 STA P

 LDA P+2                ; Set T to the sign of P+2 * S (i.e. the sign of the
 EOR S                  ; result) and store it in T
 AND #%10000000
 STA T

 LDY #0                 ; Set Y = 0 to store the scale factor

 LDA P+2                ; Clear the sign bit of P+2, so the division can be done
 AND #%01111111         ; with positive numbers and we'll set the correct sign
                        ; below, once all the maths is done
                        ;
                        ; This also leaves A = P+2, which we use below

.DVL9

                        ; We now shift (A P+1 P) left until A >= 64, counting
                        ; the number of shifts in Y. This makes the top part of
                        ; the division as large as possible, thus retaining as
                        ; much accuracy as we can.  When we come to return the
                        ; final result, we shift the result by the number of
                        ; places in Y, and in the correct direction

 CMP #64                ; If A >= 64, jump down to DV14
 BCS DV14

 ASL P                  ; Shift (A P+1 P) to the left
 ROL P+1
 ROL A

 INY                    ; Increment the scale factor in Y

 BNE DVL9               ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
                        ; will never be zero)

.DV14

                        ; If we get here, A >= 64 and contains the highest byte
                        ; of the numerator, scaled up by the number of left
                        ; shifts in Y

 STA P+2                ; Store A in P+2, so we now have the scaled value of
                        ; the numerator in P(2 1 0)

 LDA S                  ; Set A = |S|
 AND #%01111111

;BMI DV9                ; This label is commented out in the original source

.DVL6

                        ; We now shift (S R Q) left until bit 7 of S is set,
                        ; reducing Y by the number of shifts. This makes the
                        ; bottom part of the division as large as possible, thus
                        ; retaining as much accuracy as we can. When we come to
                        ; return the final result, we shift the result by the
                        ; total number of places in Y, and in the correct
                        ; direction, to give us the correct result
                        ;
                        ; We set A to |S| above, so the following actually
                        ; shifts (A R Q)

 DEY                    ; Decrement the scale factor in Y

 ASL Q                  ; Shift (A R Q) to the left
 ROL R
 ROL A

 BPL DVL6               ; Loop up to DVL6 to do another shift, until bit 7 of A
                        ; is set and we can't shift left any further

.DV9

                        ; We have now shifted both the numerator and denominator
                        ; left as far as they will go, keeping a tally of the
                        ; overall scale factor of the various shifts in Y. We
                        ; can now divide just the two highest bytes to get our
                        ; result

 STA Q                  ; Set Q = A, the highest byte of the denominator

 LDA #254               ; Set R to have bits 1-7 set, so we can pass this to
 STA R                  ; LL31 to act as the bit counter in the division

 LDA P+2                ; Set A to the highest byte of the numerator

.LL31new

 ASL A                  ; This contains the code from the LL31 routine, so
 BCS LL29new            ; this section is exactly equivalent to a JSR LL31
 CMP Q                  ; call, but is slightly faster as it's been inlined,
 BCC P%+4               ; so it calculates:
 SBC Q                  ;
 ROL R                  ;   R = 256 * A / Q
 BCS LL31new            ;     = 256 * numerator / denominator
 JMP LL312new

.LL29new

 SBC Q                  ; This is also part of the inline LL31 routine
 SEC
 ROL R
 BCS LL31new
 LDA R

.LL312new

                        ; The result of our division is now in R, so we just
                        ; need to shift it back by the scale factor in Y

 LDA #0                 ; Set K(3 2 1) = 0 to hold the result (we populate K
 STA K+1                ; next)
 STA K+2
 STA K+3

 TYA                    ; If Y is positive, jump to DV12
 BPL DV12

                        ; If we get here then Y is negative, so we need to shift
                        ; the result R to the left by Y places, and then set the
                        ; correct sign for the result

 LDA R                  ; Set A = R

.DVL8

 ASL A                  ; Shift (K+3 K+2 K+1 A) left
 ROL K+1
 ROL K+2
 ROL K+3

 INY                    ; Increment the scale factor in Y

 BNE DVL8               ; Loop back to DVL8 until we have shifted left by Y
                        ; places

 STA K                  ; Store A in K so the result is now in K(3 2 1 0)

 LDA K+3                ; Set K+3 to the sign in T, which we set above to the
 ORA T                  ; correct sign for the result
 STA K+3

 RTS                    ; Return from the subroutine

.DV13

                        ; If we get here then Y is zero, so we don't need to
                        ; shift the result R, we just need to set the correct
                        ; sign for the result

 LDA R                  ; Store R in K so the result is now in K(3 2 1 0)
 STA K

 LDA T                  ; Set K+3 to the sign in T, which we set above to the
 STA K+3                ; correct sign for the result

 RTS                    ; Return from the subroutine

.DV12

 BEQ DV13               ; We jumped here having set A to the scale factor in Y,
                        ; so this jumps up to DV13 if Y = 0

                        ; If we get here then Y is positive and non-zero, so we
                        ; need to shift the result R to the right by Y places
                        ; and then set the correct sign for the result. We also
                        ; know that K(3 2 1) will stay 0, as we are shifting the
                        ; lowest byte to the right, so no set bits will make
                        ; their way into the top three bytes

 LDA R                  ; Set A = R

.DVL10

 LSR A                  ; Shift A right

 DEY                    ; Decrement the scale factor in Y

 BNE DVL10              ; Loop back to DVL10 until we have shifted right by Y
                        ; places

 STA K                  ; Store the shifted A in K so the result is now in
                        ; K(3 2 1 0)

 LDA T                  ; Set K+3 to the sign in T, which we set above to the
 STA K+3                ; correct sign for the result

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: cntr
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Apply damping to the pitch or roll dashboard indicator
;
; ------------------------------------------------------------------------------
;
; Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
; centre point (so X represents a position on a centre-based dashboard slider,
; such as pitch or roll). If the value is in the left-hand side of the slider
; (1-127) then it bumps the value up by 1 so it moves towards the centre, and
; if it's in the right-hand side, it reduces it by 1, also moving it towards the
; centre.
;
; ******************************************************************************

.cntr

 LDA auto               ; If the docking computer is currently activated, jump
 BNE cnt2               ; to cnt2 to skip the following as we always want to
                        ; enable damping for the docking computer

 LDA DAMP               ; If DAMP is non-zero, then keyboard damping is not
 BNE RE1                ; enabled, so jump to RE1 to return from the subroutine

.cnt2

 TXA                    ; If X < 128, then it's in the left-hand side of the
 BPL BUMP               ; dashboard slider, so jump to BUMP to bump it up by 1,
                        ; to move it closer to the centre

 DEX                    ; Otherwise X >= 128, so it's in the right-hand side
 BMI RE1                ; of the dashboard slider, so decrement X by 1, and if
                        ; it's still >= 128, jump to RE1 to return from the
                        ; subroutine, otherwise fall through to BUMP to undo
                        ; the bump and then return

.BUMP

 INX                    ; Bump X up by 1, and if it hasn't overshot the end of
 BNE RE1                ; the dashboard slider, jump to RE1 to return from the
                        ; subroutine, otherwise fall through to REDU to drop
                        ; it down by 1 again

.REDU

 DEX                    ; Reduce X by 1, and if we have reached 0 jump up to
 BEQ BUMP               ; BUMP to add 1, because we need the value to be in the
                        ; range 1 to 255

.RE1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: BUMP2
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Bump up the value of the pitch or roll dashboard indicator
;
; ------------------------------------------------------------------------------
;
; Increase ("bump up") X by A, where X is either the current rate of pitch or
; the current rate of roll.
;
; The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
; This is the amount by which the pitch or roll is currently changing, so 1
; means it is decreasing at the maximum rate, 128 means it is not changing,
; and 255 means it is increasing at the maximum rate. These values correspond
; to the line on the DC or RL indicators on the dashboard, with 1 meaning full
; left, 128 meaning the middle, and 255 meaning full right.
;
; If bumping up X would push it past 255, then X is set to 255.
;
; If keyboard auto-recentre is configured and the result is less than 128, we
; bump X up to the mid-point, 128. This is the equivalent of having a roll or
; pitch in the left half of the indicator, when increasing the roll or pitch
; should jump us straight to the mid-point.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   RE2+2               Restore A from T and return from the subroutine
;
; ******************************************************************************

.BUMP2

 STA T                  ; Store argument A in T so we can restore it later

 TXA                    ; Copy argument X into A

 CLC                    ; Clear the C flag so we can do addition without the
                        ; C flag affecting the result

 ADC T                  ; Set X = A = argument X + argument A
 TAX

 BCC RE2                ; If the C flag is clear, then we didn't overflow, so
                        ; jump to RE2 to auto-recentre and return the result

 LDX #255               ; We have an overflow, so set X to the maximum possible
                        ; value of 255

.RE2

 BPL djd1               ; If X has bit 7 clear (i.e. the result < 128), then
                        ; jump to djd1 in routine REDU2 to do an auto-recentre,
                        ; if configured, because the result is on the left side
                        ; of the centre point of 128

                        ; Jumps to RE2+2 end up here

 LDA T                  ; Restore the original argument A from T into A

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: REDU2
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Reduce the value of the pitch or roll dashboard indicator
;
; ------------------------------------------------------------------------------
;
; Reduce X by A, where X is either the current rate of pitch or the current
; rate of roll.
;
; The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
; This is the amount by which the pitch or roll is currently changing, so 1
; means it is decreasing at the maximum rate, 128 means it is not changing,
; and 255 means it is increasing at the maximum rate. These values correspond
; to the line on the DC or RL indicators on the dashboard, with 1 meaning full
; left, 128 meaning the middle, and 255 meaning full right.
;
; If reducing X would bring it below 1, then X is set to 1.
;
; If keyboard auto-recentre is configured and the result is greater than 128, we
; reduce X down to the mid-point, 128. This is the equivalent of having a roll
; or pitch in the right half of the indicator, when decreasing the roll or pitch
; should jump us straight to the mid-point.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   djd1                Auto-recentre the value in X, if keyboard auto-recentre
;                       is configured
;
; ******************************************************************************

.REDU2

 STA T                  ; Store argument A in T so we can restore it later

 TXA                    ; Copy argument X into A

 SEC                    ; Set the C flag so we can do subtraction without the
                        ; C flag affecting the result

 SBC T                  ; Set X = A = argument X - argument A
 TAX

 BCS RE3                ; If the C flag is set, then we didn't underflow, so
                        ; jump to RE3 to auto-recentre and return the result

 LDX #1                 ; We have an underflow, so set X to the minimum possible
                        ; value, 1

.RE3

 BPL RE2+2              ; If X has bit 7 clear (i.e. the result < 128), then
                        ; jump to RE2+2 above to return the result as is,
                        ; because the result is on the left side of the centre
                        ; point of 128, so we don't need to auto-centre

.djd1

                        ; If we get here, then we need to apply auto-recentre,
                        ; if it is configured

 LDA DJD                ; If keyboard auto-recentre is disabled, then
 BNE RE2+2              ; jump to RE2+2 to restore A and return

 LDX #128               ; If we get here then keyboard auto-recentre is enabled,
 BMI RE2+2              ; so set X to 128 (the middle of our range) and jump to
                        ; RE2+2 to restore A and return from the subroutine
                        ; (this BMI is effectively a JMP as bit 7 of X is always
                        ; set)

; ******************************************************************************
;
;       Name: ARCTAN
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate A = arctan(P / Q)
;  Deep dive: The sine, cosine and arctan tables
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   A = arctan(P / Q)
;
; In other words, this finds the angle in the right-angled triangle where the
; opposite side to angle A is length P and the adjacent side to angle A has
; length Q, so:
;
;   tan(A) = P / Q
;
; The result in A is an integer representing the angle in radians. The routine
; returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
; PI radians).
;
; ******************************************************************************

.ARCTAN

 LDA P                  ; Set T1 = P EOR Q, which will have the sign of P * Q
 EOR Q                  ;
;AND #%10000000         ; The AND is commented out in the original source
 STA T1

 LDA Q                  ; If Q = 0, jump to AR2 to return a right angle
 BEQ AR2

 ASL A                  ; Set Q = |Q| * 2 (this is a quick way of clearing the
 STA Q                  ; sign bit, and we don't need to shift right again as we
                        ; only ever use this value in the division with |P| * 2,
                        ; which we set next)

 LDA P                  ; Set A = |P| * 2
 ASL A

 CMP Q                  ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
 BCS AR1                ; and Q around, so we can still use the lookup table

 JSR ARS1               ; Call ARS1 to set the following from the lookup table:
                        ;
                        ;   A = arctan(A / Q)
                        ;     = arctan(|P / Q|)

 SEC                    ; Set the C flag so the SBC instruction in AR3 will be
                        ; correct, should we jump there

.AR4

 LDX T1                 ; If T1 is negative, i.e. P and Q have different signs,
 BMI AR3                ; jump down to AR3 to return arctan(-|P / Q|)

 RTS                    ; Otherwise P and Q have the same sign, so our result is
                        ; correct and we can return from the subroutine

.AR1

                        ; We want to calculate arctan(t) where |t| > 1, so we
                        ; can use the calculation described in the documentation
                        ; for the ACT table, i.e. 64 - arctan(1 / t)

 LDX Q                  ; Swap the values in Q and P, using the fact that we
 STA Q                  ; called AR1 with A = P
 STX P                  ;
 TXA                    ; This also sets A = P (which now contains the original
                        ; argument |Q|)

 JSR ARS1               ; Call ARS1 to set the following from the lookup table:
                        ;
                        ;   A = arctan(A / Q)
                        ;     = arctan(|Q / P|)
                        ;     = arctan(1 / |P / Q|)

 STA T                  ; Set T = 64 - T
 LDA #64
 SBC T

 BCS AR4                ; Jump to AR4 to continue the calculation (this BCS is
                        ; effectively a JMP as the subtraction will never
                        ; underflow, as ARS1 returns values in the range 0-31)

.AR2

                        ; If we get here then Q = 0, so tan(A) = infinity and
                        ; A is a right angle, or 0.25 of a circle. We allocate
                        ; 255 to a full circle, so we should return 63 for a
                        ; right angle

 LDA #63                ; Set A to 63, to represent a right angle

 RTS                    ; Return from the subroutine

.AR3

                        ; A contains arctan(|P / Q|) but P and Q have different
                        ; signs, so we need to return arctan(-|P / Q|), using
                        ; the calculation described in the documentation for the
                        ; ACT table, i.e. 128 - A

 STA T                  ; Set A = 128 - A
 LDA #128               ;
;SEC                    ; The SEC instruction is commented out in the original
 SBC T                  ; source, and isn't required as we did a SEC before
                        ; calling AR3

 RTS                    ; Return from the subroutine

.ARS1

                        ; This routine fetches arctan(A / Q) from the ACT table,
                        ; so A will be set to an integer in the range 0 to 31
                        ; that represents an angle from 0 to 45 degrees (or 0 to
                        ; PI / 4 radians)

 JSR LL28               ; Call LL28 to calculate:
                        ;
                        ;   R = 256 * A / Q

 LDA R                  ; Set X = R / 8
 LSR A                  ;       = 32 * A / Q
 LSR A                  ;
 LSR A                  ; so X has the value t * 32 where t = A / Q, which is
 TAX                    ; what we need to look up values in the ACT table

 LDA ACT,X              ; Fetch ACT+X from the ACT table into A, so now:
                        ;
                        ;   A = value in ACT + X
                        ;     = value in ACT + (32 * A / Q)
                        ;     = arctan(A / Q)

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: LASLI
;       Type: Subroutine
;   Category: Drawing lines
;    Summary: Draw the laser lines for when we fire our lasers
;
; ------------------------------------------------------------------------------
;
; Draw the laser lines, aiming them to slightly different place each time so
; they appear to flicker and dance. Also heat up the laser temperature and drain
; some energy.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   LASLI2              Just draw the current laser lines without moving the
;                       centre point, draining energy or heating up. This has
;                       the effect of removing the lines from the screen
;
;   LASLI-1             Contains an RTS
;
; ******************************************************************************

.LASLI

 JSR DORND              ; Set A and X to random numbers

 AND #7                 ; Restrict A to a random value in the range 0 to 7

 ADC #Y-4               ; Set LASY to four pixels above the centre of the
 STA LASY               ; screen (#Y), plus our random number, so the laser
                        ; dances above and below the centre point

 JSR DORND              ; Set A and X to random numbers

 AND #7                 ; Restrict A to a random value in the range 0 to 7

 ADC #X-4               ; Set LASX to four pixels left of the centre of the
 STA LASX               ; screen (#X), plus our random number, so the laser
                        ; dances to the left and right of the centre point

 LDA GNTMP              ; Add 8 to the laser temperature in GNTMP
 ADC #8
 STA GNTMP

 JSR DENGY              ; Call DENGY to deplete our energy banks by 1

.LASLI2

 LDA QQ11               ; If this is not a space view (i.e. QQ11 is non-zero)
 BNE LASLI-1            ; then jump to MA9 to return from the main flight loop
                        ; (as LASLI-1 is an RTS)

;LDA #RED               ; These instructions are commented out in the original
;STA COL                ; source; they would switch to colour 2, which is red in
                        ; the space view

 LDA #32                ; Set A = 32 and Y = 224 for the first set of laser
 LDY #224               ; lines (the wider pair of lines)

 JSR las                ; Call las below to draw the first set of laser lines

 LDA #48                ; Fall through into las with A = 48 and Y = 208 to draw
 LDY #208               ; a second set of lines (the narrower pair)

                        ; The following routine draws two laser lines, one from
                        ; the centre point down to point A on the bottom row,
                        ; and the other from the centre point down to point Y
                        ; on the bottom row. We therefore get lines from the
                        ; centre point to points 32, 48, 208 and 224 along the
                        ; bottom row, giving us the triangular laser effect
                        ; we're after

.las

 STA X2                 ; Set X2 = A

 LDA LASX               ; Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 LDA #2*Y-1             ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
 STA Y2                 ; y-coordinate of the mid-point of the space view, so
                        ; this sets Y2 to 191, the y-coordinate of the bottom
                        ; pixel row of the space view

 JSR LL30               ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        ; the centre point to (A, 191)

 LDA LASX               ; Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 STY X2                 ; Set X2 = Y

 LDA #2*Y-1             ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
 STA Y2                 ; pixel row of the space view (as before)

 JMP LL30               ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        ; the centre point to (Y, 191), and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: PDESC
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the system's extended description or a mission 1 directive
;  Deep dive: Extended system descriptions
;             Extended text tokens
;
; ------------------------------------------------------------------------------
;
; This prints a specific system's extended description. This is called the "pink
; volcanoes string" in a comment in the original source, and the "goat soup"
; recipe by Ian Bell on his website (where he also refers to the species string
; as the "pink felines" string).
;
; For some special systems, when you are docked at them, the procedurally
; generated extended description is overridden and a text token from the RUTOK
; table is shown instead. If mission 1 is in progress, then a number of systems
; along the route of that mission's story will show custom mission-related
; directives in place of that system's normal "goat soup" phrase.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   ZZ                  The system number (0-255)
;
; ******************************************************************************

.PDESC

 LDA QQ8                ; If either byte in QQ18(1 0) is non-zero, meaning that
 ORA QQ8+1              ; the distance from the current system to the selected
 BNE PD1                ; is non-zero, jump to PD1 to show the standard "goat
                        ; soup" description

 LDA QQ12               ; If QQ12 does not have bit 7 set, which means we are
 BPL PD1                ; not docked, jump to PD1 to show the standard "goat
                        ; soup" description

                        ; If we get here, then the current system is the same as
                        ; the selected system and we are docked, so now to check
                        ; whether there is a special override token for this
                        ; system

 LDY #NRU%              ; Set Y as a loop counter as we work our way through the
                        ; system numbers in RUPLA, starting at NRU% (which is
                        ; the number of entries in RUPLA, 26) and working our
                        ; way down to 1

.PDL1

 LDA RUPLA-1,Y          ; Fetch the Y-th byte from RUPLA-1 into A (we use
                        ; RUPLA-1 because Y is looping from 26 to 1)

 CMP ZZ                 ; If A doesn't match the system whose description we
 BNE PD2                ; are printing (in ZZ), jump to PD2 to keep looping
                        ; through the system numbers in RUPLA

                        ; If we get here we have found a match for this system
                        ; number in RUPLA

 LDA RUGAL-1,Y          ; Fetch the Y-th byte from RUGAL-1 into A

 AND #%01111111         ; Extract bits 0-6 of A

 CMP GCNT               ; If the result does not equal the current galaxy
 BNE PD2                ; number, jump to PD2 to keep looping through the system
                        ; numbers in RUPLA

 LDA RUGAL-1,Y          ; Fetch the Y-th byte from RUGAL-1 into A, once again

 BMI PD3                ; If bit 7 is set, jump to PD3 to print the extended
                        ; token in A from the second table in RUTOK

 LDA TP                 ; Fetch bit 0 of TP into the C flag, and skip to PD1 if
 LSR A                  ; it is clear (i.e. if mission 1 is not in progress) to
 BCC PD1                ; print the "goat soup" extended description

                        ; If we get here then mission 1 is in progress, so we
                        ; print out the corresponding token from RUTOK

 JSR MT14               ; Call MT14 to switch to justified text

 LDA #1                 ; Set A = 1 so that extended token 1 (an empty string)
                        ; gets printed below instead of token 176, followed by
                        ; the Y-th token in RUTOK

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A9 $B0, or BIT $B0A9, which does nothing apart
                        ; from affect the flags

.PD3

 LDA #176               ; Print extended token 176 ("{lower case}{justify}
 JSR DETOK2             ; {single cap}")

 TYA                    ; Print the extended token in Y from the second table
 JSR DETOK3             ; in RUTOK

 LDA #177               ; Set A = 177 so when we jump to PD4 in the next
                        ; instruction, we print token 177 (".{cr}{left align}")

 BNE PD4                ; Jump to PD4 to print the extended token in A and
                        ; return from the subroutine using a tail call

.PD2

 DEY                    ; Decrement the byte counter in Y

 BNE PDL1               ; Loop back to check the next byte in RUPLA until we
                        ; either find a match for the system in ZZ, or we fall
                        ; through into the "goat soup" extended description
                        ; routine

.PD1

                        ; We now print the "goat soup" extended description

 LDX #3                 ; We now want to seed the random number generator with
                        ; the s1 and s2 16-bit seeds from the current system, so
                        ; we get the same extended description for each system
                        ; every time we call PDESC, so set a counter in X for
                        ; copying 4 bytes

{
.PDL1                   ; This label is a duplicate of the label above (which is
                        ; why we need to surround it with braces, as BeebAsm
                        ; doesn't allow us to redefine labels, unlike BBC BASIC)

 LDA QQ15+2,X           ; Copy QQ15+2 to QQ15+5 (s1 and s2) to RAND to RAND+3
 STA RAND,X

 DEX                    ; Decrement the loop counter

 BPL PDL1               ; Loop back to PDL1 until we have copied all

 LDA #5                 ; Set A = 5, so we print extended token 5 in the next
                        ; instruction ("{lower case}{justify}{single cap}[86-90]
                        ; IS [140-144].{cr}{left align}"
}

.PD4

 JMP DETOK              ; Print the extended token given in A, and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: BRIEF2
;       Type: Subroutine
;   Category: Missions
;    Summary: Start mission 2
;  Deep dive: The Thargoid Plans mission
;
; ******************************************************************************

.BRIEF2

 LDA TP                 ; Set bit 2 of TP to indicate mission 2 is in progress
 ORA #%00000100         ; but plans have not yet been picked up
 STA TP

 LDA #11                ; Set A = 11 so the call to BRP prints extended token 11
                        ; (the initial contact at the start of mission 2, asking
                        ; us to head for Ceerdi for a mission briefing)

                        ; Fall through into BRP to print the extended token in A
                        ; and show the Status Mode screen

; ******************************************************************************
;
;       Name: BRP
;       Type: Subroutine
;   Category: Missions
;    Summary: Print an extended token and show the Status Mode screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   BAYSTEP             Go to the docking bay (i.e. show the Status Mode screen)
;
; ******************************************************************************

.BRP

 JSR DETOK              ; Print the extended token in A

.BAYSTEP

 JMP BAY                ; Jump to BAY to go to the docking bay (i.e. show the
                        ; Status Mode screen) and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: BRIEF3
;       Type: Subroutine
;   Category: Missions
;    Summary: Receive the briefing and plans for mission 2
;  Deep dive: The Thargoid Plans mission
;
; ******************************************************************************

.BRIEF3

 LDA TP                 ; Set bits 1 and 3 of TP to indicate that mission 1 is
 AND #%11110000         ; complete, and mission 2 is in progress and the plans
 ORA #%00001010         ; have been picked up
 STA TP

 LDA #222               ; Set A = 222 so the call to BRP prints extended token
                        ; 222 (the briefing for mission 2 where we pick up the
                        ; plans we need to take to Birera)

 BNE BRP                ; Jump to BRP to print the extended token in A and show
                        ; the Status Mode screen), returning from the subroutine
                        ; using a tail call (this BNE is effectively a JMP as A
                        ; is never zero)

; ******************************************************************************
;
;       Name: DEBRIEF2
;       Type: Subroutine
;   Category: Missions
;    Summary: Finish mission 2
;  Deep dive: The Thargoid Plans mission
;
; ******************************************************************************

.DEBRIEF2

 LDA TP                 ; Set bit 2 of TP to indicate mission 2 is complete (so
 ORA #%00000100         ; both bits 2 and 3 are now set)
 STA TP

 LDA #2                 ; Set ENGY to 2 so our energy banks recharge at a faster
 STA ENGY               ; rate, as our mission reward is a special navy energy
                        ; unit that recharges at a rate of 3 units of energy on
                        ; each iteration of the main loop, compared to a rate of
                        ; 2 units of energy for the standard energy unit

 INC TALLY+1            ; Award 256 kill points for completing the mission

 LDA #223               ; Set A = 223 so the call to BRP prints extended token
                        ; 223 (the thank you message at the end of mission 2)

 BNE BRP                ; Jump to BRP to print the extended token in A and show
                        ; the Status Mode screen), returning from the subroutine
                        ; using a tail call (this BNE is effectively a JMP as A
                        ; is never zero)

; ******************************************************************************
;
;       Name: DEBRIEF
;       Type: Subroutine
;   Category: Missions
;    Summary: Finish mission 1
;  Deep dive: The Constrictor mission
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   BRPS                Print the extended token in A, show the Status Mode
;                       screen and return from the subroutine
;
; ******************************************************************************

.DEBRIEF

 LSR TP                 ; Clear bit 0 of TP to indicate that mission 1 is no
 ASL TP                 ; longer in progress, as we have completed it

;INC TALLY+1            ; This instruction is commented out in the original
                        ; source

 LDX #LO(50000)         ; Increase our cash reserves by the generous mission
 LDY #HI(50000)         ; reward of 5,000 CR
 JSR MCASH

 LDA #15                ; Set A = 15 so the call to BRP prints extended token 15
                        ; (the thank you message at the end of mission 1)

.BRPS

 BNE BRP                ; Jump to BRP to print the extended token in A and show
                        ; the Status Mode screen, returning from the subroutine
                        ; using a tail call (this BNE is effectively a JMP as A
                        ; is never zero)

; ******************************************************************************
;
;       Name: TBRIEF
;       Type: Subroutine
;   Category: Missions
;    Summary: Start mission 3
;  Deep dive: The Trumbles mission
;
; ******************************************************************************

.TBRIEF

 LDA TP                 ; Set bit 4 of TP to indicate that mission 3 has been
 ORA #%00010000         ; triggered
 STA TP

 LDA #199               ; Print extended token 199, which is the briefing for
 JSR DETOK              ; the Trumbles mission

 JSR YESNO              ; Call YESNO to wait until either "Y" or "N" is pressed

 BCC BAYSTEP            ; If "N" was pressed, then the mission was not accepted,
                        ; jump to BAYSTEP to go to the docking bay (i.e. show
                        ; the Status Mode screen)

 LDY #HI(50000)         ; Otherwise the mission was accepted, so subtract
 LDX #LO(50000)         ; 50,000 CR from the cash pot to pay for the Trumble
 JSR LCASH

 INC TRIBBLE            ; Increment the number of Trumbles from 0 to 1, so they
                        ; start breeding

 JMP BAY                ; Go to the docking bay (i.e. show the Status Mode
                        ; screen)

; ******************************************************************************
;
;       Name: BRIEF
;       Type: Subroutine
;   Category: Missions
;    Summary: Start mission 1 and show the mission briefing
;  Deep dive: The Constrictor mission
;
; ------------------------------------------------------------------------------
;
; This routine does the following:
;
;   * Clear the screen
;   * Display "INCOMING MESSAGE" in the middle of the screen
;   * Wait for 2 seconds
;   * Clear the screen
;   * Show the Constrictor rolling and pitching in the middle of the screen
;   * Do this for 64 loop iterations
;   * Move the ship away from us and up until it's near the top of the screen
;   * Show the mission 1 briefing in extended token 10
;
; The mission briefing ends with a "{display ship, wait for key press}" token,
; which calls the PAUSE routine. This continues to display the rotating ship,
; waiting until a key is pressed, and then removes the ship from the screen.
;
; ******************************************************************************

.BRIEF

 LSR TP                 ; Set bit 0 of TP to indicate that mission 1 is now in
 SEC                    ; progress
 ROL TP

 JSR BRIS               ; Call BRIS to clear the screen, display "INCOMING
                        ; MESSAGE" and wait for 2 seconds

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 LDA #CON               ; Set the ship type in TYPE to the Constrictor
 STA TYPE

 JSR NWSHP              ; Add a new Constrictor to the local bubble (in this
                        ; case, the briefing screen)

 LDA #1                 ; Move the text cursor to column 1
 JSR DOXC

 STA INWK+7             ; Set z_hi = 1, the distance at which we show the
                        ; rotating ship

 JSR TT66               ; Clear the top part of the screen, draw a white border,
                        ; and set the current view type in QQ11 to 1

 LDA #64                ; Set the main loop counter to 64, so the ship rotates
 STA MCNT               ; for 64 iterations through MVEIT

.BRL1

 LDX #%01111111         ; Set the ship's roll counter to a positive roll that
 STX INWK+29            ; doesn't dampen (a clockwise roll)

 STX INWK+30            ; Set the ship's pitch counter to a positive pitch that
                        ; doesn't dampen (a diving pitch)

 JSR LL9                ; Draw the ship on screen

 JSR MVEIT              ; Call MVEIT to rotate the ship in space

 DEC MCNT               ; Decrease the counter in MCNT

 BNE BRL1               ; Loop back to keep moving the ship until we have done
                        ; all 64 iterations

.BRL2

 LSR INWK               ; Halve x_lo so the Constrictor moves towards the centre

 INC INWK+6             ; Increment z_lo so the Constrictor moves away from us

 BEQ BR2                ; If z_lo = 0 (i.e. it just went past 255), jump to BR2
                        ; to show the briefing

 INC INWK+6             ; Increment z_lo so the Constrictor moves a bit further
                        ; away from us

 BEQ BR2                ; If z_lo = 0 (i.e. it just went past 255), jump out of
                        ; the loop to BR2 to stop moving the ship up the screen
                        ; and show the briefing

 LDX INWK+3             ; Set X = y_lo + 1
 INX

 CPX #conhieght         ; If X < conhieght then skip the next instruction
 BCC P%+4

 LDX #conhieght         ; X is bigger than conhieght, so set X = conhieght so
                        ; that X has a maximum value of conhieght

 STX INWK+3             ; Set y_lo = X
                        ;          = y_lo + 1
                        ;
                        ; so the ship moves up the screen (as space coordinates
                        ; have the y-axis going up)

 JSR LL9                ; Draw the ship on screen

 JSR MVEIT              ; Call MVEIT to move and rotate the ship in space

 DEC MCNT               ; Decrease the counter in MCNT

 JMP BRL2               ; Loop back to keep moving the ship up the screen and
                        ; away from us

.BR2

 INC INWK+7             ; Increment z_hi, to keep the ship at the same distance
                        ; as we just incremented z_lo past 255

 LDA #10                ; Set A = 10 so the call to BRP prints extended token 10
                        ; (the briefing for mission 1 where we find out all
                        ; about the stolen Constrictor)

 BNE BRPS               ; Jump to BRP via BRPS to print the extended token in A
                        ; and show the Status Mode screen, returning from the
                        ; subroutine using a tail call (this BNE is effectively
                        ; a JMP as A is never zero)

; ******************************************************************************
;
;       Name: BRIS
;       Type: Subroutine
;   Category: Missions
;    Summary: Clear the screen, display "INCOMING MESSAGE" and wait for 2
;             seconds
;
; ******************************************************************************

.BRIS

 LDA #216               ; Print extended token 216 ("{clear screen}{tab 6}{move
 JSR DETOK              ; to row 10, white, lower case}{white}{all caps}INCOMING
                        ; MESSAGE"

 LDY #100               ; Delay for 100 vertical syncs (100/50 = 2 seconds) and
 JMP DELAY              ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: PAUSE
;       Type: Subroutine
;   Category: Missions
;    Summary: Display a rotating ship, waiting until a key is pressed, then
;             remove the ship from the screen
;
; ******************************************************************************

.PAUSE

 JSR PAS1               ; Call PAS1 to display the rotating ship at space
                        ; coordinates (0, 112, 256) and scan the keyboard,
                        ; returning the internal key number in X (or 0 for no
                        ; key press)

 BNE PAUSE              ; If a key was already being held down when we entered
                        ; this routine, keep looping back up to PAUSE, until
                        ; the key is released

.PAL1

 JSR PAS1               ; Call PAS1 to display the rotating ship at space
                        ; coordinates (0, 112, 256) and scan the keyboard,
                        ; returning the internal key number in X (or 0 for no
                        ; key press)

 BEQ PAL1               ; Keep looping up to PAL1 until a key is pressed

 LDA #0                 ; Set the ship's AI flag to 0 (no AI) so it doesn't get
 STA INWK+31            ; any ideas of its own

 LDA #1                 ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 1

 JSR LL9                ; Draw the ship on screen to redisplay it

                        ; Fall through into MT23 to move to row 10, switch to
                        ; white text, and switch to lower case when printing
                        ; extended tokens

; ******************************************************************************
;
;       Name: MT23
;       Type: Subroutine
;   Category: Text
;    Summary: Move to row 10, switch to white text, and switch to lower case
;             when printing extended tokens
;  Deep dive: Extended text tokens
;
; ******************************************************************************

.MT23

 LDA #10                ; Set A = 10, so when we fall through into MT29, the
                        ; text cursor gets moved to row 10

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A9 $06, or BIT $06A9, which does nothing apart
                        ; from affect the flags

                        ; Fall through into MT29 to move to the row in A, switch
                        ; to white text, and switch to lower case

; ******************************************************************************
;
;       Name: MT29
;       Type: Subroutine
;   Category: Text
;    Summary: Move to row 6, switch to white text, and switch to lower case when
;             printing extended tokens
;  Deep dive: Extended text tokens
;
; ------------------------------------------------------------------------------
;
; This routine sets the following:
;
;   * YC = 6 (move to row 6)
;
; Then it calls WHITETEXT to switch to white text, before jumping to MT13 to
; switch to lower case when printing extended tokens.
;
; ******************************************************************************

.MT29

 LDA #6                 ; Move the text cursor to row 6
 JSR DOYC

 JSR WHITETEXT          ; Set white text

 JMP MT13               ; Jump to MT13 to set bit 7 of DTW6 and bit 5 of DTW1,
                        ; returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: PAS1
;       Type: Subroutine
;   Category: Missions
;    Summary: Display a rotating ship at space coordinates (0, conhieght, 256)
;             and scan the keyboard
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   If a key is being pressed, X contains the ASCII code of
;                       the key being pressed, otherwise it contains 0
;
;   A                   Contains the same as X
;
; ******************************************************************************

.PAS1

 LDA #conhieght         ; Set y_lo = conhieght
 STA INWK+3

 LDA #0                 ; Set x_lo = 0
 STA INWK

 STA INWK+6             ; Set z_lo = 0

 LDA #2                 ; Set z_hi = 1, so (z_hi z_lo) = 256
 STA INWK+7

 JSR LL9                ; Draw the ship on screen

 JSR MVEIT              ; Call MVEIT to move and rotate the ship in space

 JMP RDKEY              ; Scan the keyboard for a key press and return the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press), returning from the subroutine using a tail
                        ; call

; ******************************************************************************
;
;       Name: PAUSE2
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Wait until a key is pressed, ignoring any existing key press
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   The ASCII code of the key that was pressed
;
; ******************************************************************************

.PAUSE2

 JSR RDKEY              ; Scan the keyboard for a key press and return the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 BNE PAUSE2             ; If a key was already being held down when we entered
                        ; this routine, keep looping back up to PAUSE2, until
                        ; the key is released

 JSR RDKEY              ; Any pre-existing key press is now gone, so we can
                        ; start scanning the keyboard again, returning the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 BEQ PAUSE2             ; Keep looping up to PAUSE2 until a key is pressed

.newyearseve

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GINF
;       Type: Subroutine
;   Category: Universe
;    Summary: Fetch the address of a ship's data block into INF
;
; ------------------------------------------------------------------------------
;
; Get the address of the data block for ship slot X and store it in INF. This
; address is fetched from the UNIV table, which stores the addresses of the 13
; ship data blocks in workspace K%.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The ship slot number for which we want the data block
;                       address
;
; ******************************************************************************

.GINF

 TXA                    ; Set Y = X * 2
 ASL A
 TAY

 LDA UNIV,Y             ; Get the high byte of the address of the X-th ship
 STA INF                ; from UNIV and store it in INF

 LDA UNIV+1,Y           ; Get the low byte of the address of the X-th ship
 STA INF+1              ; from UNIV and store it in INF

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ping
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the selected system to the current system
;
; ******************************************************************************

.ping

 LDX #1                 ; We want to copy the X- and Y-coordinates of the
                        ; current system in (QQ0, QQ1) to the selected system's
                        ; coordinates in (QQ9, QQ10), so set up a counter to
                        ; copy two bytes

.pl1

 LDA QQ0,X              ; Load byte X from the current system in QQ0/QQ1

 STA QQ9,X              ; Store byte X in the selected system in QQ9/QQ10

 DEX                    ; Decrement the loop counter

 BPL pl1                ; Loop back for the next byte to copy

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DELAY
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Wait for a specified time, in 1/50s of a second
;
; ------------------------------------------------------------------------------
;
; Wait for the number of vertical syncs given in Y, so this effectively waits
; for Y/50 of a second (as the vertical sync occurs 50 times a second).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The number of vertical sync events to wait for
;
; ******************************************************************************

.DELAY

 JSR WSCAN              ; Call WSCAN to wait for the vertical sync, so the whole
                        ; screen gets drawn

 DEY                    ; Decrement the counter in Y

 BNE DELAY              ; If Y isn't yet at zero, jump back to DELAY to wait
                        ; for another vertical sync

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: sightcol
;       Type: Variable
;   Category: Drawing lines
;    Summary: Colours for the crosshair sights on the different laser types
;
; ******************************************************************************

.sightcol

 EQUB 7                 ; Pulse lasers have ??? sights

 EQUB 7                 ; Beam lasers have ??? sights

 EQUB 13                ; Military lasers have ??? sights

 EQUB 4                 ; Mining lasers have ??? sights

; ******************************************************************************
;
;       Name: MTIN
;       Type: Variable
;   Category: Text
;    Summary: Lookup table for random tokens in the extended token table (0-37)
;  Deep dive: Extended text tokens
;
; ------------------------------------------------------------------------------
;
; The ERND token type, which is part of the extended token system, takes an
; argument between 0 and 37, and returns a randomly chosen token in the range
; specified in this table. This is used to generate the extended description of
; each system.
;
; For example, the entry at position 13 in this table (counting from 0) is 66,
; so ERND 14 will expand into a random token in the range 66-70, i.e. one of
; "JUICE", "BRANDY", "WATER", "BREW" and "GARGLE BLASTERS".
;
; ******************************************************************************

.MTIN

 EQUB 16                ; Token  0: a random extended token between 16 and 20
 EQUB 21                ; Token  1: a random extended token between 21 and 25
 EQUB 26                ; Token  2: a random extended token between 26 and 30
 EQUB 31                ; Token  3: a random extended token between 31 and 35
 EQUB 155               ; Token  4: a random extended token between 155 and 159
 EQUB 160               ; Token  5: a random extended token between 160 and 164
 EQUB 46                ; Token  6: a random extended token between 46 and 50
 EQUB 165               ; Token  7: a random extended token between 165 and 169
 EQUB 36                ; Token  8: a random extended token between 36 and 40
 EQUB 41                ; Token  9: a random extended token between 41 and 45
 EQUB 61                ; Token 10: a random extended token between 61 and 65
 EQUB 51                ; Token 11: a random extended token between 51 and 55
 EQUB 56                ; Token 12: a random extended token between 56 and 60
 EQUB 170               ; Token 13: a random extended token between 170 and 174
 EQUB 66                ; Token 14: a random extended token between 66 and 70
 EQUB 71                ; Token 15: a random extended token between 71 and 75
 EQUB 76                ; Token 16: a random extended token between 76 and 80
 EQUB 81                ; Token 17: a random extended token between 81 and 85
 EQUB 86                ; Token 18: a random extended token between 86 and 90
 EQUB 140               ; Token 19: a random extended token between 140 and 144
 EQUB 96                ; Token 20: a random extended token between 96 and 100
 EQUB 101               ; Token 21: a random extended token between 101 and 105
 EQUB 135               ; Token 22: a random extended token between 135 and 139
 EQUB 130               ; Token 23: a random extended token between 130 and 134
 EQUB 91                ; Token 24: a random extended token between 91 and 95
 EQUB 106               ; Token 25: a random extended token between 106 and 110
 EQUB 180               ; Token 26: a random extended token between 180 and 184
 EQUB 185               ; Token 27: a random extended token between 185 and 189
 EQUB 190               ; Token 28: a random extended token between 190 and 194
 EQUB 225               ; Token 29: a random extended token between 225 and 229
 EQUB 230               ; Token 30: a random extended token between 230 and 234
 EQUB 235               ; Token 31: a random extended token between 235 and 239
 EQUB 240               ; Token 32: a random extended token between 240 and 244
 EQUB 245               ; Token 33: a random extended token between 245 and 249
 EQUB 250               ; Token 34: a random extended token between 250 and 254
 EQUB 115               ; Token 35: a random extended token between 115 and 119
 EQUB 120               ; Token 36: a random extended token between 120 and 124
 EQUB 125               ; Token 37: a random extended token between 125 and 129

.R%                     ; ???

; ******************************************************************************
;
; Save ELTC.bin
;
; ******************************************************************************

 PRINT "ELITE C"
 PRINT "Assembled at ", ~CODE_C%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_C%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_C%

 PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
 SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%

; ******************************************************************************
;
; ELITE D FILE
;
; Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 ORG C% ; $7300 in source disk, $6A00 in gma85 ???

 CODE_D% = P%

 LOAD_D% = LOAD% + P% - CODE%

; ******************************************************************************
;
;       Name: tnpr1
;       Type: Subroutine
;   Category: Market
;    Summary: Work out if we have space for one tonne of cargo
;
; ------------------------------------------------------------------------------
;
; Given a market item, work out whether there is room in the cargo hold for one
; tonne of this item.
;
; For standard tonne canisters, the limit is given by the type of cargo hold we
; have, with a standard cargo hold having a capacity of 20t and an extended
; cargo bay being 35t.
;
; For items measured in kg (gold, platinum), g (gem-stones) and alien items,
; the individual limit on each of these is 200 units.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The type of market item (see QQ23 for a list of market
;                       item numbers)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A = 1
;
;   C flag              Returns the result:
;
;                         * Set if there is no room for this item
;
;                         * Clear if there is room for this item
;
; ******************************************************************************

.tnpr1

 STA QQ29               ; Store the type of market item in QQ29

 LDA #1                 ; Set the number of units of this market item to 1

                        ; Fall through into tnpr to work out whether there is
                        ; room in the cargo hold for A tonnes of the item of
                        ; type QQ29

; ******************************************************************************
;
;       Name: tnpr
;       Type: Subroutine
;   Category: Market
;    Summary: Work out if we have space for a specific amount of cargo
;
; ------------------------------------------------------------------------------
;
; Given a market item and an amount, work out whether there is room in the
; cargo hold for this item.
;
; For standard tonne canisters, the limit is given by the type of cargo hold we
; have, with a standard cargo hold having a capacity of 20t and an extended
; cargo bay being 35t.
;
; For items measured in kg (gold, platinum), g (gem-stones) and alien items,
; the individual limit on each of these is 200 units.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The number of units of this market item
;
;   QQ29                The type of market item (see QQ23 for a list of market
;                       item numbers)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A is preserved
;
;   C flag              Returns the result:
;
;                         * Set if there is no room for this item
;
;                         * Clear if there is room for this item
;
; ******************************************************************************

.tnpr

 PHA                    ; Store A on the stack

 LDX #12                ; If QQ29 > 12 then jump to kg below, as this cargo
 CPX QQ29               ; type is gold, platinum, gem-stones or alien items,
 BCC kg                 ; and they have different cargo limits to the standard
                        ; tonne canisters

.Tml

                        ; Here we count the tonne canisters we have in the hold
                        ; and add to A to see if we have enough room for A more
                        ; tonnes of cargo, using X as the loop counter, starting
                        ; with X = 12

 ADC QQ20,X             ; Set A = A + the number of tonnes we have in the hold
                        ; of market item number X. Note that the first time we
                        ; go round this loop, the C flag is set (as we didn't
                        ; branch with the BCC above, so the effect of this loop
                        ; is to count the number of tonne canisters in the hold,
                        ; and add 1

 DEX                    ; Decrement the loop counter

 BPL Tml                ; Loop back to add in the next market item in the hold,
                        ; until we have added up all market items from 12
                        ; (minerals) down to 0 (food)

 ADC TRIBBLE+1          ; Add the high byte of the number of Trumbles in the
                        ; hold, as 256 Trumbles take up one tonne of cargo space

 CMP CRGO               ; If A < CRGO then the C flag will be clear (we have
                        ; room in the hold)
                        ;
                        ; If A >= CRGO then the C flag will be set (we do not
                        ; have room in the hold)
                        ;
                        ; This works because A contains the number of canisters
                        ; plus 1, while CRGO contains our cargo capacity plus 2,
                        ; so if we actually have "a" canisters and a capacity
                        ; of "c", then:
                        ;
                        ; A < CRGO means: a+1 <  c+2
                        ;                 a   <  c+1
                        ;                 a   <= c
                        ;
                        ; So this is why the value in CRGO is 2 higher than the
                        ; actual cargo bay size, i.e. it's 22 for the standard
                        ; 20-tonne bay, and 37 for the large 35-tonne bay

 PLA                    ; Restore A from the stack

 RTS                    ; Return from the subroutine

.kg

                        ; Here we count the number of items of this type that
                        ; we already have in the hold, and add to A to see if
                        ; we have enough room for A more units

 LDY QQ29               ; Set Y to the item number we want to add

 ADC QQ20,Y             ; Set A = A + the number of units of this item that we
                        ; already have in the hold

 CMP #200               ; Is the result greater than 200 (the limit on
                        ; individual stocks of gold, platinum, gem-stones and
                        ; alien items)?
                        ;
                        ; If so, this sets the C flag (no room)
                        ;
                        ; Otherwise it is clear (we have room)

 PLA                    ; Restore A from the stack

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOXC
;       Type: Subroutine
;   Category: Text
;    Summary: Move the text cursor to a specific column
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text column
;
; ******************************************************************************

.DOXC

 STA XC                 ; Store the new text column in XC

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOYC
;       Type: Subroutine
;   Category: Text
;    Summary: Move the text cursor to a specific row
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text row
;
; ******************************************************************************

.DOYC

 STA YC                 ; Store the new text row in YC

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: INCYC
;       Type: Subroutine
;   Category: Text
;    Summary: Move the text cursor to the next row
;
; ******************************************************************************

.INCYC

 INC YC                 ; Move the text cursor to the next row

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOVDU19
;       Type: Subroutine
;   Category: Drawing the screen
;    Summary: Change the trading screen palette
;
; ------------------------------------------------------------------------------
;
; ******************************************************************************

.DOVDU19

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TRADEMODE
;       Type: Subroutine
;   Category: Drawing the screen
;    Summary: Clear the screen and set up a trading screen
;
; ------------------------------------------------------------------------------
;
; Clear the top part of the screen, draw a border and set the current view
; type in QQ11 to A.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The type of the new current view (see QQ11 for a list of
;                       view types)
;
; ******************************************************************************

.TRADEMODE

 JSR TT66               ; Clear the top part of the screen, draw a white border,
                        ; and set the current view type in QQ11 to A

 JSR FLKB               ; Call FLKB to flush the keyboard buffer

 LDA #48                ; Switch to the palette for trading screens, though this
 JSR DOVDU19            ; doesn't actually do anything in this version of Elite

;LDA #CYAN              ; These instructions are commented out in the original
;JMP DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to white)

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT20
;       Type: Subroutine
;   Category: Universe
;    Summary: Twist the selected system's seeds four times
;  Deep dive: Twisting the system seeds
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Twist the three 16-bit seeds in QQ15 (selected system) four times, to
; generate the next system.
;
; ******************************************************************************

.TT20

 JSR P%+3               ; This line calls the line below as a subroutine, which
                        ; does two twists before returning here, and then we
                        ; fall through to the line below for another two
                        ; twists, so the net effect of these two consecutive
                        ; JSR calls is four twists, not counting the ones
                        ; inside your head as you try to follow this process

 JSR P%+3               ; This line calls TT54 as a subroutine to do a twist,
                        ; and then falls through into TT54 to do another twist
                        ; before returning from the subroutine

; ******************************************************************************
;
;       Name: TT54
;       Type: Subroutine
;   Category: Universe
;    Summary: Twist the selected system's seeds
;  Deep dive: Twisting the system seeds
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; This routine twists the three 16-bit seeds in QQ15 once.
;
; If we start with seeds s0, s1 and s2 and we want to work out their new values
; after we perform a twist (let's call the new values s0, s1 and s2), then:
;
;  s0 = s1
;  s1 = s2
;  s2 = s0 + s1 + s2
;
; So given an existing set of seeds in s0, s1 and s2, we can get the new values
; s0, s1 and s2 simply by doing the above sums. And if we want to do the
; above in-place without creating three new s variables, then we can do the
; following:
;
;  tmp = s0 + s1
;  s0 = s1
;  s1 = s2
;  s2 = tmp + s1
;
; So this is what we do in this routine, where each seed is a 16-bit number.
;
; ******************************************************************************

.TT54

 LDA QQ15               ; X = tmp_lo = s0_lo + s1_lo
 CLC
 ADC QQ15+2
 TAX

 LDA QQ15+1             ; Y = tmp_hi = s1_hi + s1_hi + C
 ADC QQ15+3
 TAY

 LDA QQ15+2             ; s0_lo = s1_lo
 STA QQ15

 LDA QQ15+3             ; s0_hi = s1_hi
 STA QQ15+1

 LDA QQ15+5             ; s1_hi = s2_hi
 STA QQ15+3

 LDA QQ15+4             ; s1_lo = s2_lo
 STA QQ15+2

 CLC                    ; s2_lo = X + s1_lo
 TXA
 ADC QQ15+2
 STA QQ15+4

 TYA                    ; s2_hi = Y + s1_hi + C
 ADC QQ15+3
 STA QQ15+5

 RTS                    ; The twist is complete so return from the subroutine

; ******************************************************************************
;
;       Name: TT146
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the distance to the selected system in light years
;
; ------------------------------------------------------------------------------
;
; If it is non-zero, print the distance to the selected system in light years.
; If it is zero, just move the text cursor down a line.
;
; Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
; then a colon, then the distance to one decimal place, then token 35 ("LIGHT
; YEARS"). If the distance is zero, move the cursor down one line.
;
; ******************************************************************************

.TT146

 LDA QQ8                ; Take the two bytes of the 16-bit value in QQ8 and
 ORA QQ8+1              ; OR them together to check whether there are any
 BNE TT63               ; non-zero bits, and if so, jump to TT63 to print the
                        ; distance

 JMP INCYC              ; Move the text cursor down by one line and return from
                        ; the subroutine using a tail call

;RTS                    ; This instruction is commented out in the original
                        ; source

.TT63

 LDA #191               ; Print recursive token 31 ("DISTANCE") followed by
 JSR TT68               ; a colon

 LDX QQ8                ; Load (Y X) from QQ8, which contains the 16-bit
 LDY QQ8+1              ; distance we want to show

 SEC                    ; Set the C flag so that the call to pr5 will include a
                        ; decimal point, and display the value as (Y X) / 10

 JSR pr5                ; Print (Y X) to 5 digits, including a decimal point

 LDA #195               ; Set A to the recursive token 35 (" LIGHT YEARS") and
                        ; fall through into TT60 to print the token followed
                        ; by a paragraph break

; ******************************************************************************
;
;       Name: TT60
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token and a paragraph break
;
; ------------------------------------------------------------------------------
;
; Print a text token (i.e. a character, control code, two-letter token or
; recursive token). Then print a paragraph break (a blank line between
; paragraphs) by moving the cursor down a line, setting Sentence Case, and then
; printing a newline.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.TT60

 JSR TT27               ; Print the text token in A and fall through into TTX69
                        ; to print the paragraph break

; ******************************************************************************
;
;       Name: TTX69
;       Type: Subroutine
;   Category: Text
;    Summary: Print a paragraph break
;
; ------------------------------------------------------------------------------
;
; Print a paragraph break (a blank line between paragraphs) by moving the cursor
; down a line, setting Sentence Case, and then printing a newline.
;
; ******************************************************************************

.TTX69

 JSR INCYC              ; Move the text cursor down a line

;JSR INCYC              ; This instruction is commented out in the original
;                       ; source

                        ; Fall through into TT69 to set Sentence Case and print
                        ; a newline

; ******************************************************************************
;
;       Name: TT69
;       Type: Subroutine
;   Category: Text
;    Summary: Set Sentence Case and print a newline
;
; ******************************************************************************

.TT69

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

                        ; Fall through into TT67 to print a newline

; ******************************************************************************
;
;       Name: TT67
;       Type: Subroutine
;   Category: Text
;    Summary: Print a newline
;
; ******************************************************************************

.TT67

;INC YC                 ; This instruction is commented out in the original
                        ; source

 LDA #12                ; Load a newline character into A

 JMP TT27               ; Print the text token in A and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT70
;       Type: Subroutine
;   Category: Universe
;    Summary: Display "MAINLY " and jump to TT72
;
; ------------------------------------------------------------------------------
;
; This subroutine is called by TT25 when displaying a system's economy.
;
; ******************************************************************************

.TT70

 LDA #173               ; Print recursive token 13 ("MAINLY ")
 JSR TT27

 JMP TT72               ; Jump to TT72 to continue printing system data as part
                        ; of routine TT25

; ******************************************************************************
;
;       Name: spc
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token followed by a space
;
; ------------------------------------------------------------------------------
;
; Print a text token (i.e. a character, control code, two-letter token or
; recursive token) followed by a space.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.spc

 JSR TT27               ; Print the text token in A

 JMP TT162              ; Print a space and return from the subroutine using a
                        ; tail call

; ******************************************************************************
;
;       Name: TT25
;       Type: Subroutine
;   Category: Universe
;    Summary: Show the Data on System screen
;  Deep dive: Generating system data
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT72                Used by TT70 to re-enter the routine after displaying
;                       "MAINLY" for the economy type
;
; ******************************************************************************

.TT25

 LDA #1                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 1

 LDA #9                 ; Move the text cursor to column 9
 JSR DOXC

 LDA #163               ; Print recursive token 3 ("DATA ON {selected system
 JSR NLIN3              ; name}" and draw a horizontal line at pixel row 19
                        ; to box in the title

 JSR TTX69              ; Print a paragraph break and set Sentence Case

 JSR TT146              ; If the distance to this system is non-zero, print
                        ; "DISTANCE", then the distance, "LIGHT YEARS" and a
                        ; paragraph break, otherwise just move the cursor down
                        ; a line

 LDA #194               ; Print recursive token 34 ("ECONOMY") followed by
 JSR TT68               ; a colon

 LDA QQ3                ; The system economy is determined by the value in QQ3,
                        ; so fetch it into A. First we work out the system's
                        ; prosperity as follows:
                        ;
                        ;   QQ3 = 0 or 5 = %000 or %101 = Rich
                        ;   QQ3 = 1 or 6 = %001 or %110 = Average
                        ;   QQ3 = 2 or 7 = %010 or %111 = Poor
                        ;   QQ3 = 3 or 4 = %011 or %100 = Mainly

 CLC                    ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
 ADC #1                 ; (3 or 4), then call TT70, which prints "MAINLY " and
 LSR A                  ; jumps down to TT72 to print the type of economy
 CMP #%00000010
 BEQ TT70

 LDA QQ3                ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
 BCC TT71               ; %010 (0, 1 or 2), then jump to TT71 with A set to the
                        ; original value of QQ3

 SBC #5                 ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
 CLC                    ; 5 to bring it down to 0, 1 or 2 (the C flag is already
                        ; set so the SBC will be correct)

.TT71

 ADC #170               ; A is now 0, 1 or 2, so print recursive token 10 + A.
 JSR TT27               ; This means that:
                        ;
                        ;   QQ3 = 0 or 5 prints token 10 ("RICH ")
                        ;   QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
                        ;   QQ3 = 2 or 7 prints token 12 ("POOR ")

.TT72

 LDA QQ3                ; Now to work out the type of economy, which is
 LSR A                  ; determined by bit 2 of QQ3, as follows:
 LSR A                  ;
                        ;   QQ3 bit 2 = 0 = Industrial
                        ;   QQ3 bit 2 = 1 = Agricultural
                        ;
                        ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
                        ; two right shifts (which will work as QQ3 is only a
                        ; 3-bit number)

 CLC                    ; Print recursive token 8 + A, followed by a paragraph
 ADC #168               ; break and Sentence Case, so:
 JSR TT60               ;
                        ;   QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
                        ;   QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")

 LDA #162               ; Print recursive token 2 ("GOVERNMENT") followed by
 JSR TT68               ; a colon

 LDA QQ4                ; The system's government is determined by the value in
                        ; QQ4, so fetch it into A

 CLC                    ; Print recursive token 17 + A, followed by a paragraph
 ADC #177               ; break and Sentence Case, so:
 JSR TT60               ;
                        ;   QQ4 = 0 prints token 17 ("ANARCHY")
                        ;   QQ4 = 1 prints token 18 ("FEUDAL")
                        ;   QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
                        ;   QQ4 = 3 prints token 20 ("DICTATORSHIP")
                        ;   QQ4 = 4 prints token 21 ("COMMUNIST")
                        ;   QQ4 = 5 prints token 22 ("CONFEDERACY")
                        ;   QQ4 = 6 prints token 23 ("DEMOCRACY")
                        ;   QQ4 = 7 prints token 24 ("CORPORATE STATE")

 LDA #196               ; Print recursive token 36 ("TECH.LEVEL") followed by a
 JSR TT68               ; colon

 LDX QQ5                ; Fetch the tech level from QQ5 and increment it, as it
 INX                    ; is stored in the range 0-14 but the displayed range
                        ; should be 1-15

 CLC                    ; Call pr2 to print the technology level as a 3-digit
 JSR pr2                ; number without a decimal point (by clearing the C
                        ; flag)

 JSR TTX69              ; Print a paragraph break and set Sentence Case

 LDA #192               ; Print recursive token 32 ("POPULATION") followed by a
 JSR TT68               ; colon

 SEC                    ; Call pr2 to print the population as a 3-digit number
 LDX QQ6                ; with a decimal point (by setting the C flag), so the
 JSR pr2                ; number printed will be population / 10

 LDA #198               ; Print recursive token 38 (" BILLION"), followed by a
 JSR TT60               ; paragraph break and Sentence Case

 LDA #'('               ; Print an opening bracket
 JSR TT27

 LDA QQ15+4             ; Now to calculate the species, so first check bit 7 of
 BMI TT75               ; s2_lo, and if it is set, jump to TT75 as this is an
                        ; alien species

 LDA #188               ; Bit 7 of s2_lo is clear, so print recursive token 28
 JSR TT27               ; ("HUMAN COLONIAL")

 JMP TT76               ; Jump to TT76 to print "S)" and a paragraph break, so
                        ; the whole species string is "(HUMAN COLONIALS)"

.TT75

 LDA QQ15+5             ; This is an alien species, and we start with the first
 LSR A                  ; adjective, so fetch bits 2-7 of s2_hi into A and push
 LSR A                  ; onto the stack so we can use this later
 PHA

 AND #%00000111         ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)

 CMP #3                 ; If A >= 3, jump to TT205 to skip the first adjective,
 BCS TT205

 ADC #227               ; Otherwise A = 0, 1 or 2, so print recursive token
 JSR spc                ; 67 + A, followed by a space, so:
                        ;
                        ;   A = 0 prints token 67 ("LARGE") and a space
                        ;   A = 1 prints token 68 ("FIERCE") and a space
                        ;   A = 2 prints token 69 ("SMALL") and a space

.TT205

 PLA                    ; Now for the second adjective, so restore A to bits
 LSR A                  ; 2-7 of s2_hi, and throw away bits 2-4 to leave
 LSR A                  ; A = bits 5-7 of s2_hi
 LSR A

 CMP #6                 ; If A >= 6, jump to TT206 to skip the second adjective
 BCS TT206

 ADC #230               ; Otherwise A = 0 to 5, so print recursive token
 JSR spc                ; 70 + A, followed by a space, so:
                        ;
                        ;   A = 0 prints token 70 ("GREEN") and a space
                        ;   A = 1 prints token 71 ("RED") and a space
                        ;   A = 2 prints token 72 ("YELLOW") and a space
                        ;   A = 3 prints token 73 ("BLUE") and a space
                        ;   A = 4 prints token 74 ("BLACK") and a space
                        ;   A = 5 prints token 75 ("HARMLESS") and a space

.TT206

 LDA QQ15+3             ; Now for the third adjective, so EOR the high bytes of
 EOR QQ15+1             ; s0 and s1 and extract bits 0-2 of the result:
 AND #%00000111         ;
 STA QQ19               ;   A = (s0_hi EOR s1_hi) AND %111
                        ;
                        ; storing the result in QQ19 so we can use it later

 CMP #6                 ; If A >= 6, jump to TT207 to skip the third adjective
 BCS TT207

 ADC #236               ; Otherwise A = 0 to 5, so print recursive token
 JSR spc                ; 76 + A, followed by a space, so:
                        ;
                        ;   A = 0 prints token 76 ("SLIMY") and a space
                        ;   A = 1 prints token 77 ("BUG-EYED") and a space
                        ;   A = 2 prints token 78 ("HORNED") and a space
                        ;   A = 3 prints token 79 ("BONY") and a space
                        ;   A = 4 prints token 80 ("FAT") and a space
                        ;   A = 5 prints token 81 ("FURRY") and a space

.TT207

 LDA QQ15+5             ; Now for the actual species, so take bits 0-1 of
 AND #%00000011         ; s2_hi, add this to the value of A that we used for
 CLC                    ; the third adjective, and take bits 0-2 of the result
 ADC QQ19
 AND #%00000111

 ADC #242               ; A = 0 to 7, so print recursive token 82 + A, so:
 JSR TT27               ;
                        ;   A = 0 prints token 82 ("RODENT")
                        ;   A = 1 prints token 83 ("FROG")
                        ;   A = 2 prints token 84 ("LIZARD")
                        ;   A = 3 prints token 85 ("LOBSTER")
                        ;   A = 4 prints token 86 ("BIRD")
                        ;   A = 5 prints token 87 ("HUMANOID")
                        ;   A = 6 prints token 88 ("FELINE")
                        ;   A = 7 prints token 89 ("INSECT")

.TT76

 LDA #'S'               ; Print an "S" to pluralise the species
 JSR TT27

 LDA #')'               ; And finally, print a closing bracket, followed by a
 JSR TT60               ; paragraph break and Sentence Case, to end the species
                        ; section

 LDA #193               ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
 JSR TT68               ; followed by a colon

 LDX QQ7                ; Fetch the 16-bit productivity value from QQ7 into
 LDY QQ7+1              ; (Y X)

 JSR pr6                ; Print (Y X) to 5 digits with no decimal point

 JSR TT162              ; Print a space

 LDA #0                 ; Set QQ17 = 0 to switch to ALL CAPS
 STA QQ17

 LDA #'M'               ; Print "M"
 JSR TT27

 LDA #226               ; Print recursive token 66 (" CR"), followed by a
 JSR TT60               ; paragraph break and Sentence Case

 LDA #250               ; Print recursive token 90 ("AVERAGE RADIUS"), followed
 JSR TT68               ; by a colon

                        ; The average radius is calculated like this:
                        ;
                        ;   ((s2_hi AND %1111) + 11) * 256 + s1_hi
                        ;
                        ; or, in terms of memory locations:
                        ;
                        ;   ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
                        ;
                        ; Because the multiplication is by 256, this is the
                        ; same as saying a 16-bit number, with high byte:
                        ;
                        ;   (QQ15+5 AND %1111) + 11
                        ;
                        ; and low byte:
                        ;
                        ;   QQ15+3
                        ;
                        ; so we can set this up in (Y X) and call the pr5
                        ; routine to print it out

 LDA QQ15+5             ; Set A = QQ15+5
 LDX QQ15+3             ; Set X = QQ15+3

 AND #%00001111         ; Set Y = (A AND %1111) + 11
 CLC
 ADC #11
 TAY

 JSR pr5                ; Print (Y X) to 5 digits, not including a decimal
                        ; point, as the C flag will be clear (as the maximum
                        ; radius will always fit into 16 bits)

 JSR TT162              ; Print a space

 LDA #'k'               ; Print "km"
 JSR TT26
 LDA #'m'
 JSR TT26

 JSR TTX69              ; Print a paragraph break and set Sentence Case

                        ; By this point, ZZ contains the current system number
                        ; which PDESC requires. It gets put there in the TT102
                        ; routine, which calls TT111 to populate ZZ before
                        ; calling TT25 (this routine)

 JMP PDESC              ; Jump to PDESC to print the system's extended
                        ; description, returning from the subroutine using a
                        ; tail call

 RTS                    ; Return from the subroutine (though this instruction
                        ; has no effect as we already returned using a tail
                        ; call)

; ******************************************************************************
;
;       Name: TT24
;       Type: Subroutine
;   Category: Universe
;    Summary: Calculate system data from the system seeds
;  Deep dive: Generating system data
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Calculate system data from the seeds in QQ15 and store them in the relevant
; locations. Specifically, this routine calculates the following from the three
; 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
;
;   QQ3 = economy (0-7)
;   QQ4 = government (0-7)
;   QQ5 = technology level (0-14)
;   QQ6 = population * 10 (1-71)
;   QQ7 = productivity (96-62480)
;
; The ranges of the various values are shown in brackets. Note that the radius
; and type of inhabitant are calculated on-the-fly in the TT25 routine when
; the system data gets displayed, so they aren't calculated here.
;
; ******************************************************************************

.TT24

 LDA QQ15+1             ; Fetch s0_hi and extract bits 0-2 to determine the
 AND #%00000111         ; system's economy, and store in QQ3
 STA QQ3

 LDA QQ15+2             ; Fetch s1_lo and extract bits 3-5 to determine the
 LSR A                  ; system's government, and store in QQ4
 LSR A
 LSR A
 AND #%00000111
 STA QQ4

 LSR A                  ; If government isn't anarchy or feudal, skip to TT77,
 BNE TT77               ; as we need to fix the economy of anarchy and feudal
                        ; systems so they can't be rich

 LDA QQ3                ; Set bit 1 of the economy in QQ3 to fix the economy
 ORA #%00000010         ; for anarchy and feudal governments
 STA QQ3

.TT77

 LDA QQ3                ; Now to work out the tech level, which we do like this:
 EOR #%00000111         ;
 CLC                    ;   flipped_economy + (s1_hi AND %11) + (government / 2)
 STA QQ5                ;
                        ; or, in terms of memory locations:
                        ;
                        ;   QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
                        ;
                        ; We start by setting QQ5 = QQ3 EOR %111

 LDA QQ15+3             ; We then take the first 2 bits of s1_hi (QQ15+3) and
 AND #%00000011         ; add it into QQ5
 ADC QQ5
 STA QQ5

 LDA QQ4                ; And finally we add QQ4 / 2 and store the result in
 LSR A                  ; QQ5, using LSR then ADC to divide by 2, which rounds
 ADC QQ5                ; up the result for odd-numbered government types
 STA QQ5

 ASL A                  ; Now to work out the population, like so:
 ASL A                  ;
 ADC QQ3                ;   (tech level * 4) + economy + government + 1
 ADC QQ4                ;
 ADC #1                 ; or, in terms of memory locations:
 STA QQ6                ;
                        ;   QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1

 LDA QQ3                ; Finally, we work out productivity, like this:
 EOR #%00000111         ;
 ADC #3                 ;  (flipped_economy + 3) * (government + 4)
 STA P                  ;                        * population
 LDA QQ4                ;                        * 8
 ADC #4                 ;
 STA Q                  ; or, in terms of memory locations:
 JSR MULTU              ;
                        ;   QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
                        ;
                        ; We do the first step by setting P to the first
                        ; expression in brackets and Q to the second, and
                        ; calling MULTU, so now (A P) = P * Q. The highest this
                        ; can be is 10 * 11 (as the maximum values of economy
                        ; and government are 7), so the high byte of the result
                        ; will always be 0, so we actually have:
                        ;
                        ;   P = P * Q
                        ;     = (flipped_economy + 3) * (government + 4)

 LDA QQ6                ; We now take the result in P and multiply by the
 STA Q                  ; population to get the productivity, by setting Q to
 JSR MULTU              ; the population from QQ6 and calling MULTU again, so
                        ; now we have:
                        ;
                        ;   (A P) = P * population

 ASL P                  ; Next we multiply the result by 8, as a 16-bit number,
 ROL A                  ; so we shift both bytes to the left three times, using
 ASL P                  ; the C flag to carry bits from bit 7 of the low byte
 ROL A                  ; into bit 0 of the high byte
 ASL P
 ROL A

 STA QQ7+1              ; Finally, we store the productivity in two bytes, with
 LDA P                  ; the low byte in QQ7 and the high byte in QQ7+1
 STA QQ7

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT22
;       Type: Subroutine
;   Category: Charts
;    Summary: Show the Long-range Chart
;
; ******************************************************************************

.TT22

 LDA #64                ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 32 (Long-
                        ; range Chart)

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to white)

 LDA #16                ; Switch to the mode 1 palette for the trade view, which
 JSR DOVDU19            ; is yellow (colour 1), magenta (colour 2) and white
                        ; (colour 3)

 LDA #7                 ; Move the text cursor to column 7
 JSR DOXC

 JSR TT81               ; Set the seeds in QQ15 to those of system 0 in the
                        ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #199               ; Print recursive token 39 ("GALACTIC CHART{galaxy
 JSR TT27               ; number right-aligned to width 3}")

 JSR NLIN               ; Draw a horizontal line at pixel row 23 to box in the
                        ; title and act as the top frame of the chart, and move
                        ; the text cursor down one line

 LDA #152               ; Draw a screen-wide horizontal line at pixel row 152
 JSR NLIN2              ; for the bottom edge of the chart, so the chart itself
                        ; is 128 pixels high, starting on row 24 and ending on
                        ; row 151

 JSR TT14               ; Call TT14 to draw a circle with crosshairs at the
                        ; current system's galactic coordinates

 LDX #0                 ; We're now going to plot each of the galaxy's systems,
                        ; so set up a counter in X for each system, starting at
                        ; 0 and looping through to 255

.TT83

 STX XSAV               ; Store the counter in XSAV

 LDX QQ15+3             ; Fetch the s1_hi seed into X, which gives us the
                        ; galactic x-coordinate of this system

 LDY QQ15+4             ; Fetch the s2_lo seed and set bits 4 and 6, storing the
 TYA                    ; result in ZZ to give a random number between 80 and
 ORA #%01010000         ; (but which will always be the same for this system).
 STA ZZ                 ; We use this value to determine the size of the point
                        ; for this system on the chart by passing it as the
                        ; distance argument to the PIXEL routine below

 LDA QQ15+1             ; Fetch the s0_hi seed into A, which gives us the
                        ; galactic y-coordinate of this system

 LSR A                  ; We halve the y-coordinate because the galaxy in
                        ; in Elite is rectangular rather than square, and is
                        ; twice as wide (x-axis) as it is high (y-axis), so the
                        ; chart is 256 pixels wide and 128 high

 CLC                    ; Add 24 to the halved y-coordinate and store in XX15+1
 ADC #24                ; (as the top of the chart is on pixel row 24, just
 STA XX15+1             ; below the line we drew on row 23 above)

 JSR PIXEL              ; Call PIXEL to draw a point at (X, A), with the size of
                        ; the point dependent on the distance specified in ZZ
                        ; (so a high value of ZZ will produce a 1-pixel point,
                        ; a medium value will produce a 2-pixel dash, and a
                        ; small value will produce a 4-pixel square)

 JSR TT20               ; We want to move on to the next system, so call TT20
                        ; to twist the three 16-bit seeds in QQ15

 LDX XSAV               ; Restore the loop counter from XSAV

 INX                    ; Increment the counter

 BNE TT83               ; If X > 0 then we haven't done all 256 systems yet, so
                        ; loop back up to TT83

;JSR PBFL               ; This instruction is commented out in the original
;                       ; source (it would call PBFL to send the contents of the
;                       ; pixel buffer to the I/O processor for plotting
;                       ; on-screen

 LDA QQ9                ; Set QQ19 to the selected system's x-coordinate
 STA QQ19

 LDA QQ10               ; Set QQ19+1 to the selected system's y-coordinate,
 LSR A                  ; halved to fit it into the chart
 STA QQ19+1

 LDA #4                 ; Set QQ19+2 to size 4 for the crosshairs size
 STA QQ19+2

                        ; Fall through into TT15 to draw crosshairs of size 4 at
                        ; the selected system's coordinates

; ******************************************************************************
;
;       Name: TT15
;       Type: Subroutine
;   Category: Drawing lines
;    Summary: Draw a set of crosshairs
;
; ------------------------------------------------------------------------------
;
; For all views except the Short-range Chart, the centre is drawn 24 pixels to
; the right of the y-coordinate given.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ19                The pixel x-coordinate of the centre of the crosshairs
;
;   QQ19+1              The pixel y-coordinate of the centre of the crosshairs
;
;   QQ19+2              The size of the crosshairs
;
; ******************************************************************************

.TT15

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to white)

.TT15b

 LDA #24                ; Set A to 24, which we will use as the minimum
                        ; screen indent for the crosshairs (i.e. the minimum
                        ; distance from the top-left corner of the screen)

 LDX QQ11               ; If the current view is not the Short-range Chart,
 BPL TT178              ; which is the only view with bit 7 set, then jump to
                        ; TT178 to skip the following instruction

 LDA #0                 ; This is the Short-range Chart, so set A to 0, so the
                        ; crosshairs can go right up against the screen edges

.TT178

 STA QQ19+5             ; Set QQ19+5 to A, which now contains the correct indent
                        ; for this view

 LDA QQ19               ; Set A = crosshairs x-coordinate - crosshairs size
 SEC                    ; to get the x-coordinate of the left edge of the
 SBC QQ19+2             ; crosshairs

 BCS TT84               ; If the above subtraction didn't underflow, then A is
                        ; positive, so skip the next instruction

 LDA #0                 ; The subtraction underflowed, so set A to 0 so the
                        ; crosshairs don't spill out of the left of the screen

.TT84

                        ; In the following, the authors have used XX15 for
                        ; temporary storage. XX15 shares location with X1, Y1,
                        ; X2 and Y2, so in the following, you can consider
                        ; the variables like this:
                        ;
                        ;   XX15   is the same as X1
                        ;   XX15+1 is the same as Y1
                        ;   XX15+2 is the same as X2
                        ;   XX15+3 is the same as Y2
                        ;
                        ; Presumably this routine was written at a different
                        ; time to the line-drawing routine, before the two
                        ; workspaces were merged to save space

 STA XX15               ; Set XX15 (X1) = A (the x-coordinate of the left edge
                        ; of the crosshairs)

 LDA QQ19               ; Set A = crosshairs x-coordinate + crosshairs size
 CLC                    ; to get the x-coordinate of the right edge of the
 ADC QQ19+2             ; crosshairs

 BCC TT85               ; If the above addition didn't overflow, then A is
                        ; correct, so jump to TT85 to skip the next instruction

 LDA #255               ; The addition overflowed, so set A to 255 so the
                        ; crosshairs don't spill out of the right of the screen
                        ; (as 255 is the x-coordinate of the rightmost pixel
                        ; on-screen)

.TT85

 STA XX15+2             ; Set XX15+2 (X2) = A (the x-coordinate of the right
                        ; edge of the crosshairs)

 LDA QQ19+1             ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
 CLC                    ; to get the y-coordinate of the centre of the
 ADC QQ19+5             ; crosshairs
 STA XX15+1

 STA XX15+3             ; Set XX15+3 (Y2) = crosshairs y-coordinate + indent

 JSR LL30               ; Draw a line from (X1, Y1) to (X2, Y2), where Y1 = Y2,
                        ; which will draw from the left edge of the crosshairs
                        ; to the right edge, through the centre of the
                        ; crosshairs

 LDA QQ19+1             ; Set A = crosshairs y-coordinate - crosshairs size
 SEC                    ; to get the y-coordinate of the top edge of the
 SBC QQ19+2             ; crosshairs

 BCS TT86               ; If the above subtraction didn't underflow, then A is
                        ; correct, so skip the next instruction

 LDA #0                 ; The subtraction underflowed, so set A to 0 so the
                        ; crosshairs don't spill out of the top of the screen

.TT86

 CLC                    ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
 ADC QQ19+5             ; of the top edge of the indented crosshairs
 STA XX15+1

 LDA QQ19+1             ; Set A = crosshairs y-coordinate + crosshairs size
 CLC                    ; + indent to get the y-coordinate of the bottom edge
 ADC QQ19+2             ; of the indented crosshairs
 ADC QQ19+5

 CMP #152               ; If A < 152 then skip the following, as the crosshairs
 BCC TT87               ; won't spill out of the bottom of the screen

 LDX QQ11               ; A >= 152, so we need to check whether this will fit in
                        ; this view, so fetch the view type

 BMI TT87               ; If this is the Short-range Chart then the y-coordinate
                        ; is fine, so skip to TT87

 LDA #151               ; Otherwise this is the Long-range Chart, so we need to
                        ; clip the crosshairs at a maximum y-coordinate of 151

.TT87

 STA XX15+3             ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
                        ; edge of the crosshairs)

 LDA QQ19               ; Set XX15 (X1) = the x-coordinate of the centre of the
 STA XX15               ; crosshairs

 STA XX15+2             ; Set XX15+2 (X2) = the x-coordinate of the centre of
                        ; the crosshairs

 JMP LL30               ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
                        ; draw from the top edge of the crosshairs to the bottom
                        ; edge, through the centre of the crosshairs, returning
                        ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT14
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw a circle with crosshairs on a chart
;
; ------------------------------------------------------------------------------
;
; Draw a circle with crosshairs at the current system's galactic coordinates.
;
; ******************************************************************************

.TT126

 LDA #104               ; Set QQ19 = 104, for the x-coordinate of the centre of
 STA QQ19               ; the fixed circle on the Short-range Chart

 LDA #90                ; Set QQ19+1 = 90, for the y-coordinate of the centre of
 STA QQ19+1             ; the fixed circle on the Short-range Chart

 LDA #16                ; Set QQ19+2 = 16, the size of the crosshairs on the
 STA QQ19+2             ; Short-range Chart

 JSR TT15               ; Draw the set of crosshairs defined in QQ19, at the
                        ; exact coordinates as this is the Short-range Chart

 LDA QQ14               ; Set K to the fuel level from QQ14, so this can act as
 STA K                  ; the circle's radius (70 being a full tank)

 JMP TT128              ; Jump to TT128 to draw a circle with the centre at the
                        ; same coordinates as the crosshairs, (QQ19, QQ19+1),
                        ; and radius K that reflects the current fuel levels,
                        ; returning from the subroutine using a tail call

.TT14

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to white)

 LDA QQ11               ; If the current view is the Short-range Chart, which
 BMI TT126              ; is the only view with bit 7 set, then jump up to TT126
                        ; to draw the crosshairs and circle for that view

                        ; Otherwise this is the Long-range Chart, so we draw the
                        ; crosshairs and circle for that view instead

 LDA QQ14               ; Set K to the fuel level from QQ14 divided by 4, so
 LSR A                  ; this can act as the circle's radius (70 being a full
 LSR A                  ; tank, which divides down to a radius of 17)
 STA K

 LDA QQ0                ; Set QQ19 to the x-coordinate of the current system,
 STA QQ19               ; which will be the centre of the circle and crosshairs
                        ; we draw

 LDA QQ1                ; Set QQ19+1 to the y-coordinate of the current system,
 LSR A                  ; halved because the galactic chart is half as high as
 STA QQ19+1             ; it is wide, which will again be the centre of the
                        ; circle and crosshairs we draw

 LDA #7                 ; Set QQ19+2 = 7, the size of the crosshairs on the
 STA QQ19+2             ; Long-range Chart

 JSR TT15               ; Draw the set of crosshairs defined in QQ19, which will
                        ; be drawn 24 pixels to the right of QQ19+1

 LDA QQ19+1             ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
 CLC                    ; so that the centre of the circle matches the centre
 ADC #24                ; of the crosshairs
 STA QQ19+1

                        ; Fall through into TT128 to draw a circle with the
                        ; centre at the same coordinates as the crosshairs,
                        ; (QQ19, QQ19+1), and radius K that reflects the
                        ; current fuel levels

; ******************************************************************************
;
;       Name: TT128
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw a circle on a chart
;  Deep dive: Drawing circles
;
; ------------------------------------------------------------------------------
;
; Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ19                The x-coordinate of the centre of the circle
;
;   QQ19+1              The y-coordinate of the centre of the circle
;
;   K                   The radius of the circle
;
; ******************************************************************************

.TT128

 LDA QQ19               ; Set K3 = the x-coordinate of the centre
 STA K3

 LDA QQ19+1             ; Set K4 = the y-coordinate of the centre
 STA K4

 LDX #0                 ; Set the high bytes of K3(1 0) and K4(1 0) to 0
 STX K4+1
 STX K3+1

;STX LSX                ; This instruction is commented out in the original
                        ; source

 INX                    ; Set LSP = 1 to reset the ball line heap
 STX LSP

 LDX #2                 ; Set STP = 2, the step size for the circle
 STX STP

;LDA #RED               ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to red)

 JMP CIRCLE2            ; Jump to CIRCLE2 to draw a circle with the centre at
                        ; (K3(1 0), K4(1 0)) and radius K, returning from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT219
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Buy Cargo screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   BAY2                Jump into the main loop at FRCE, setting the key
;                       "pressed" to the Inventory key
;
; ******************************************************************************

.TT219

 LDA #2                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 2 (Buy Cargo screen)

 JSR TT163              ; Print the column headers for the prices table

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               ; next letter in capitals

 LDA #0                 ; We're going to loop through all the available market
 STA QQ29               ; items, so we set up a counter in QQ29 to denote the
                        ; current item and start it at 0

.TT220

 JSR TT151              ; Call TT151 to print the item name, market price and
                        ; availability of the current item, and set QQ24 to the
                        ; item's price / 4, QQ25 to the quantity available and
                        ; QQ19+1 to byte #1 from the market prices table for
                        ; this item

 LDA QQ25               ; If there are some of the current item available, jump
 BNE TT224              ; to TT224 below to see if we want to buy any

 JMP TT222              ; Otherwise there are none available, so jump down to
                        ; TT222 to skip this item

.TQ4

 LDY #176               ; Set Y to the recursive token 16 ("QUANTITY")

.Tc

 JSR TT162              ; Print a space

 TYA                    ; Print the recursive token in Y followed by a question
 JSR prq                ; mark

.TTX224

 JSR dn2                ; Call dn2 to make a short, high beep and delay for 1
                        ; second

.TT224

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #204               ; Print recursive token 44 ("QUANTITY OF ")
 JSR TT27

 LDA QQ29               ; Print recursive token 48 + QQ29, which will be in the
 CLC                    ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               ; prints the current item's name
 JSR TT27

 LDA #'/'               ; Print "/"
 JSR TT27

 JSR TT152              ; Print the unit ("t", "kg" or "g") for the current item
                        ; (as the call to TT151 above set QQ19+1 with the
                        ; appropriate value)

 LDA #'?'               ; Print "?"
 JSR TT27

 JSR TT67               ; Print a newline

 LDX #0                 ; These instructions have no effect, as they are
 STX R                  ; repeated at the start of gnum, which we call next.
 LDX #12                ; Perhaps they were left behind when code was moved from
 STX T1                 ; here into gnum, and weren't deleted?

{
.TT223                  ; This label is a duplicate of a label in gnum (which is
                        ; why we need to surround it with braces, as BeebAsm
                        ; doesn't allow us to redefine labels, unlike BBC
                        ; BASIC). This could be a remnant if the code in gnum
                        ; was originally here, but got moved into the gnum
                        ; subroutine without removing the original

}

 JSR gnum               ; Call gnum to get a number from the keyboard, which
                        ; will be the quantity of this item we want to purchase,
                        ; returning the number entered in A and R

 BCS TQ4                ; If gnum set the C flag, the number entered is greater
                        ; than the quantity available, so jump up to TQ4 to
                        ; display a "Quantity?" error, beep, clear the number
                        ; and try again

 STA P                  ; Otherwise we have a valid purchase quantity entered,
                        ; so store the amount we want to purchase in P

 JSR tnpr               ; Call tnpr to work out whether there is room in the
                        ; cargo hold for this item

 LDY #206               ; Set Y to recursive token 46 (" CARGO{sentence case}")
                        ; to pass to the Tc routine if we call it

 LDA R                  ; If R = 0, then we didn't enter a number above, so skip
 BEQ P%+4               ; the following instruction

 BCS Tc                 ; If the C flag is set, then there is no room in the
                        ; cargo hold, jump up to Tc to print a "Cargo?" error,
                        ; beep, clear the number and try again

 LDA QQ24               ; There is room in the cargo hold, so now to check
 STA Q                  ; whether we have enough cash, so fetch the item's
                        ; price / 4, which was returned in QQ24 by the call
                        ; to TT151 above and store it in Q

 JSR GCASH              ; Call GCASH to calculate:
                        ;
                        ;   (Y X) = P * Q * 4
                        ;
                        ; which will be the total price of this transaction
                        ; (as P contains the purchase quantity and Q contains
                        ; the item's price / 4)

 JSR LCASH              ; Subtract (Y X) cash from the cash pot in CASH

 LDY #197               ; If the C flag is clear, we didn't have enough cash,
 BCC Tc                 ; so set Y to the recursive token 37 ("CASH") and jump
                        ; up to Tc to print a "Cash?" error, beep, clear the
                        ; number and try again

 LDY QQ29               ; Fetch the current market item number from QQ29 into Y

 LDA R                  ; Set A to the number of items we just purchased (this
                        ; was set by gnum above)

 PHA                    ; Store the quantity just purchased on the stack

 CLC                    ; Add the number purchased to the Y-th byte of QQ20,
 ADC QQ20,Y             ; which contains the number of items of this type in
 STA QQ20,Y             ; our hold (so this transfers the bought items into our
                        ; cargo hold)

 LDA AVL,Y              ; Subtract the number of items from the Y-th byte of
 SEC                    ; AVL, which contains the number of items of this type
 SBC R                  ; that are available on the market
 STA AVL,Y

 PLA                    ; Restore the quantity just purchased

 BEQ TT222              ; If we didn't buy anything, jump to TT222 to skip the
                        ; following instruction

 JSR dn                 ; Call dn to print the amount of cash left in the cash
                        ; pot, then make a short, high beep to confirm the
                        ; purchase, and delay for 1 second

.TT222

 LDA QQ29               ; Move the text cursor to row QQ29 + 5 (where QQ29 is
 CLC                    ; the item number, starting from 0)
 ADC #5
 JSR DOYC

 LDA #0                 ; Move the text cursor to column 0
 JSR DOXC

 INC QQ29               ; Increment QQ29 to point to the next item

 LDA QQ29               ; If QQ29 >= 17 then jump to BAY2 as we have done the
 CMP #17                ; last item
 BCS BAY2

 JMP TT220              ; Otherwise loop back to TT220 to print the next market
                        ; item

.BAY2

 LDA #$10               ; ???
 STA COL2

 LDA #f9                ; Jump into the main loop at FRCE, setting the key
 JMP FRCE               ; "pressed" to red key f9 (so we show the Inventory
                        ; screen)

; ******************************************************************************
;
;       Name: gnum
;       Type: Subroutine
;   Category: Market
;    Summary: Get a number from the keyboard
;
; ------------------------------------------------------------------------------
;
; Get a number from the keyboard, up to the maximum number in QQ25, for the
; buying and selling of cargo and equipment.
;
; Pressing "Y" will return the maximum number (i.e. buy/sell all items), while
; pressing "N" will abort the sale and return a 0.
;
; Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
; that includes pressing Space or Return), while pressing a key with an ASCII
; code greater than ASCII "9" will jump to the Inventory screen (so that
; includes all letters and most punctuation).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ25                The maximum number allowed
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   The number entered
;
;   R                   Also contains the number entered
;
;   C flag              Set if the number is too large (> QQ25), clear otherwise
;
; ******************************************************************************

.gnum

 LDA #MAG2              ; Switch to ???
 STA COL2

 LDX #0                 ; We will build the number entered in R, so initialise
 STX R                  ; it with 0

 LDX #12                ; We will check for up to 12 key presses, so set a
 STX T1                 ; counter in T1

.TT223

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A (and X)

 LDX R                  ; If R is non-zero then skip to NWDAV2, as we are
 BNE NWDAV2             ; already building a number

 CMP #'Y'               ; If "Y" was pressed, jump to NWDAV1 to return the
 BEQ NWDAV1             ; maximum number allowed (i.e. buy/sell the whole stock)

 CMP #'N'               ; If "N" was pressed, jump to NWDAV3 to return from the
 BEQ NWDAV3             ; subroutine with a result of 0 (i.e. abort transaction)

.NWDAV2

 STA Q                  ; Store the key pressed in Q

 SEC                    ; Subtract ASCII "0" from the key pressed, to leave the
 SBC #'0'               ; numeric value of the key in A (if it was a number key)

 BCC OUT                ; If A < 0, jump to OUT to load the current number and
                        ; return from the subroutine, as the key pressed was
                        ; RETURN (or some other ncharacter with a value less
                        ; than ASCII "0")

 CMP #10                ; If A >= 10, jump to BAY2 to display the Inventory
 BCS BAY2               ; screen, as the key pressed was a letter or other
                        ; non-digit and is greater than ASCII "9"

 STA S                  ; Store the numeric value of the key pressed in S

 LDA R                  ; Fetch the result so far into A

 CMP #26                ; If A >= 26, where A is the number entered so far, then
 BCS OUT                ; adding a further digit will make it bigger than 256,
                        ; so jump to OUT to return from the subroutine with the
                        ; result in R (i.e. ignore the last key press)

 ASL A                  ; Set A = (A * 2) + (A * 8) = A * 10
 STA T
 ASL A
 ASL A
 ADC T

 ADC S                  ; Add the pressed digit to A and store in R, so R now
 STA R                  ; contains its previous value with the new key press
                        ; tacked onto the end

 CMP QQ25               ; If the result in R = the maximum allowed in QQ25, jump
 BEQ TT226              ; to TT226 to print the key press and keep looping (the
                        ; BEQ is needed because the BCS below would jump to OUT
                        ; if R >= QQ25, which we don't want)

 BCS OUT                ; If the result in R > QQ25, jump to OUT to return from
                        ; the subroutine with the result in R

.TT226

 LDA Q                  ; Print the character in Q (i.e. the key that was
 JSR TT26               ; pressed, as we stored the ASCII value in Q earlier)

 DEC T1                 ; Decrement the loop counter

 BNE TT223              ; Loop back to TT223 until we have checked for 12 digits

.OUT

 LDA #$10               ; Switch to ???
 STA COL2

 LDA R                  ; Set A to the result we have been building in R

 RTS                    ; Return from the subroutine

.NWDAV1

                        ; If we get here then "Y" was pressed, so we return the
                        ; maximum number allowed, which is in QQ25

 JSR TT26               ; Print the character for the key that was pressed

 LDA QQ25               ; Set R = QQ25, so we return the maximum value allowed
 STA R

 JMP OUT                ; Jump to OUT to return from the subroutine

.NWDAV3

                        ; If we get here then "N" was pressed, so we return 0

 JSR TT26               ; Print the character for the key that was pressed

 LDA #0                 ; Set R = 0, so we return 0
 STA R

 JMP OUT                ; Jump to OUT to return from the subroutine

; ******************************************************************************
;
;       Name: NWDAV4
;       Type: Subroutine
;   Category: Market
;    Summary: Print an "ITEM?" error, make a beep and rejoin the TT210 routine
;
; ******************************************************************************

.NWDAV4

 JSR TT67               ; Print a newline

 LDA #176               ; Print recursive token 127 ("ITEM") followed by a
 JSR prq                ; question mark

 JSR dn2                ; Call dn2 to make a short, high beep and delay for 1
                        ; second

 LDY QQ29               ; Fetch the item number we are selling from QQ29

 JMP NWDAVxx            ; Jump back into the TT210 routine that called NWDAV4

; ******************************************************************************
;
;       Name: TT208
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Sell Cargo screen
;
; ******************************************************************************

.TT208

 LDA #4                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 4 (Sell Cargo screen)

 LDA #10                ; Move the text cursor to column 10
 JSR DOXC

 LDA #205               ; Print recursive token 45 ("SELL")
 JSR TT27

 LDA #206               ; Print recursive token 46 (" CARGO{sentence case}")
 JSR NLIN3              ; draw a horizontal line at pixel row 19 to box in the
                        ; title

 JSR TT67               ; Print a newline

                        ; Fall through into TT210 to show the Inventory screen
                        ; with the option to sell

; ******************************************************************************
;
;       Name: TT210
;       Type: Subroutine
;   Category: Market
;    Summary: Show a list of current cargo in our hold, optionally to sell
;
; ------------------------------------------------------------------------------
;
; Show a list of current cargo in our hold, either with the ability to sell (the
; Sell Cargo screen) or without (the Inventory screen), depending on the current
; view.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ11                The current view:
;
;                           * 4 = Sell Cargo
;
;                           * 8 = Inventory
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   NWDAVxx             Used to rejoin this routine from the call to NWDAV4
;
; ******************************************************************************

.TT210

 LDY #0                 ; We're going to loop through all the available market
                        ; items and check whether we have any in the hold (and,
                        ; if we are in the Sell Cargo screen, whether we want
                        ; to sell any items), so we set up a counter in Y to
                        ; denote the current item and start it at 0

.TT211

 STY QQ29               ; Store the current item number in QQ29

.NWDAVxx

 LDX QQ20,Y             ; Fetch into X the amount of the current item that we
 BEQ TT212              ; have in our cargo hold, which is stored in QQ20+Y,
                        ; and if there are no items of this type in the hold,
                        ; jump down to TT212 to skip to the next item

 TYA                    ; Set Y = Y * 4, so this will act as an index into the
 ASL A                  ; market prices table at QQ23 for this item (as there
 ASL A                  ; are four bytes per item in the table)
 TAY

 LDA QQ23+1,Y           ; Fetch byte #1 from the market prices table for the
 STA QQ19+1             ; current item and store it in QQ19+1, for use by the
                        ; call to TT152 below

 TXA                    ; Store the amount of item in the hold (in X) on the
 PHA                    ; stack

 JSR TT69               ; Call TT69 to set Sentence Case and print a newline

 CLC                    ; Print recursive token 48 + QQ29, which will be in the
 LDA QQ29               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               ; prints the current item's name
 JSR TT27

 LDA #14                ; Move the text cursor to column 14, for the item's
 JSR DOXC               ; quantity

 PLA                    ; Restore the amount of item in the hold into X
 TAX

 STA QQ25               ; Store the amount of this item in the hold in QQ25

 CLC                    ; Print the 8-bit number in X to 3 digits, without a
 JSR pr2                ; decimal point

 JSR TT152              ; Print the unit ("t", "kg" or "g") for the market item
                        ; whose byte #1 from the market prices table is in
                        ; QQ19+1 (which we set up above)

 LDA QQ11               ; If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 ; screen), jump to TT212 to skip the option to sell
 BNE TT212              ; items

;JSR TT162              ; This instruction is commented out in the original
                        ; source

 LDA #205               ; Print recursive token 45 ("SELL")
 JSR TT27

 LDA #206               ; Print extended token 206 ("{all caps}(Y/N)?")
 JSR DETOK

 JSR gnum               ; Call gnum to get a number from the keyboard, which
                        ; will be the number of the item we want to sell,
                        ; returning the number entered in A and R, and setting
                        ; the C flag if the number is bigger than the available
                        ; amount of this item in QQ25

 BEQ TT212              ; If no number was entered, jump to TT212 to move on to
                        ; the next item

 BCS NWDAV4             ; If the number entered was too big, jump to NWDAV4 to
                        ; print an "ITEM?" error, make a beep and rejoin the
                        ; routine at NWDAVxx above

 LDA QQ29               ; We are selling this item, so fetch the item number
                        ; from QQ29

 LDX #255               ; Set QQ17 = 255 to disable printing
 STX QQ17

 JSR TT151              ; Call TT151 to set QQ24 to the item's price / 4 (the
                        ; routine doesn't print the item details, as we just
                        ; disabled printing)

 LDY QQ29               ; Subtract R (the number of items we just asked to buy)
 LDA QQ20,Y             ; from the available amount of this item in QQ20, as we
 SEC                    ; just bought them
 SBC R
 STA QQ20,Y

 LDA R                  ; Set P to the amount of this item we just bought
 STA P

 LDA QQ24               ; Set Q to the item's price / 4
 STA Q

 JSR GCASH              ; Call GCASH to calculate
                        ;
                        ;   (Y X) = P * Q * 4
                        ;
                        ; which will be the total price we make from this sale
                        ; (as P contains the quantity we're selling and Q
                        ; contains the item's price / 4)

 JSR MCASH              ; Add (Y X) cash to the cash pot in CASH

 LDA #0                 ; We've made the sale, so set the amount

 STA QQ17               ; Set QQ17 = 0, which enables printing again

.TT212

 LDY QQ29               ; Fetch the item number from QQ29 into Y, and increment
 INY                    ; Y to point to the next item

 CPY #17                ; Loop back to TT211 to print the next item in the hold
 BCC TT211              ; until Y = 17 (at which point we have done the last
                        ; item)

 LDA QQ11               ; If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 ; screen), skip the next two instructions and move on to
 BNE P%+8               ; printing the number of Trumbles

 JSR dn2                ; This is the Sell Cargo screen, so call dn2 to make a
                        ; short, high beep and delay for 1 second

 JMP BAY2               ; And then jump to BAY2 to display the Inventory
                        ; screen, as we have finished selling cargo

 JSR TT69               ; Call TT69 to set Sentence Case and print a newline

 LDA TRIBBLE            ; If there are any Trumbles in the hold, skip the
 ORA TRIBBLE+1          ; following RTS and continue on (in the Master version,
 BNE P%+3               ; there are never any Trumbles, so this value will
                        ; always be zero)

.zebra

 RTS                    ; There are no Trumbles in the hold, so return from the
                        ; subroutine

                        ; If we get here then we have Trumbles in the hold, so
                        ; we print out the number (though we never get here in
                        ; the Master version)

 CLC                    ; Clear the C flag, so the call to TT11 below doesn't
                        ; include a decimal point

 LDA #0                 ; Set A = 0, for the call to TT11 below, so we don't pad
                        ; out the number of Trumbles

 LDX TRIBBLE            ; Fetch the number of Trumbles into (Y X)
 LDY TRIBBLE+1

 JSR TT11               ; Call TT11 to print the number of Trumbles in (Y X),
                        ; with no decimal point

 JSR DORND              ; Print out a random extended token from 111 to 114, all
 AND #3                 ; of which are blank in this version of Elite
 CLC
 ADC #111
 JSR DETOK

 LDA #198               ; Print extended token 198, which is blank, but would
 JSR DETOK              ; contain the text "LITTLE TRUMBLE" if the Trumbles
                        ; mission was enabled

 LDA TRIBBLE+1          ; If we have more than 256 Trumbles, skip to DOANS
 BNE DOANS

 LDX TRIBBLE            ; If we have exactly one Trumble, return from the
 DEX                    ; subroutine (as zebra contains an RTS)
 BEQ zebra

.DOANS

 LDA #'s'               ; We have more than one Trumble, so print an 's' and
 JMP DASC               ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT213
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Inventory screen
;
; ******************************************************************************

.TT213

 LDA #8                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 4 (Inventory screen)

 LDA #11                ; Move the text cursor to column 11 to print the screen
 JSR DOXC               ; title

 LDA #164               ; Print recursive token 4 ("INVENTORY{crlf}") followed
 JSR TT60               ; by a paragraph break and Sentence Case

 JSR NLIN4              ; Draw a horizontal line at pixel row 19 to box in the
                        ; title. The authors could have used a call to NLIN3
                        ; instead and saved the above call to TT60, but you
                        ; just can't optimise everything

 JSR fwl                ; Call fwl to print the fuel and cash levels on two
                        ; separate lines

 LDA CRGO               ; If our ship's cargo capacity is < 26 (i.e. we do not
 CMP #26                ; have a cargo bay extension), skip the following two
 BCC P%+7               ; instructions

 LDA #107               ; We do have a cargo bay extension, so print recursive
 JSR TT27               ; token 107 ("LARGE CARGO{sentence case} BAY")

 JMP TT210              ; Jump to TT210 to print the contents of our cargo bay
                        ; and return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT214
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Ask a question with a "Y/N?" prompt and return the response
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to print before the "Y/N?" prompt
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if the response was "yes", clear otherwise
;
; ******************************************************************************

.TT214

;.TT214                 ; These instructions are commented out in the original
;PHA                    ; source
;JSR TT162
;PLA

.TT221

 JSR TT27               ; Print the text token in A

 LDA #206               ; Print extended token 206 ("{all caps}(Y/N)?")
 JSR DETOK

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A and X

 ORA #%00100000         ; Set bit 5 in the value of the key pressed, which
                        ; converts it to lower case

 CMP #'y'               ; If "y" was pressed, jump to TT218
 BEQ TT218

 LDA #'n'               ; Otherwise jump to TT26 to print "n" and return from
 JMP TT26               ; the subroutine using a tail call (so all other
                        ; responses apart from "y" indicate a no)

.TT218

 JSR TT26               ; Print the character in A, i.e. print "y"

 SEC                    ; Set the C flag to indicate a "yes" response

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT16
;       Type: Subroutine
;   Category: Charts
;    Summary: Move the crosshairs on a chart
;
; ------------------------------------------------------------------------------
;
; Move the chart crosshairs by the amount in X and Y.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The amount to move the crosshairs in the x-axis
;
;   Y                   The amount to move the crosshairs in the y-axis
;
; ******************************************************************************

.TT16

 TXA                    ; Push the change in X onto the stack (let's call this
 PHA                    ; the x-delta)

 DEY                    ; Negate the change in Y and push it onto the stack
 TYA                    ; (let's call this the y-delta)
 EOR #$FF
 PHA

 JSR WSCAN              ; Call WSCAN to wait for the vertical sync, so the whole
                        ; screen gets drawn and we can move the crosshairs with
                        ; no screen flicker

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will erase the crosshairs currently there

 PLA                    ; Store the y-delta in QQ19+3 and fetch the current
 STA QQ19+3             ; y-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ10               ; for the call to TT123

 JSR TT123              ; Call TT123 to move the selected system's galactic
                        ; y-coordinate by the y-delta, putting the new value in
                        ; QQ19+4

 LDA QQ19+4             ; Store the updated y-coordinate in QQ10 (the current
 STA QQ10               ; y-coordinate of the crosshairs)

 STA QQ19+1             ; This instruction has no effect, as QQ19+1 is
                        ; overwritten below, both in TT103 and TT105

 PLA                    ; Store the x-delta in QQ19+3 and fetch the current
 STA QQ19+3             ; x-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ9                ; for the call to TT123

 JSR TT123              ; Call TT123 to move the selected system's galactic
                        ; x-coordinate by the x-delta, putting the new value in
                        ; QQ19+4

 LDA QQ19+4             ; Store the updated x-coordinate in QQ9 (the current
 STA QQ9                ; x-coordinate of the crosshairs)

 STA QQ19               ; This instruction has no effect, as QQ19 is overwritten
                        ; below, both in TT103 and TT105

                        ; Now we've updated the coordinates of the crosshairs,
                        ; fall through into TT103 to redraw them at their new
                        ; location

; ******************************************************************************
;
;       Name: TT103
;       Type: Subroutine
;   Category: Charts
;    Summary: Draw a small set of crosshairs on a chart
;
; ------------------------------------------------------------------------------
;
; Draw a small set of crosshairs on a galactic chart at the coordinates in
; (QQ9, QQ10).
;
; ******************************************************************************

.TT103

 LDA QQ11               ; Fetch the current view type into A

 BMI TT105              ; If this is the Short-range Chart screen, jump to TT105

 LDA QQ9                ; Store the crosshairs x-coordinate in QQ19
 STA QQ19

 LDA QQ10               ; Halve the crosshairs y-coordinate and store it in QQ19
 LSR A                  ; (we halve it because the Long-range Chart is half as
 STA QQ19+1             ; high as it is wide)

 LDA #4                 ; Set QQ19+2 to 4 denote crosshairs of size 4
 STA QQ19+2

 JMP TT15               ; Jump to TT15 to draw crosshairs of size 4 at the
                        ; crosshairs coordinates, returning from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TT123
;       Type: Subroutine
;   Category: Charts
;    Summary: Move galactic coordinates by a signed delta
;
; ------------------------------------------------------------------------------
;
; Move an 8-bit galactic coordinate by a certain distance in either direction
; (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
; overflow. The coordinate is in a single axis, so it's either an x-coordinate
; or a y-coordinate.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The galactic coordinate to update
;
;   QQ19+3              The delta (can be positive or negative)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   QQ19+4              The updated coordinate after moving by the delta (this
;                       will be the same as A if moving by the delta overflows)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT180               Contains an RTS
;
; ******************************************************************************

.TT123

 STA QQ19+4             ; Store the original coordinate in temporary storage at
                        ; QQ19+4

 CLC                    ; Set A = A + QQ19+3, so A now contains the original
 ADC QQ19+3             ; coordinate, moved by the delta

 LDX QQ19+3             ; If the delta is negative, jump to TT124
 BMI TT124

 BCC TT125              ; If the C flag is clear, then the above addition didn't
                        ; overflow, so jump to TT125 to return the updated value

 RTS                    ; Otherwise the C flag is set and the above addition
                        ; overflowed, so do not update the return value

.TT124

 BCC TT180              ; If the C flag is clear, then because the delta is
                        ; negative, this indicates the addition (which is
                        ; effectively a subtraction) underflowed, so jump to
                        ; TT180 to return from the subroutine without updating
                        ; the return value

.TT125

 STA QQ19+4             ; Store the updated coordinate in QQ19+4

.TT180

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT105
;       Type: Subroutine
;   Category: Charts
;    Summary: Draw crosshairs on the Short-range Chart, with clipping
;
; ------------------------------------------------------------------------------
;
; Check whether the crosshairs are close enough to the current system to appear
; on the Short-range Chart, and if so, draw them.
;
; ******************************************************************************

.TT105

 LDA QQ9                ; Set A = QQ9 - QQ0, the horizontal distance between the
 SEC                    ; crosshairs (QQ9) and the current system (QQ0)
 SBC QQ0

 CMP #38                ; If the horizontal distance in A < 38, then the
 BCC TT179              ; crosshairs are close enough to the current system to
                        ; appear in the Short-range Chart, so jump to TT179 to
                        ; check the vertical distance

 CMP #230               ; If the horizontal distance in A < -26, then the
 BCC TT180              ; crosshairs are too far from the current system to
                        ; appear in the Short-range Chart, so jump to TT180 to
                        ; return from the subroutine (as TT180 contains an RTS)

.TT179

 ASL A                  ; Set QQ19 = 104 + A * 4
 ASL A                  ;
 CLC                    ; 104 is the x-coordinate of the centre of the chart,
 ADC #104               ; so this sets QQ19 to the screen pixel x-coordinate
 STA QQ19               ; of the crosshairs

 LDA QQ10               ; Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    ; crosshairs (QQ10) and the current system (QQ1)
 SBC QQ1

 CMP #38                ; If the vertical distance in A is < 38, then the
 BCC P%+6               ; crosshairs are close enough to the current system to
                        ; appear in the Short-range Chart, so skip the next two
                        ; instructions

 CMP #220               ; If the horizontal distance in A is < -36, then the
 BCC TT180              ; crosshairs are too far from the current system to
                        ; appear in the Short-range Chart, so jump to TT180 to
                        ; return from the subroutine (as TT180 contains an RTS)

 ASL A                  ; Set QQ19+1 = 90 + A * 2
 CLC                    ;
 ADC #90                ; 90 is the y-coordinate of the centre of the chart,
 STA QQ19+1             ; so this sets QQ19+1 to the screen pixel x-coordinate
                        ; of the crosshairs

 LDA #8                 ; Set QQ19+2 to 8 denote crosshairs of size 8
 STA QQ19+2

 JMP TT15               ; Jump to TT15 to draw crosshairs of size 8 at the
                        ; crosshairs coordinates, returning from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TT23
;       Type: Subroutine
;   Category: Charts
;    Summary: Show the Short-range Chart
;
; ******************************************************************************

.TT23

 LDA #199               ; Set the number of pixel rows in the space view to 199,
 STA Yx2M1              ; to cover the size of the chart part of the Short-range
                        ; Chart view

 STA dontclip           ; ???

 LDA #128               ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 128 (Short-
                        ; range Chart)

 LDA #16                ; ???
 JSR DOVDU19

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to white)

 LDA #7                 ; Move the text cursor to column 7
 JSR DOXC

 LDA #190               ; Print recursive token 30 ("SHORT RANGE CHART") and
 JSR NLIN3              ; draw a horizontal line at pixel row 19 to box in the
                        ; title

 JSR TT14               ; Call TT14 to draw a circle with crosshairs at the
                        ; current system's galactic coordinates

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; i.e. at the selected system

 JSR TT81               ; Set the seeds in QQ15 to those of system 0 in the
                        ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to white)

 LDA #0                 ; Set A = 0, which we'll use below to zero out the INWK
                        ; workspace

 STA XX20               ; We're about to start working our way through each of
                        ; the galaxy's systems, so set up a counter in XX20 for
                        ; each system, starting at 0 and looping through to 255

 LDX #24                ; First, though, we need to zero out the 25 bytes at
                        ; INWK so we can use them to work out which systems have
                        ; room for a label, so set a counter in X for 25 bytes

.EE3

 STA INWK,X             ; Set the X-th byte of INWK to zero

 DEX                    ; Decrement the counter

 BPL EE3                ; Loop back to EE3 for the next byte until we've zeroed
                        ; all 25 bytes

                        ; We now loop through every single system in the galaxy
                        ; and check the distance from the current system whose
                        ; coordinates are in (QQ0, QQ1). We get the galactic
                        ; coordinates of each system from the system's seeds,
                        ; like this:
                        ;
                        ;   x = s1_hi (which is stored in QQ15+3)
                        ;   y = s0_hi (which is stored in QQ15+1)
                        ;
                        ; so the following loops through each system in the
                        ; galaxy in turn and calculates the distance between
                        ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one

.TT182

 LDA QQ15+3             ; Set A = s1_hi - QQ0, the horizontal distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ0, QQ1)
 SBC QQ0

 BCS TT184              ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
                        ; result is positive, so jump to TT184 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s1_hi - QQ0|)

.TT184

 CMP #20                ; If the horizontal distance in A is >= 20, then this
 BCS TT187              ; system is too far away from the current system to
                        ; appear in the Short-range Chart, so jump to TT187 to
                        ; move on to the next system

 LDA QQ15+1             ; Set A = s0_hi - QQ1, the vertical distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ0, QQ1)
 SBC QQ1

 BCS TT186              ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
                        ; result is positive, so jump to TT186 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s0_hi - QQ1|)

.TT186

 CMP #38                ; If the vertical distance in A is >= 38, then this
 BCS TT187              ; system is too far away from the current system to
                        ; appear in the Short-range Chart, so jump to TT187 to
                        ; move on to the next system

                        ; This system should be shown on the Short-range Chart,
                        ; so now we need to work out where the label should go,
                        ; and set up the various variables we need to draw the
                        ; system's filled circle on the chart

 LDA QQ15+3             ; Set A = s1_hi - QQ0, the horizontal distance between
 SEC                    ; this system and the current system, where |A| < 20.
 SBC QQ0                ; Let's call this the x-delta, as it's the horizontal
                        ; difference between the current system at the centre of
                        ; the chart, and this system (and this time we keep the
                        ; sign of A, so it can be negative if it's to the left
                        ; of the chart's centre, or positive if it's to the
                        ; right)

 ASL A                  ; Set XX12 = 104 + x-delta * 4
 ASL A                  ;
 ADC #104               ; 104 is the x-coordinate of the centre of the chart,
 STA XX12               ; so this sets XX12 to the centre 104 +/- 76, the pixel
                        ; x-coordinate of this system

 LSR A                  ; Move the text cursor to column x-delta / 2 + 1
 LSR A                  ; which will be in the range 1-10
 LSR A
 CLC
 ADC #1
 JSR DOXC

 LDA QQ15+1             ; Set A = s0_hi - QQ1, the vertical distance between
 SEC                    ; this system and the current system, where |A| < 38.
 SBC QQ1                ; Let's call this the y-delta, as it's the vertical
                        ; difference between the current system at the centre of
                        ; the chart, and this system (and this time we keep the
                        ; sign of A, so it can be negative if it's above the
                        ; chart's centre, or positive if it's below)

 ASL A                  ; Set K4 = 90 + y-delta * 2
 ADC #90                ;
 STA K4                 ; 90 is the y-coordinate of the centre of the chart,
                        ; so this sets K4 to the centre 90 +/- 74, the pixel
                        ; y-coordinate of this system

 LSR A                  ; Set Y = K4 / 8, so Y contains the number of the text
 LSR A                  ; row that contains this system
 LSR A
 TAY

                        ; Now to see if there is room for this system's label.
                        ; Ideally we would print the system name on the same
                        ; text row as the system, but we only want to print one
                        ; label per row, to prevent overlap, so now we check
                        ; this system's row, and if that's already occupied,
                        ; the row above, and if that's already occupied, the
                        ; row below... and if that's already occupied, we give
                        ; up and don't print a label for this system

 LDX INWK,Y             ; If the value in INWK+Y is 0 (i.e. the text row
 BEQ EE4                ; containing this system does not already have another
                        ; system's label on it), jump to EE4 to store this
                        ; system's label on this row

 INY                    ; If the value in INWK+Y+1 is 0 (i.e. the text row below
 LDX INWK,Y             ; the one containing this system does not already have
 BEQ EE4                ; another system's label on it), jump to EE4 to store
                        ; this system's label on this row

 DEY                    ; If the value in INWK+Y-1 is 0 (i.e. the text row above
 DEY                    ; the one containing this system does not already have
 LDX INWK,Y             ; another system's label on it), fall through into to
 BNE ee1                ; EE4 to store this system's label on this row,
                        ; otherwise jump to ee1 to skip printing a label for
                        ; this system (as there simply isn't room)

.EE4

 TYA                    ; Now to print the label, so move the text cursor to row
 JSR DOYC               ; Y (which contains the row where we can print this
                        ; system's label)

 CPY #3                 ; If Y < 3, then the system would clash with the chart
 BCC TT187              ; title, so jump to TT187 to skip showing the system

 LDA #$FF               ; Store $FF in INWK+Y, to denote that this row is now
 STA INWK,Y             ; occupied so we don't try to print another system's
                        ; label on this row

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

 JSR cpl                ; Call cpl to print out the system name for the seeds
                        ; in QQ15 (which now contains the seeds for the current
                        ; system)

.ee1

 LDA #0                 ; Now to plot the star, so set the high bytes of K, K3
 STA K3+1               ; and K4 to 0
 STA K4+1
 STA K+1

 LDA XX12               ; Set the low byte of K3 to XX12, the pixel x-coordinate
 STA K3                 ; of this system

 LDA QQ15+5             ; Fetch s2_hi for this system from QQ15+5, extract bit 0
 AND #1                 ; and add 2 to get the size of the star, which we store
 ADC #2                 ; in K. This will be either 2, 3 or 4, depending on the
 STA K                  ; value of bit 0, and whether the C flag is set (which
                        ; will vary depending on what happens in the above call
                        ; to cpl). Incidentally, the planet's average radius
                        ; also uses s2_hi, bits 0-3 to be precise, but that
                        ; doesn't mean the two sizes affect each other

                        ; We now have the following:
                        ;
                        ;   K(1 0)  = radius of star (2, 3 or 4)
                        ;
                        ;   K3(1 0) = pixel x-coordinate of system
                        ;
                        ;   K4(1 0) = pixel y-coordinate of system
                        ;
                        ; which we can now pass to the SUN routine to draw a
                        ; small "sun" on the Short-range Chart for this system

 JSR FLFLLS             ; Call FLFLLS to reset the LSO block

 JSR SUN                ; Call SUN to plot a sun with radius K at pixel
                        ; coordinate (K3, K4)

 JSR FLFLLS             ; Call FLFLLS to reset the LSO block

.TT187

 JSR TT20               ; We want to move on to the next system, so call TT20
                        ; to twist the three 16-bit seeds in QQ15

 INC XX20               ; Increment the counter

 BEQ P%+5               ; If X = 0 then we have done all 256 systems, so skip
                        ; the next instruction to return from the subroutine

 JMP TT182              ; Otherwise jump back up to TT182 to process the next
                        ; system

 LDA #0                 ; ???
 STA dontclip
 LDA #2*Y-1
 STA Yx2M1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT81
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the selected system's seeds to those of system 0
;
; ------------------------------------------------------------------------------
;
; Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
; seeds for the selected system (QQ15) - in other words, set the selected
; system's seeds to those of system 0.
;
; ******************************************************************************

.TT81

 LDX #5                 ; Set up a counter in X to copy six bytes (for three
                        ; 16-bit numbers)

 LDA QQ21,X             ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    ; Decrement the counter

 BPL TT81+2             ; Loop back up to the LDA instruction if we still have
                        ; more bytes to copy

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT111
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the current system to the nearest system to a point
;
; ------------------------------------------------------------------------------
;
; Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
; to this point in the galaxy, and set this as the currently selected system.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ9                 The x-coordinate near which we want to find a system
;
;   QQ10                The y-coordinate near which we want to find a system
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   QQ8(1 0)            The distance from the current system to the nearest
;                       system to the original coordinates
;
;   QQ9                 The x-coordinate of the nearest system to the original
;                       coordinates
;
;   QQ10                The y-coordinate of the nearest system to the original
;                       coordinates
;
;   QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
;                       original coordinates
;
;   ZZ                  The system number of the nearest system
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT111-1             Contains an RTS
;
; ******************************************************************************

.TT111

 JSR TT81               ; Set the seeds in QQ15 to those of system 0 in the
                        ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

                        ; We now loop through every single system in the galaxy
                        ; and check the distance from (QQ9, QQ10). We get the
                        ; galactic coordinates of each system from the system's
                        ; seeds, like this:
                        ;
                        ;   x = s1_hi (which is stored in QQ15+3)
                        ;   y = s0_hi (which is stored in QQ15+1)
                        ;
                        ; so the following loops through each system in the
                        ; galaxy in turn and calculates the distance between
                        ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one

 LDY #127               ; Set Y = T = 127 to hold the shortest distance we've
 STY T                  ; found so far, which we initially set to half the
                        ; distance across the galaxy, or 127, as our coordinate
                        ; system ranges from (0,0) to (255, 255)

 LDA #0                 ; Set A = U = 0 to act as a counter for each system in
 STA U                  ; the current galaxy, which we start at system 0 and
                        ; loop through to 255, the last system

.TT130

 LDA QQ15+3             ; Set A = s1_hi - QQ9, the horizontal distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ9, QQ10)
 SBC QQ9

 BCS TT132              ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
                        ; result is positive, so jump to TT132 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s1_hi - QQ9|)

.TT132

 LSR A                  ; Set S = A / 2
 STA S                  ;       = |s1_hi - QQ9| / 2

 LDA QQ15+1             ; Set A = s0_hi - QQ10, the vertical distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ9, QQ10)
 SBC QQ10

 BCS TT134              ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
                        ; result is positive, so jump to TT134 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s0_hi - QQ10|)

.TT134

 LSR A                  ; Set A = S + A / 2
 CLC                    ;       = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
 ADC S                  ;
                        ; So A now contains the sum of the horizontal and
                        ; vertical distances, both divided by 2 so the result
                        ; fits into one byte, and although this doesn't contain
                        ; the actual distance between the systems, it's a good
                        ; enough approximation to use for comparing distances

 CMP T                  ; If A >= T, then this system's distance is bigger than
 BCS TT135              ; our "minimum distance so far" stored in T, so it's no
                        ; closer than the systems we have already found, so
                        ; skip to TT135 to move on to the next system

 STA T                  ; This system is the closest to (QQ9, QQ10) so far, so
                        ; update T with the new "distance" approximation

 LDX #5                 ; As this system is the closest we have found yet, we
                        ; want to store the system's seeds in case it ends up
                        ; being the closest of all, so we set up a counter in X
                        ; to copy six bytes (for three 16-bit numbers)

.TT136

 LDA QQ15,X             ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
 STA QQ19,X             ; where QQ15 contains the seeds for the system we just
                        ; found to be the closest so far, and QQ19 is temporary
                        ; storage

 DEX                    ; Decrement the counter

 BPL TT136              ; Loop back to TT136 if we still have more bytes to
                        ; copy

 LDA U                  ; Store the system number U in ZZ, so when we are done
 STA ZZ                 ; looping through all the candidates, the winner's
                        ; number will be in ZZ

.TT135

 JSR TT20               ; We want to move on to the next system, so call TT20
                        ; to twist the three 16-bit seeds in QQ15

 INC U                  ; Increment the system counter in U

 BNE TT130              ; If U > 0 then we haven't done all 256 systems yet, so
                        ; loop back up to TT130

                        ; We have now finished checking all the systems in the
                        ; galaxy, and the seeds for the closest system are in
                        ; QQ19, so now we want to copy these seeds to QQ15,
                        ; to set the selected system to this closest system

 LDX #5                 ; So we set up a counter in X to copy six bytes (for
                        ; three 16-bit numbers)

.TT137

 LDA QQ19,X             ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    ; Decrement the counter

 BPL TT137              ; Loop back to TT137 if we still have more bytes to
                        ; copy

 LDA QQ15+1             ; The y-coordinate of the system described by the seeds
 STA QQ10               ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
                        ; as this is where we store the selected system's
                        ; y-coordinate

 LDA QQ15+3             ; The x-coordinate of the system described by the seeds
 STA QQ9                ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
                        ; as this is where we store the selected system's
                        ; x-coordinate

                        ; We have now found the closest system to (QQ9, QQ10)
                        ; and have set it as the selected system, so now we
                        ; need to work out the distance between the selected
                        ; system and the current system

 SEC                    ; Set A = QQ9 - QQ0, the horizontal distance between
 SBC QQ0                ; the selected system's x-coordinate (QQ9) and the
                        ; current system's x-coordinate (QQ0)

 BCS TT139              ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
                        ; result is positive, so jump to TT139 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |QQ9 - QQ0|)

                        ; A now contains the difference between the two
                        ; systems' x-coordinates, with the sign removed. We
                        ; will refer to this as the x-delta ("delta" means
                        ; change or difference in maths)

.TT139

 JSR SQUA2              ; Set (A P) = A * A
                        ;           = |QQ9 - QQ0| ^ 2
                        ;           = x_delta ^ 2

 STA K+1                ; Store (A P) in K(1 0)
 LDA P
 STA K

 LDA QQ10               ; Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    ; selected system's y-coordinate (QQ10) and the current
 SBC QQ1                ; system's y-coordinate (QQ1)

 BCS TT141              ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
                        ; result is positive, so jump to TT141 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |QQ10 - QQ1|)

.TT141

 LSR A                  ; Set A = A / 2

                        ; A now contains the difference between the two
                        ; systems' y-coordinates, with the sign removed, and
                        ; halved. We halve the value because the galaxy in
                        ; in Elite is rectangular rather than square, and is
                        ; twice as wide (x-axis) as it is high (y-axis), so to
                        ; get a distance that matches the shape of the
                        ; long-range galaxy chart, we need to halve the
                        ; distance between the vertical y-coordinates. We will
                        ; refer to this as the y-delta

 JSR SQUA2              ; Set (A P) = A * A
                        ;           = (|QQ10 - QQ1| / 2) ^ 2
                        ;           = y_delta ^ 2

                        ; By this point we have the following results:
                        ;
                        ;   K(1 0) = x_delta ^ 2
                        ;    (A P) = y_delta ^ 2
                        ;
                        ; so to find the distance between the two points, we
                        ; can use Pythagoras - so first we need to add the two
                        ; results together, and then take the square root

 PHA                    ; Store the high byte of the y-axis value on the stack,
                        ; so we can use A for another purpose

 LDA P                  ; Set Q = P + K, which adds the low bytes of the two
 CLC                    ; calculated values
 ADC K
 STA Q

 PLA                    ; Restore the high byte of the y-axis value from the
                        ; stack into A again

 ADC K+1                ; Set A = A + K+1, which adds the high bytes of the two
                        ; calculated values

 BCC P%+4               ; If the above addition overflowed, set A = 255
 LDA #255

 STA R                  ; Store A in R, so we now have R = A + K+1, and:
                        ;
                        ;   (R Q) = K(1 0) + (A P)
                        ;         = (x_delta ^ 2) + (y_delta ^ 2)

 JSR LL5                ; Set Q = SQRT(R Q), so Q now contains the distance
                        ; between the two systems, in terms of coordinates

                        ; We now store the distance to the selected system * 4
                        ; in the two-byte location QQ8, by taking (0 Q) and
                        ; shifting it left twice, storing it in QQ8(1 0)

 LDA Q                  ; First we shift the low byte left by setting
 ASL A                  ; A = Q * 2, with bit 7 of A going into the C flag

 LDX #0                 ; Now we set the high byte in QQ8+1 to 0 and rotate
 STX QQ8+1              ; the C flag into bit 0 of QQ8+1
 ROL QQ8+1

 ASL A                  ; And then we repeat the shift left of (QQ8+1 A)
 ROL QQ8+1

 STA QQ8                ; And store A in the low byte, QQ8, so QQ8(1 0) now
                        ; contains Q * 4. Given that the width of the galaxy is
                        ; 256 in coordinate terms, the width of the galaxy
                        ; would be 1024 in the units we store in QQ8

 JMP TT24               ; Call TT24 to calculate system data from the seeds in
                        ; QQ15 and store them in the relevant locations, so our
                        ; new selected system is fully set up, and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: dockEd
;       Type: Subroutine
;   Category: Flight
;    Summary: Print a message to say there is no hyperspacing allowed inside the
;             station
;
; ------------------------------------------------------------------------------
;
; Print "Docked" at the bottom of the screen to indicate we can't hyperspace
; when docked.
;
; ******************************************************************************

.dockEd

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #15                ; Move the text cursor to column 15
 JSR DOXC

;LDA #RED               ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to red)

 LDA #205               ; Print extended token 205 ("DOCKED") and return from
 JMP DETOK              ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: hyp
;       Type: Subroutine
;   Category: Flight
;    Summary: Start the hyperspace process
;
; ------------------------------------------------------------------------------
;
; Called when "H" or CTRL-H is pressed during flight. Checks the following:
;
;   * We are in space
;
;   * We are not already in a hyperspace countdown
;
; If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
; otherwise we check that:
;
;   * The selected system is not the current system
;
;   * We have enough fuel to make the jump
;
; and if all the pre-jump checks are passed, we print the destination on-screen
; and start the countdown.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TTX111              Used to rejoin this routine from the call to TTX110
;
; ******************************************************************************

.hyp

 LDA QQ12               ; If we are docked (QQ12 = $FF) then jump to dockEd to
 BNE dockEd             ; print an error message and return from the subroutine
                        ; using a tail call (as we can't hyperspace when docked)

 LDA QQ22+1             ; Fetch QQ22+1, which contains the number that's shown
                        ; on-screen during hyperspace countdown

 BEQ P%+3               ; If it is zero, skip the next instruction

 RTS                    ; The count is non-zero, so return from the subroutine

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to cyan)

 JSR CTRL               ; Scan the keyboard to see if CTRL is currently pressed

 BMI Ghy                ; If it is, then the galactic hyperdrive has been
                        ; activated, so jump to Ghy to process it

 LDA QQ11               ; If the current view is 0 (i.e. the space view) then
 BEQ TTX110             ; jump to TTX110, which calls TT111 to set the current
                        ; system to the nearest system to (QQ9, QQ10), and jumps
                        ; back into this routine at TTX111 below

 AND #%11000000         ; If either bit 6 or 7 of the view type is set - so
 BNE P%+3               ; this is either the Short-range or Long-range Chart -
                        ; then skip the following instruction

 RTS                    ; This is not a chart view, so return from the
                        ; subroutine

 JSR hm                 ; This is a chart view, so call hm to redraw the chart
                        ; crosshairs

.TTX111

                        ; If we get here then the current view is either the
                        ; space view or a chart

 LDA QQ8                ; If either byte of the distance to the selected system
 ORA QQ8+1              ; in QQ8 are zero, skip the next instruction to make a
 BNE P%+3               ; copy of the destination seeds in safehouse

 RTS                    ; The selected system is the same as the current system,
                        ; so return from the subroutine

 LDX #5                 ; We now want to copy those seeds into safehouse, so we
                        ; so set a counter in X to copy 6 bytes

.sob

 LDA QQ15,X             ; Copy the X-th byte of QQ15 into the X-th byte of
 STA safehouse,X        ; safehouse

 DEX                    ; Decrement the loop counter

 BPL sob                ; Loop back to copy the next byte until we have copied
                        ; all six seed bytes

 LDA #7                 ; ???
 JSR DOXC
 LDA #23
 LDY QQ11
 BNE P%+4
 LDA #17
 JSR DOYC

 LDA #0                 ; Set QQ17 = 0 to switch to ALL CAPS
 STA QQ17

 LDA #189               ; Print recursive token 29 ("HYPERSPACE ")
 JSR TT27

 LDA QQ8+1              ; If the high byte of the distance to the selected
 BNE goTT147            ; system in QQ8 is > 0, then it is definitely too far to
                        ; jump (as our maximum range is 7.0 light years, or a
                        ; value of 70 in QQ8(1 0)), so jump to TT147 via goTT147
                        ; to print "RANGE?" and return from the subroutine using
                        ; a tail call

 LDA QQ14               ; Fetch our current fuel level from Q114 into A

 CMP QQ8                ; If our fuel reserves are greater than or equal to the
 BCS P%+5               ; distance to the selected system, then we have enough
                        ; fuel for this jump, so skip the following instruction
                        ; to start the hyperspace countdown

.goTT147

 JMP TT147              ; We don't have enough fuel to reach the destination, so
                        ; jump to TT147 to print "RANGE?" and return from the
                        ; subroutine using a tail call

 LDA #'-'               ; Print a hyphen
 JSR TT27

 JSR cpl                ; Call cpl to print the name of the selected system

                        ; Fall through into wW to start the hyperspace countdown

; ******************************************************************************
;
;       Name: wW
;       Type: Subroutine
;   Category: Flight
;    Summary: Start a hyperspace countdown
;
; ------------------------------------------------------------------------------
;
; Start the hyperspace countdown (for both inter-system hyperspace and the
; galactic hyperdrive).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   wW2                 Start the hyperspace countdown, starting the countdown
;                       from the value in A
;
; ******************************************************************************

.wW

 LDA #15                ; The hyperspace countdown starts from 15, so set A to
                        ; 15 so we can set the two hyperspace counters

.wW2

 STA QQ22+1             ; Set the number in QQ22+1 to A, which is the number
                        ; that's shown on-screen during the hyperspace countdown

 STA QQ22               ; Set the number in QQ22 to 15, which is the internal
                        ; counter that counts down by 1 each iteration of the
                        ; main game loop, and each time it reaches zero, the
                        ; on-screen counter gets decremented, and QQ22 gets set
                        ; to 5, so setting QQ22 to 15 here makes the first tick
                        ; of the hyperspace counter longer than subsequent ticks

 TAX                    ; Print the 8-bit number in X (i.e. 15) at text location
 JMP ee3                ; (0, 1), padded to 5 digits, so it appears in the top
                        ; left corner of the screen, and return from the
                        ; subroutine using a tail call

;.hy5                   ; This instruction and the hy5 label are commented out
;RTS                    ; in the original - they can actually be found at the
                        ; end of the jmp routine below, so perhaps this is where
                        ; they were originally, but the authors realised they
                        ; could save a byte by using a tail call instead of an
                        ; RTS?

; ******************************************************************************
;
;       Name: TTX110
;       Type: Subroutine
;   Category: Flight
;    Summary: Set the current system to the nearest system and return to hyp
;
; ******************************************************************************

.TTX110

                        ; This routine is only called from the hyp routine, and
                        ; it jumps back into hyp at label TTX111

 JSR TT111              ; Call TT111 to set the current system to the nearest
                        ; system to (QQ9, QQ10), and put the seeds of the
                        ; nearest system into QQ15 to QQ15+5

 JMP TTX111             ; Return to TTX111 in the hyp routine

; ******************************************************************************
;
;       Name: Ghy
;       Type: Subroutine
;   Category: Flight
;    Summary: Perform a galactic hyperspace jump
;  Deep dive: Twisting the system seeds
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
; being pressed.
;
; This routine also updates the galaxy seeds to point to the next galaxy. Using
; a galactic hyperdrive rotates each seed byte to the left, rolling each byte
; left within itself like this:
;
;   01234567 -> 12345670
;
; to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
; roll round to those of the first galaxy again.
;
; We always arrive in a new galaxy at galactic coordinates (96, 96), and then
; find the nearest system and set that as our location.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   zZ+1                Contains an RTS
;
; ******************************************************************************

.Ghy

 LDX GHYP               ; Fetch GHYP, which tells us whether we own a galactic
 BEQ zZ+1               ; hyperdrive, and if it is zero, which means we don't,
                        ; return from the subroutine (as zZ+1 contains an RTS)

 INX                    ; We own a galactic hyperdrive, so X is $FF, so this
                        ; instruction sets X = 0

;STX QQ8                ; These instructions are commented out in the original
;STX QQ8+1              ; source

 STX GHYP               ; The galactic hyperdrive is a one-use item, so set GHYP
                        ; to 0 so we no longer have one fitted

 STX FIST               ; Changing galaxy also clears our criminal record, so
                        ; set our legal status in FIST to 0 ("clean")

 LDA #2                 ; Call wW2 with A = 2 to start the hyperspace countdown,
 JSR wW2                ; but starting the countdown from 2

 LDX #5                 ; To move galaxy, we rotate the galaxy's seeds left, so
                        ; set a counter in X for the 6 seed bytes

 INC GCNT               ; Increment the current galaxy number in GCNT

 LDA GCNT               ; Clear bit 3 of GCNT, so we jump from galaxy 7 back
 AND #%11110111         ; to galaxy 0 (shown in-game as going from galaxy 8 back
 STA GCNT               ; to the starting point in galaxy 1). We also retain any
                        ; set bits in the high nibble, so if the galaxy number
                        ; is manually set to 16 or higher, it will stay high
                        ; (though the high nibble doesn't seem to get set by
                        ; the game at any point, so it isn't clear what this is
                        ; for, though Lave in galaxy 16 does show a unique
                        ; system description override, so something is going on
                        ; here...)

.G1

 LDA QQ21,X             ; Load the X-th seed byte into A

 ASL A                  ; Set the C flag to bit 7 of the seed

 ROL QQ21,X             ; Rotate the seed in memory, which will add bit 7 back
                        ; in as bit 0, so this rolls the seed around on itself

 DEX                    ; Decrement the counter

 BPL G1                 ; Loop back for the next seed byte, until we have
                        ; rotated them all

;JSR DORND              ; This instruction is commented out in the original
                        ; source, and would set A and X to random numbers, so
                        ; perhaps the original plan was to arrive in each new
                        ; galaxy in a random place?

.zZ

 LDA #96                ; Set (QQ9, QQ10) to (96, 96), which is where we always
 STA QQ9                ; arrive in a new galaxy (the selected system will be
 STA QQ10               ; set to the nearest actual system later on)

 JSR TT110              ; Call TT110 to show the front space view

 JSR TT111              ; Call TT111 to set the current system to the nearest
                        ; system to (QQ9, QQ10), and put the seeds of the
                        ; nearest system into QQ15 to QQ15+5
                        ;
                        ; This call fixes a bug in the cassette version, where
                        ; the galactic hyperdrive will take us to coordinates
                        ; (96, 96) in the new galaxy, even if there isn't
                        ; actually a system there, so if we jump when we are
                        ; low on fuel, it is possible to get stuck in the
                        ; middle of nowhere when changing galaxy
                        ;
                        ; This call sets the current system correctly, so we
                        ; always arrive at the nearest system to (96, 96)

 LDX #5                 ; We now want to copy those seeds into safehouse, so we
                        ; so set a counter in X to copy 6 bytes

.dumdeedum

 LDA QQ15,X             ; Copy the X-th byte of QQ15 into the X-th byte of
 STA safehouse,X        ; safehouse

 DEX                    ; Decrement the loop counter

 BPL dumdeedum          ; Loop back to copy the next byte until we have copied
                        ; all six seed bytes

 LDX #0                 ; Set the distance to the selected system in QQ8(1 0)
 STX QQ8                ; to 0
 STX QQ8+1

 LDA #116               ; Print recursive token 116 (GALACTIC HYPERSPACE ")
 JSR MESS               ; as an in-flight message

                        ; Fall through into jmp to set the system to the
                        ; current system and return from the subroutine there

; ******************************************************************************
;
;       Name: jmp
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the current system to the selected system
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (QQ0, QQ1)          The galactic coordinates of the new system
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   hy5                 Contains an RTS
;
; ******************************************************************************

.jmp

 LDA QQ9                ; Set the current system's galactic x-coordinate to the
 STA QQ0                ; x-coordinate of the selected system

 LDA QQ10               ; Set the current system's galactic y-coordinate to the
 STA QQ1                ; y-coordinate of the selected system

.hy5

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ee3
;       Type: Subroutine
;   Category: Flight
;    Summary: Print the hyperspace countdown in the top-left of the screen
;
; ------------------------------------------------------------------------------
;
; 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
; numbers < 10000 are right-aligned), with no decimal point.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The number to print
;
; ******************************************************************************

.ee3

;LDA #RED               ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to red)

 LDA #1                 ; Move the text cursor to column 1 on row 1
 JSR DOXC
 JSR DOYC

 LDY #0                 ; Set Y = 0 for the high byte in pr6

 CLC                    ; Call TT11 to print X to 3 digits with no decimal point
 LDA #3                 ; and return from the subroutine using a tail call
 JMP TT11

; ******************************************************************************
;
;       Name: pr6
;       Type: Subroutine
;   Category: Text
;    Summary: Print 16-bit number, left-padded to 5 digits, no point
;
; ------------------------------------------------------------------------------
;
; Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
; numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
; with no decimal point.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The low byte of the number to print
;
;   Y                   The high byte of the number to print
;
; ******************************************************************************

.pr6

 CLC                    ; Do not display a decimal point when printing

                        ; Fall through into pr5 to print X to 5 digits

; ******************************************************************************
;
;       Name: pr5
;       Type: Subroutine
;   Category: Text
;    Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
;
; ------------------------------------------------------------------------------
;
; Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
; numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
; Optionally include a decimal point.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The low byte of the number to print
;
;   Y                   The high byte of the number to print
;
;   C flag              If set, include a decimal point
;
; ******************************************************************************

.pr5

 LDA #5                 ; Set the number of digits to print to 5

 JMP TT11               ; Call TT11 to print (Y X) to 5 digits and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT147
;       Type: Subroutine
;   Category: Flight
;    Summary: Print an error when a system is out of hyperspace range
;
; ------------------------------------------------------------------------------
;
; Print "RANGE?" for when the hyperspace distance is too far
;
; ******************************************************************************

.TT147

 LDA #202               ; Load A with token 42 ("RANGE") and fall through into
                        ; prq to print it, followed by a question mark

; ******************************************************************************
;
;       Name: prq
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token followed by a question mark
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   prq+3               Print a question mark
;
; ******************************************************************************

.prq

 JSR TT27               ; Print the text token in A

 LDA #'?'               ; Print a question mark and return from the
 JMP TT27               ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT151
;       Type: Subroutine
;   Category: Market
;    Summary: Print the name, price and availability of a market item
;  Deep dive: Market item prices and availability
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The number of the market item to print, 0-16 (see QQ23
;                       for details of item numbers)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   QQ19+1              Byte #1 from the market prices table for this item
;
;   QQ24                The item's price / 4
;
;   QQ25                The item's availability
;
; ******************************************************************************

.TT151q

                        ; We jump here from below if we are in witchspace

 PLA                    ; Restore the item number from the stack

 RTS                    ; Return from the subroutine

.TT151

 PHA                    ; Store the item number on the stack and in QQ19+4
 STA QQ19+4

 ASL A                  ; Store the item number * 4 in QQ19, so this will act as
 ASL A                  ; an index into the market prices table at QQ23 for this
 STA QQ19               ; item (as there are four bytes per item in the table)

 LDA MJ                 ; If we are in witchspace, we can't trade items, so jump
 BNE TT151q             ; up to TT151q to return from the subroutine

 LDA #1                 ; Move the text cursor to column 1, for the item's name
 JSR DOXC

 PLA                    ; Restore the item number

 ADC #208               ; Print recursive token 48 + A, which will be in the
 JSR TT27               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
                        ; prints the item's name

 LDA #14                ; Move the text cursor to column 14, for the price
 JSR DOXC

 LDX QQ19               ; Fetch byte #1 from the market prices table (units and
 LDA QQ23+1,X           ; economic_factor) for this item and store in QQ19+1
 STA QQ19+1

 LDA QQ26               ; Fetch the random number for this system visit and
 AND QQ23+3,X           ; AND with byte #3 from the market prices table (mask)
                        ; to give:
                        ;
                        ;   A = random AND mask

 CLC                    ; Add byte #0 from the market prices table (base_price),
 ADC QQ23,X             ; so we now have:
 STA QQ24               ;
                        ;   A = base_price + (random AND mask)

 JSR TT152              ; Call TT152 to print the item's unit ("t", "kg" or
                        ; "g"), padded to a width of two characters

 JSR var                ; Call var to set QQ19+3 = economy * |economic_factor|
                        ; (and set the availability of alien items to 0)

 LDA QQ19+1             ; Fetch the byte #1 that we stored above and jump to
 BMI TT155              ; TT155 if it is negative (i.e. if the economic_factor
                        ; is negative)

 LDA QQ24               ; Set A = QQ24 + QQ19+3
 ADC QQ19+3             ;
                        ;       = base_price + (random AND mask)
                        ;         + (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as the economic_factor
                        ; is positive

 JMP TT156              ; Jump to TT156 to multiply the result by 4

.TT155

 LDA QQ24               ; Set A = QQ24 - QQ19+3
 SEC                    ;
 SBC QQ19+3             ;       = base_price + (random AND mask)
                        ;         - (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as economic_factor
                        ; is negative

.TT156

 STA QQ24               ; Store the result in QQ24 and P
 STA P

 LDA #0                 ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
 JSR GC2                ; which is the same as (Y X) = P * 4 because A = 0

 SEC                    ; We now have our final price, * 10, so we can call pr5
 JSR pr5                ; to print (Y X) to 5 digits, including a decimal
                        ; point, as the C flag is set

 LDY QQ19+4             ; We now move on to availability, so fetch the market
                        ; item number that we stored in QQ19+4 at the start

 LDA #5                 ; Set A to 5 so we can print the availability to 5
                        ; digits (right-padded with spaces)

 LDX AVL,Y              ; Set X to the item's availability, which is given in
                        ; the AVL table

 STX QQ25               ; Store the availability in QQ25

 CLC                    ; Clear the C flag

 BEQ TT172              ; If none are available, jump to TT172 to print a tab
                        ; and a "-"

 JSR pr2+2              ; Otherwise print the 8-bit number in X to 5 digits,
                        ; right-aligned with spaces. This works because we set
                        ; A to 5 above, and we jump into the pr2 routine just
                        ; after the first instruction, which would normally
                        ; set the number of digits to 3

 JMP TT152              ; Print the unit ("t", "kg" or "g") for the market item,
                        ; with a following space if required to make it two
                        ; characters long, and return from the subroutine using
                        ; a tail call

.TT172

 LDA #25                ; Move the text cursor to column 25
 JSR DOXC

 LDA #'-'               ; Print a "-" character by jumping to TT162+2, which
 BNE TT162+2            ; contains JMP TT27 (this BNE is effectively a JMP as A
                        ; will never be zero), and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TT152
;       Type: Subroutine
;   Category: Market
;    Summary: Print the unit ("t", "kg" or "g") for a market item
;
; ------------------------------------------------------------------------------
;
; Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
; market prices table is in QQ19+1, right-padded with spaces to a width of two
; characters (so that's "t ", "kg" or "g ").
;
; ******************************************************************************

.TT152

 LDA QQ19+1             ; Fetch the economic_factor from QQ19+1

 AND #96                ; If bits 5 and 6 are both clear, jump to TT160 to
 BEQ TT160              ; print "t" for tonne, followed by a space, and return
                        ; from the subroutine using a tail call

 CMP #32                ; If bit 5 is set, jump to TT161 to print "kg" for
 BEQ TT161              ; kilograms, and return from the subroutine using a tail
                        ; call

 JSR TT16a              ; Otherwise call TT16a to print "g" for grams, and fall
                        ; through into TT162 to print a space and return from
                        ; the subroutine

; ******************************************************************************
;
;       Name: TT162
;       Type: Subroutine
;   Category: Text
;    Summary: Print a space
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT162+2             Jump to TT27 to print the text token in A
;
; ******************************************************************************

.TT162

 LDA #' '               ; Load a space character into A

 JMP TT27               ; Print the text token in A and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT160
;       Type: Subroutine
;   Category: Market
;    Summary: Print "t" (for tonne) and a space
;
; ******************************************************************************

.TT160

 LDA #'t'               ; Load a "t" character into A

 JSR TT26               ; Print the character, using TT216 so that it doesn't
                        ; change the character case

 BCC TT162              ; Jump to TT162 to print a space and return from the
                        ; subroutine using a tail call (this BCC is effectively
                        ; a JMP as the C flag is cleared by TT26)

; ******************************************************************************
;
;       Name: TT161
;       Type: Subroutine
;   Category: Market
;    Summary: Print "kg" (for kilograms)
;
; ******************************************************************************

.TT161

 LDA #'k'               ; Load a "k" character into A

 JSR TT26               ; Print the character, using TT216 so that it doesn't
                        ; change the character case, and fall through into
                        ; TT16a to print a "g" character

; ******************************************************************************
;
;       Name: TT16a
;       Type: Subroutine
;   Category: Market
;    Summary: Print "g" (for grams)
;
; ******************************************************************************

.TT16a

 LDA #'g'               ; Load a "g" character into A

 JMP TT26               ; Print the character, using TT216 so that it doesn't
                        ; change the character case, and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT163
;       Type: Subroutine
;   Category: Market
;    Summary: Print the headers for the table of market prices
;
; ------------------------------------------------------------------------------
;
; Print the column headers for the prices table in the Buy Cargo and Market
; Price screens.
;
; ******************************************************************************

.TT163

 LDA #17                ; Move the text cursor in XC to column 17
 JSR DOXC

 LDA #255               ; Print recursive token 95 token ("UNIT  QUANTITY
 BNE TT162+2            ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
                        ; jumping to TT162+2, which contains JMP TT27 (this BNE
                        ; is effectively a JMP as A will never be zero), and
                        ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT167
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Market Price screen
;
; ******************************************************************************

.TT167

 LDA #16                ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 32 (Market Price screen)

 LDA #5                 ; Move the text cursor to column 5
 JSR DOXC

 LDA #167               ; Print recursive token 7 ("{current system name} MARKET
 JSR NLIN3              ; PRICES") and draw a horizontal line at pixel row 19
                        ; to box in the title

 LDA #3                 ; Move the text cursor to row 3
 JSR DOYC

 JSR TT163              ; Print the column headers for the prices table

 LDA #6                 ; Move the text cursor to row 6
 JSR DOYC

 LDA #0                 ; We're going to loop through all the available market
 STA QQ29               ; items, so we set up a counter in QQ29 to denote the
                        ; current item and start it at 0

.TT168

 LDX #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STX QQ17               ; next letter in capitals

 JSR TT151              ; Call TT151 to print the item name, market price and
                        ; availability of the current item, and set QQ24 to the
                        ; item's price / 4, QQ25 to the quantity available and
                        ; QQ19+1 to byte #1 from the market prices table for
                        ; this item

 JSR INCYC              ; Move the text cursor down one row

 INC QQ29               ; Increment QQ29 to point to the next item

 LDA QQ29               ; If QQ29 >= 17 then jump to TT168 as we have done the
 CMP #17                ; last item
 BCC TT168

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: var
;       Type: Subroutine
;   Category: Market
;    Summary: Calculate QQ19+3 = economy * |economic_factor|
;
; ------------------------------------------------------------------------------
;
; Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
; table for an item. Also sets the availability of alien items to 0.
;
; This routine forms part of the calculations for market item prices (TT151)
; and availability (GVL).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ19+1              Byte #1 of the market prices table for this market item
;                       (which contains the economic_factor in bits 0-5, and the
;                       sign of the economic_factor in bit 7)
;
; ******************************************************************************

.var

 LDA QQ19+1             ; Extract bits 0-5 from QQ19+1 into A, to get the
 AND #31                ; economic_factor without its sign, in other words:
                        ;
                        ;   A = |economic_factor|

 LDY QQ28               ; Set Y to the economy byte of the current system

 STA QQ19+2             ; Store A in QQ19+2

 CLC                    ; Clear the C flag so we can do additions below

 LDA #0                 ; Set AVL+16 (availability of alien items) to 0,
 STA AVL+16             ; setting A to 0 in the process

.TT153

                        ; We now do the multiplication by doing a series of
                        ; additions in a loop, building the result in A. Each
                        ; loop adds QQ19+2 (|economic_factor|) to A, and it
                        ; loops the number of times given by the economy byte;
                        ; in other words, because A starts at 0, this sets:
                        ;
                        ;   A = economy * |economic_factor|

 DEY                    ; Decrement the economy in Y, exiting the loop when it
 BMI TT154              ; becomes negative

 ADC QQ19+2             ; Add QQ19+2 to A

 JMP TT153              ; Loop back to TT153 to do another addition

.TT154

 STA QQ19+3             ; Store the result in QQ19+3

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: hyp1
;       Type: Subroutine
;   Category: Universe
;    Summary: Process a jump to the system closest to (QQ9, QQ10)
;
; ------------------------------------------------------------------------------
;
; Do a hyperspace jump to the system closest to galactic coordinates
; (QQ9, QQ10), and set up the current system's state to those of the new system.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (QQ0, QQ1)          The galactic coordinates of the new system
;
;   QQ2 to QQ2+6        The seeds of the new system
;
;   EV                  Set to 0
;
;   QQ28                The new system's economy
;
;   tek                 The new system's tech level
;
;   gov                 The new system's government
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   hyp1+3              Jump straight to the system at (QQ9, QQ10) without
;                       first calculating which system is closest. We do this
;                       if we already know that (QQ9, QQ10) points to a system
;
; ******************************************************************************

.hyp1

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 JSR jmp                ; Set the current system to the selected system

 LDX #5                 ; We now want to copy the seeds for the selected system
                        ; in QQ15 into QQ2, where we store the seeds for the
                        ; current system, so set up a counter in X for copying
                        ; 6 bytes (for three 16-bit seeds)

.TT112

 LDA safehouse,X        ; Copy the X-th byte in safehouse to the X-th byte in
 STA QQ2,X              ; QQ2

 DEX                    ; Decrement the counter

 BPL TT112              ; Loop back to TT112 if we still have more bytes to
                        ; copy

 INX                    ; Set X = 0 (as we ended the above loop with X = $FF)

 STX EV                 ; Set EV, the extra vessels spawning counter, to 0, as
                        ; we are entering a new system with no extra vessels
                        ; spawned

 LDA QQ3                ; Set the current system's economy in QQ28 to the
 STA QQ28               ; selected system's economy from QQ3

 LDA QQ5                ; Set the current system's tech level in tek to the
 STA tek                ; selected system's economy from QQ5

 LDA QQ4                ; Set the current system's government in gov to the
 STA gov                ; selected system's government from QQ4

; ******************************************************************************
;
;       Name: GVL
;       Type: Subroutine
;   Category: Universe
;    Summary: Calculate the availability of market items
;  Deep dive: Market item prices and availability
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Calculate the availability for each market item and store it in AVL. This is
; called on arrival in a new system.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   hyR                 Contains an RTS
;
; ******************************************************************************

.GVL

 JSR DORND              ; Set A and X to random numbers

 STA QQ26               ; Set QQ26 to the random byte that's used in the market
                        ; calculations

 LDX #0                 ; We are now going to loop through the market item
 STX XX4                ; availability table in AVL, so set a counter in XX4
                        ; (and X) for the market item number, starting with 0

.hy9

 LDA QQ23+1,X           ; Fetch byte #1 from the market prices table (units and
 STA QQ19+1             ; economic_factor) for item number X and store it in
                        ; QQ19+1

 JSR var                ; Call var to set QQ19+3 = economy * |economic_factor|
                        ; (and set the availability of alien items to 0)

 LDA QQ23+3,X           ; Fetch byte #3 from the market prices table (mask) and
 AND QQ26               ; AND with the random number for this system visit
                        ; to give:
                        ;
                        ;   A = random AND mask

 CLC                    ; Add byte #2 from the market prices table
 ADC QQ23+2,X           ; (base_quantity) so we now have:
                        ;
                        ;   A = base_quantity + (random AND mask)

 LDY QQ19+1             ; Fetch the byte #1 that we stored above and jump to
 BMI TT157              ; TT157 if it is negative (i.e. if the economic_factor
                        ; is negative)

 SEC                    ; Set A = A - QQ19+3
 SBC QQ19+3             ;
                        ;       = base_quantity + (random AND mask)
                        ;         - (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as the economic_factor
                        ; is positive

 JMP TT158              ; Jump to TT158 to skip TT157

.TT157

 CLC                    ; Set A = A + QQ19+3
 ADC QQ19+3             ;
                        ;       = base_quantity + (random AND mask)
                        ;         + (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as the economic_factor
                        ; is negative

.TT158

 BPL TT159              ; If A < 0, then set A = 0, so we don't have negative
 LDA #0                 ; availability

.TT159

 LDY XX4                ; Fetch the counter (the market item number) into Y

 AND #%00111111         ; Take bits 0-5 of A, i.e. A mod 64, and store this as
 STA AVL,Y              ; this item's availability in the Y=th byte of AVL, so
                        ; each item has a maximum availability of 63t

 INY                    ; Increment the counter into XX44, Y and A
 TYA
 STA XX4

 ASL A                  ; Set X = counter * 4, so that X points to the next
 ASL A                  ; item's entry in the four-byte market prices table,
 TAX                    ; ready for the next loop

 CMP #63                ; If A < 63, jump back up to hy9 to set the availability
 BCC hy9                ; for the next market item

.hyR

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GTHG
;       Type: Subroutine
;   Category: Universe
;    Summary: Spawn a Thargoid ship and a Thargon companion
;  Deep dive: Fixing ship positions
;
; ******************************************************************************

.GTHG

 JSR Ze                 ; Call Ze to initialise INWK
                        ;
                        ; Note that because Ze uses the value of X returned by
                        ; DORND, and X contains the value of A returned by the
                        ; previous call to DORND, this does not set the new ship
                        ; to a totally random location. See the deep dive on
                        ; "Fixing ship positions" for details

 LDA #%11111111         ; Set the AI flag in byte #32 so that the ship has AI,
 STA INWK+32            ; is extremely and aggressively hostile, and has E.C.M.

 LDA #THG               ; Call NWSHP to add a new Thargoid ship to our local
 JSR NWSHP              ; bubble of universe

 LDA #TGL               ; Call NWSHP to add a new Thargon ship to our local
 JMP NWSHP              ; bubble of universe, and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: MJP
;       Type: Subroutine
;   Category: Flight
;    Summary: Process a mis-jump into witchspace
;
; ------------------------------------------------------------------------------
;
; Process a mis-jump into witchspace (which happens very rarely). Witchspace has
; a strange, almost dust-free aspect to it, and it is populated by hostile
; Thargoids. Using our escape pod will be fatal, and our position on the
; galactic chart is in-between systems. It is a scary place...
;
; There is a 0.78% chance that this routine is called from TT18 instead of doing
; a normal hyperspace, or we can manually trigger a mis-jump by holding down
; CTRL after first enabling the "author display" configuration option ("X") when
; paused.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   ptg                 Called when the user manually forces a mis-jump
;
;   RTS111              Contains an RTS
;
; ******************************************************************************

.ptg

 LSR COK                ; Set bit 0 of the competition flags in COK, so that the
 SEC                    ; competition code will include the fact that we have
 ROL COK                ; manually forced a mis-jump into witchspace

.MJP

;JSR CATLOD             ; This instruction is commented out in the original
                        ; source

 LDA #3                 ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 3

 JSR LL164              ; Call LL164 to show the hyperspace tunnel and make the
                        ; hyperspace sound for a second time (as we already
                        ; called LL164 in TT18)

 JSR RES2               ; Reset a number of flight variables and workspaces, as
                        ; well as setting Y to $FF

 STY MJ                 ; Set the mis-jump flag in MJ to $FF, to indicate that
                        ; we are now in witchspace

.MJP1

 JSR GTHG               ; Call GTHG to spawn a Thargoid ship and a Thargon
                        ; companion

 LDA #3                 ; Fetch the number of Thargoid ships from MANY+THG, and
 CMP MANY+THG           ; if it is less than or equal to 3, loop back to MJP1 to
 BCS MJP1               ; spawn another one, until we have four Thargoids

 STA NOSTM              ; Set NOSTM (the maximum number of stardust particles)
                        ; to 3, so there are fewer bits of stardust in
                        ; witchspace (normal space has a maximum of 18)

 LDX #0                 ; Initialise the front space view
 JSR LOOK1

 LDA QQ1                ; Fetch the current system's galactic y-coordinate in
 EOR #%00011111         ; QQ1 and flip bits 0-5, so we end up somewhere in the
 STA QQ1                ; vicinity of our original destination, but above or
                        ; below it in the galactic chart

 RTS                    ; Return from the subroutine

.RTS111

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT18
;       Type: Subroutine
;   Category: Flight
;    Summary: Try to initiate a jump into hyperspace
;
; ------------------------------------------------------------------------------
;
; Try to go through hyperspace. Called from TT102 in the main loop when the
; hyperspace countdown has finished.
;
; ******************************************************************************

.TT18

 LDA QQ14               ; Subtract the distance to the selected system (in QQ8)
 SEC                    ; from the amount of fuel in our tank (in QQ14) into A
 SBC QQ8

 BCS P%+4               ; If the subtraction didn't overflow, skip the next
                        ; instruction

 LDA #0                 ; The subtraction overflowed, so set A = 0 so we don't
                        ; end up with a negative amount of fuel

 STA QQ14               ; Store the updated fuel amount in QQ14

 LDA QQ11               ; If the current view is not a space view, jump to ee5
 BNE ee5                ; to skip the following

 JSR TT66               ; Clear the top part of the screen, draw a white border,
                        ; and set the current view type in QQ11 to 0 (space
                        ; view)

 JSR LL164              ; Call LL164 to show the hyperspace tunnel and make the
                        ; hyperspace sound

.ee5

 JSR CTRL               ; Scan the keyboard to see if CTRL is currently pressed,
                        ; returning a negative value in A if it is

 AND PATG               ; If the game is configured to show the author's names
                        ; on the start-up screen, then PATG will contain $FF,
                        ; otherwise it will be 0

 BMI ptg                ; By now, A will be negative if we are holding down CTRL
                        ; and author names are configured, which is what we have
                        ; to do in order to trigger a manual mis-jump, so jump
                        ; to ptg to do a mis-jump (ptg not only mis-jumps, but
                        ; updates the competition flags, so Acornsoft could tell
                        ; from the competition code whether this feature had
                        ; been used)

 JSR DORND              ; Set A and X to random numbers

 CMP #253               ; If A >= 253 (0.78% chance) then jump to MJP to trigger
 BCS MJP                ; a mis-jump into witchspace

;JSR TT111              ; This instruction is commented out in the original
                        ; source. It finds the closest system to coordinates
                        ; (QQ9, QQ10), but we don't need to do this as the
                        ; crosshairs will already be on a system by this point

 JSR hyp1+3             ; Jump straight to the system at (QQ9, QQ10) without
                        ; first calculating which system is closest

 JSR RES2               ; Reset a number of flight variables and workspaces

 JSR SOLAR              ; Halve our legal status, update the missile indicators,
                        ; and set up data blocks and slots for the planet and
                        ; sun

;JSR CATLOD             ; These instructions are commented out in the original
;JSR LOMOD              ; source

 LDA QQ11               ; If the current view in QQ11 is not a space view (0) or
 AND #%00111111         ; one of the charts (64 or 128), return from the
 BNE RTS111             ; subroutine (as RTS111 contains an RTS)

 JSR TTX66              ; Otherwise clear the screen and draw a white border

 LDA QQ11               ; If the current view is one of the charts, jump to
 BNE TT114              ; TT114 (from which we jump to the correct routine to
                        ; display the chart)

 INC QQ11               ; This is a space view, so increment QQ11 to 1

                        ; Fall through into TT110 to show the front space view

; ******************************************************************************
;
;       Name: TT110
;       Type: Subroutine
;   Category: Flight
;    Summary: Launch from a station or show the front space view
;
; ------------------------------------------------------------------------------
;
; Launch the ship (if we are docked), or show the front space view (if we are
; already in space).
;
; Called when the launch button is pressed while docked, after we arrive in a
; new galaxy, or after a hyperspace if the current view is a space view.
;
; ******************************************************************************

.TT110

 LDX QQ12               ; If we are not docked (QQ12 = 0) then jump to NLUNCH
 BEQ NLUNCH             ; to skip the launch tunnel and setup process

 JSR LAUN               ; Show the space station launch tunnel

 JSR RES2               ; Reset a number of flight variables and workspaces

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 INC INWK+8             ; Increment z_sign ready for the call to SOS, so the
                        ; planet appears at a z_sign of 1 in front of us when
                        ; we launch

 JSR SOS1               ; Call SOS1 to set up the planet's data block and add it
                        ; to FRIN, where it will get put in the first slot as
                        ; it's the first one to be added to our local bubble of
                        ; universe following the call to RES2 above

 LDA #128               ; For the space station, set z_sign to $80, so it's
 STA INWK+8             ; behind us ($80 is negative)

 INC INWK+7             ; And increment z_hi, so it's only just behind us

 JSR NWSPS              ; Add a new space station to our local bubble of
                        ; universe

 LDA #12                ; Set our launch speed in DELTA to 12
 STA DELTA

 JSR BAD                ; Call BAD to work out how much illegal contraband we
                        ; are carrying in our hold (A is up to 40 for a
                        ; standard hold crammed with contraband, up to 70 for
                        ; an extended cargo hold full of narcotics and slaves)

 ORA FIST               ; OR the value in A with our legal status in FIST to
                        ; get a new value that is at least as high as both
                        ; values, to reflect the fact that launching with a
                        ; hold full of contraband can only make matters worse

 STA FIST               ; Update our legal status with the new value

 LDA #255               ; Set the view type in QQ11 to 255
 STA QQ11

 JSR HFS1               ; Call HFS1 to draw 8 concentric rings to remove the
                        ; launch tunnel that we drew above

.NLUNCH

 LDX #0                 ; Set QQ12 to 0 to indicate we are not docked
 STX QQ12

 JMP LOOK1              ; Jump to LOOK1 to switch to the front view (X = 0),
                        ; returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT114
;       Type: Subroutine
;   Category: Charts
;    Summary: Display either the Long-range or Short-range Chart
;
; ------------------------------------------------------------------------------
;
; Display either the Long-range or Short-range Chart, depending on the current
; view setting. Called from TT18 once we know the current view is one of the
; charts.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The current view, loaded from QQ11
;
; ******************************************************************************

.TT114

 BMI TT115              ; If bit 7 of the current view is set (i.e. the view is
                        ; the Short-range Chart, 128), skip to TT115 below to
                        ; jump to TT23 to display the chart

 JMP TT22               ; Otherwise the current view is the Long-range Chart, so
                        ; jump to TT22 to display it

.TT115

 JMP TT23               ; Jump to TT23 to display the Short-range Chart

; ******************************************************************************
;
;       Name: LCASH
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Subtract an amount of cash from the cash pot
;
; ------------------------------------------------------------------------------
;
; Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
; cash in the pot. As CASH is a four-byte number, this calculates:
;
;   CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              If set, there was enough cash to do the subtraction
;
;                       If clear, there was not enough cash to do the
;                       subtraction
;
; ******************************************************************************

.LCASH

 STX T1                 ; Subtract the least significant bytes:
 LDA CASH+3             ;
 SEC                    ;   CASH+3 = CASH+3 - X
 SBC T1
 STA CASH+3

 STY T1                 ; Then the second most significant bytes:
 LDA CASH+2             ;
 SBC T1                 ;   CASH+2 = CASH+2 - Y
 STA CASH+2

 LDA CASH+1             ; Then the third most significant bytes (which are 0):
 SBC #0                 ;
 STA CASH+1             ;   CASH+1 = CASH+1 - 0

 LDA CASH               ; And finally the most significant bytes (which are 0):
 SBC #0                 ;
 STA CASH               ;   CASH = CASH - 0

 BCS TT113              ; If the C flag is set then the subtraction didn't
                        ; underflow, so the value in CASH is correct and we can
                        ; jump to TT113 to return from the subroutine with the
                        ; C flag set to indicate success (as TT113 contains an
                        ; RTS)

                        ; Otherwise we didn't have enough cash in CASH to
                        ; subtract (Y X) from it, so fall through into
                        ; MCASH to reverse the sum and restore the original
                        ; value in CASH, and returning with the C flag clear

; ******************************************************************************
;
;       Name: MCASH
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Add an amount of cash to the cash pot
;
; ------------------------------------------------------------------------------
;
; Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
; calculates:
;
;   CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT113               Contains an RTS
;
; ******************************************************************************

.MCASH

 TXA                    ; Add the least significant bytes:
 CLC                    ;
 ADC CASH+3             ;   CASH+3 = CASH+3 + X
 STA CASH+3

 TYA                    ; Then the second most significant bytes:
 ADC CASH+2             ;
 STA CASH+2             ;   CASH+2 = CASH+2 + Y

 LDA CASH+1             ; Then the third most significant bytes (which are 0):
 ADC #0                 ;
 STA CASH+1             ;   CASH+1 = CASH+1 + 0

 LDA CASH               ; And finally the most significant bytes (which are 0):
 ADC #0                 ;
 STA CASH               ;   CASH = CASH + 0

 CLC                    ; Clear the C flag, so if the above was done following
                        ; a failed LCASH call, the C flag correctly indicates
                        ; failure

.TT113

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GCASH
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (Y X) = P * Q * 4
;
; ------------------------------------------------------------------------------
;
; Calculate the following multiplication of unsigned 8-bit numbers:
;
;   (Y X) = P * Q * 4
;
; ******************************************************************************

.GCASH

 JSR MULTU              ; Call MULTU to calculate (A P) = P * Q

; ******************************************************************************
;
;       Name: GC2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (Y X) = (A P) * 4
;
; ------------------------------------------------------------------------------
;
; Calculate the following multiplication of unsigned 16-bit numbers:
;
;   (Y X) = (A P) * 4
;
; ******************************************************************************

.GC2

 ASL P                  ; Set (A P) = (A P) * 4
 ROL A
 ASL P
 ROL A

 TAY                    ; Set (Y X) = (A P)
 LDX P

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: RDLI
;       Type: Variable
;   Category: Loader
;    Summary: The OS command string for running the flight code in file D.CODE
;             in the disc version of Elite
;
; ------------------------------------------------------------------------------
;
; This command is not used in the Commodore 64 version of Elite; it is left over
; from the BBC Micro disc version.
;
; ******************************************************************************

.RDLI

 EQUS "R.D.CODE"        ; This is short for "*RUN D.CODE"
 EQUB 13

; ******************************************************************************
;
;       Name: EQSHP
;       Type: Subroutine
;   Category: Equipment
;    Summary: Show the Equip Ship screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   err                 Beep, pause and go to the docking bay (i.e. show the
;                       Status Mode screen)
;
;   pres                Given an item number A with the item name in recursive
;                       token Y, show an error to say that the item is already
;                       present, refund the cost of the item, and then beep and
;                       exit to the docking bay (i.e. show the Status Mode
;                       screen)
;
; ******************************************************************************

.bay

 JMP BAY                ; Go to the docking bay (i.e. show the Status Mode
                        ; screen)

.EQSHP

 LDA #32                ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 32 (Equip Ship screen)

 LDA #12                ; Move the text cursor to column 12
 JSR DOXC

 LDA #207               ; Print recursive token 47 ("EQUIP") followed by a space
 JSR spc

 LDA #185               ; Print recursive token 25 ("SHIP") and draw a
 JSR NLIN3              ; horizontal line at pixel row 19 to box in the title

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               ; next letter in capitals

 JSR INCYC              ; Move the text cursor down one line

 LDA tek                ; Fetch the tech level of the current system from tek
 CLC                    ; and add 3 (the tech level is stored as 0-14, so A is
 ADC #3                 ; now set to between 3 and 17)

 CMP #12                ; If A >= 12 then set A = 14, so A is now set to between
 BCC P%+4               ; 3 and 14
 LDA #14

 STA Q                  ; Set QQ25 = A (so QQ25 is in the range 3-14 and
 STA QQ25               ; represents number of the most advanced item available
 INC Q                  ; in this system, which we can pass to gnum below when
                        ; asking which item we want to buy)
                        ;
                        ; Set Q = A + 1 (so Q is in the range 4-15 and contains
                        ; QQ25 + 1, i.e. the highest item number on sale + 1)

 LDA #70                ; Set A = 70 - QQ14, where QQ14 contains the current
 SEC                    ; fuel in light years * 10, so this leaves the amount
 SBC QQ14               ; of fuel we need to fill 'er up (in light years * 10)

 ASL A                  ; The price of fuel is always 2 Cr per light year, so we
 STA PRXS               ; double A and store it in PRXS, as the first price in
                        ; the price list (which is reserved for fuel), and
                        ; because the table contains prices as price * 10, it's
                        ; in the right format (so tank containing 7.0 light
                        ; years of fuel would be 14.0 Cr, or a PRXS value of
                        ; 140)

 LDX #1                 ; We are now going to work our way through the equipment
                        ; price list at PRXS, printing out the equipment that is
                        ; available at this station, so set a counter in X,
                        ; starting at 1, to hold the number of the current item
                        ; plus 1 (so the item number in X loops through 1-13)

.EQL1

 STX XX13               ; Store the current item number + 1 in XX13

 JSR TT67               ; Print a newline

 LDX XX13               ; Print the current item number + 1 to 3 digits, left-
 CLC                    ; padding with spaces, and with no decimal point, so the
 JSR pr2                ; items are numbered from 1

 JSR TT162              ; Print a space

 LDA XX13               ; Print recursive token 104 + XX13, which will be in the
 CLC                    ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
 ADC #104               ; so this prints the current item's name
 JSR TT27

 LDA XX13               ; Call prx-3 to set (Y X) to the price of the item with
 JSR prx-3              ; number XX13 - 1 (as XX13 contains the item number + 1)

 SEC                    ; Set the C flag so we will print a decimal point when
                        ; we print the price

 LDA #25                ; Move the text cursor to column 25
 JSR DOXC

 LDA #6                 ; Print the number in (Y X) to 6 digits, left-padding
 JSR TT11               ; with spaces and including a decimal point, which will
                        ; be the correct price for this item as (Y X) contains
                        ; the price * 10, so the trailing zero will go after the
                        ; decimal point (i.e. 5250 will be printed as 525.0)

 LDX XX13               ; Increment the current item number in XX13
 INX

 CPX Q                  ; If X < Q, loop back up to print the next item on the
 BCC EQL1               ; list of equipment available at this station

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #127               ; Print recursive token 127 ("ITEM") followed by a
 JSR prq                ; question mark

 JSR gnum               ; Call gnum to get a number from the keyboard, which
                        ; will be the number of the item we want to purchase,
                        ; returning the number entered in A and R, and setting
                        ; the C flag if the number is bigger than the highest
                        ; item number in QQ25

 BEQ bay                ; If no number was entered, jump up to bay to go to the
                        ; docking bay (i.e. show the Status Mode screen)

 BCS bay                ; If the number entered was too big, jump up to bay to
                        ; go to the docking bay (i.e. show the Status Mode
                        ; screen)

 SBC #0                 ; Set A to the number entered - 1 (because the C flag is
                        ; clear), which will be the actual item number we want
                        ; to buy

 PHA                    ; Store A on the stack so we can restore it after the
                        ; following call to DOXC

 LDA #2                 ; Move the text cursor to column 2
 JSR DOXC

 JSR INCYC              ; Move the text cursor down one line

 PLA                    ; Restore A from the stack

 PHA                    ; While preserving the value in A, call eq to subtract
 JSR eq                 ; the price of the item we want to buy (which is in A)
 PLA                    ; from our cash pot, but only if we have enough cash in
                        ; the pot. If we don't have enough cash, exit to the
                        ; docking bay (i.e. show the Status Mode screen)

 BNE et0                ; If A is not 0 (i.e. the item we've just bought is not
                        ; fuel), skip to et0

 LDX #70                ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
 STX QQ14               ; light years (a full tank)

.et0

 CMP #1                 ; If A is not 1 (i.e. the item we've just bought is not
 BNE et1                ; a missile), skip to et1

 LDX NOMSL              ; Fetch the current number of missiles from NOMSL into X

 INX                    ; Increment X to the new number of missiles

 LDY #124               ; Set Y to recursive token 124 ("ALL")

 CPX #5                 ; If buying this missile would give us 5 missiles, this
 BCS pres               ; is more than the maximum of 4 missiles that we can
                        ; fit, so jump to pres to show the error "All Present",
                        ; beep and exit to the docking bay (i.e. show the Status
                        ; Mode screen)

 STX NOMSL              ; Otherwise update the number of missiles in NOMSL

 JSR msblob             ; Reset the dashboard's missile indicators so none of
                        ; them are targeted

 LDA #1                 ; Set A to 1 as the call to msblob will have overwritten
                        ; the original value, and we still need it set
                        ; correctly so we can continue through the conditional
                        ; statements for all the other equipment

.et1

 LDY #107               ; Set Y to recursive token 107 ("LARGE CARGO{sentence
                        ; case} BAY")

 CMP #2                 ; If A is not 2 (i.e. the item we've just bought is not
 BNE et2                ; a large cargo bay), skip to et2

 LDX #37                ; If our current cargo capacity in CRGO is 37, then we
 CPX CRGO               ; already have a large cargo bay fitted, so jump to pres
 BEQ pres               ; to show the error "Large Cargo Bay Present", beep and
                        ; exit to the docking bay (i.e. show the Status Mode
                        ; screen)

 STX CRGO               ; Otherwise we just scored ourselves a large cargo bay,
                        ; so update our current cargo capacity in CRGO to 37

.et2

 CMP #3                 ; If A is not 3 (i.e. the item we've just bought is not
 BNE et3                ; an E.C.M. system), skip to et3

 INY                    ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")

 LDX ECM                ; If we already have an E.C.M. fitted (i.e. ECM is
 BNE pres               ; non-zero), jump to pres to show the error "E.C.M.
                        ; System Present", beep and exit to the docking bay
                        ; (i.e. show the Status Mode screen)

 DEC ECM                ; Otherwise we just took delivery of a brand new E.C.M.
                        ; system, so set ECM to $FF (as ECM was 0 before the DEC
                        ; instruction)

.et3

 CMP #4                 ; If A is not 4 (i.e. the item we've just bought is not
 BNE et4                ; an extra pulse laser), skip to et4

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #POW               ; Call refund with A set to the power of the new pulse
 JSR refund             ; laser to install the new laser and process a refund if
                        ; we already have a laser fitted to this view

 LDA #4                 ; Set A to 4 as we just overwrote the original value,
                        ; and we still need it set correctly so we can continue
                        ; through the conditional statements for all the other
                        ; equipment

.et4

 CMP #5                 ; If A is not 5 (i.e. the item we've just bought is not
 BNE et5                ; an extra beam laser), skip to et5

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #POW+128           ; Call refund with A set to the power of the new beam
 JSR refund             ; laser to install the new laser and process a refund if
                        ; we already have a laser fitted to this view

.et5

 LDY #111               ; Set Y to recursive token 107 ("FUEL SCOOPS")

 CMP #6                 ; If A is not 6 (i.e. the item we've just bought is not
 BNE et6                ; a fuel scoop), skip to et6

 LDX BST                ; If we already have fuel scoops fitted (i.e. BST is
 BEQ ed9                ; zero), jump to ed9, otherwise fall through into pres
                        ; to show the error "Fuel Scoops Present", beep and
                        ; exit to the docking bay (i.e. show the Status Mode
                        ; screen)

.pres

                        ; If we get here we need to show an error to say that
                        ; the item whose name is in recursive token Y is already
                        ; present, and then process a refund for the cost of
                        ; item number A

 STY K                  ; Store the item's name in K

 JSR prx                ; Call prx to set (Y X) to the price of equipment item
                        ; number A

 JSR MCASH              ; Add (Y X) cash to the cash pot in CASH, as the station
                        ; already took the money for this item in the JSR eq
                        ; instruction above, but we can't fit the item, so need
                        ; our money back

 LDA K                  ; Print the recursive token in K (the item's name)
 JSR spc                ; followed by a space

 LDA #31                ; Print recursive token 145 ("PRESENT")
 JSR TT27

.err

 JSR dn2                ; Call dn2 to make a short, high beep and delay for 1
                        ; second

 JMP BAY                ; Jump to BAY to go to the docking bay (i.e. show the
                        ; Status Mode screen)

.ed9

 DEC BST                ; We just bought a shiny new fuel scoop, so set BST to
                        ; $FF (as BST was 0 before the jump to ed9 above)

.et6

 INY                    ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")

 CMP #7                 ; If A is not 7 (i.e. the item we've just bought is not
 BNE et7                ; an escape pod), skip to et7

 LDX ESCP               ; If we already have an escape pod fitted (i.e. ESCP is
 BNE pres               ; non-zero), jump to pres to show the error "Escape Pod
                        ; Present", beep and exit to the docking bay (i.e. show
                        ; the Status Mode screen)

 DEC ESCP               ; Otherwise we just bought an escape pod, so set ESCP
                        ; to $FF (as ESCP was 0 before the DEC instruction)

.et7

 INY                    ; Increment Y to recursive token 113 ("ENERGY BOMB")

 CMP #8                 ; If A is not 8 (i.e. the item we've just bought is not
 BNE et8                ; an energy bomb), skip to et8

 LDX BOMB               ; If we already have an energy bomb fitted (i.e. BOMB
 BNE pres               ; is non-zero), jump to pres to show the error "Energy
                        ; Bomb Present", beep and exit to the docking bay (i.e.
                        ; show the Status Mode screen)

 LDX #$7F               ; Otherwise we just bought an energy bomb, so set BOMB
 STX BOMB               ; to $7F

.et8

 INY                    ; Increment Y to recursive token 114 ("ENERGY UNIT")

 CMP #9                 ; If A is not 9 (i.e. the item we've just bought is not
 BNE etA                ; an energy unit), skip to etA

 LDX ENGY               ; If we already have an energy unit fitted (i.e. ENGY is
 BNE pres               ; non-zero), jump to pres to show the error "Energy Unit
                        ; Present", beep and exit to the docking bay (i.e. show
                        ; the Status Mode screen)

 INC ENGY               ; Otherwise we just picked up an energy unit, so set
                        ; ENGY to 1 (as ENGY was 0 before the INC instruction)

.etA

 INY                    ; Increment Y to recursive token 115 ("DOCKING
                        ; COMPUTERS")

 CMP #10                ; If A is not 10 (i.e. the item we've just bought is not
 BNE etB                ; a docking computer), skip to etB

 LDX DKCMP              ; If we already have a docking computer fitted (i.e.
 BNE pres               ; DKCMP is non-zero), jump to pres to show the error
                        ; "Docking Computer Present", beep and exit to the
                        ; docking bay (i.e. show the Status Mode screen)

 DEC DKCMP              ; Otherwise we just got hold of a docking computer, so
                        ; set DKCMP to $FF (as DKCMP was 0 before the DEC
                        ; instruction)

.etB

 INY                    ; Increment Y to recursive token 116 ("GALACTIC
                        ; HYPERSPACE ")

 CMP #11                ; If A is not 11 (i.e. the item we've just bought is not
 BNE et9                ; a galactic hyperdrive), skip to et9

 LDX GHYP               ; If we already have a galactic hyperdrive fitted (i.e.
 BNE pres               ; GHYP is non-zero), jump to pres to show the error
                        ; "Galactic Hyperspace Present", beep and exit to the
                        ; docking bay (i.e. show the Status Mode screen)

 DEC GHYP               ; Otherwise we just splashed out on a galactic
                        ; hyperdrive, so set GHYP to $FF (as GHYP was 0 before
                        ; the DEC instruction)

.et9

 INY                    ; Increment Y to recursive token 117 ("MILITARY  LASER")

 CMP #12                ; If A is not 12 (i.e. the item we've just bought is not
 BNE et10               ; a military laser), skip to et10

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #Armlas            ; Call refund with A set to the power of the new
 JSR refund             ; military laser to install the new laser and process a
                        ; refund if we already have a laser fitted to this view

.et10

 INY                    ; Increment Y to recursive token 118 ("MINING  LASER")

 CMP #13                ; If A is not 13 (i.e. the item we've just bought is not
 BNE et11               ; a mining laser), skip to et11

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #Mlas              ; Call refund with A set to the power of the new mining
 JSR refund             ; laser to install the new laser and process a refund if
                        ; we already have a laser fitted to this view

.et11

 JSR dn                 ; We are done buying equipment, so print the amount of
                        ; cash left in the cash pot, then make a short, high
                        ; beep to confirm the purchase, and delay for 1 second

 JMP EQSHP              ; Jump back up to EQSHP to show the Equip Ship screen
                        ; again and see if we can't track down another bargain

; ******************************************************************************
;
;       Name: dn
;       Type: Subroutine
;   Category: Market
;    Summary: Print the amount of money we have left in the cash pot, then make
;             a short, high beep and delay for 1 second
;
; ******************************************************************************

.dn

 JSR TT162              ; Print a space

 LDA #119               ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
 JSR spc                ; followed by a space

                        ; Fall through into dn2 to make a beep and delay for
                        ; 1 second before returning from the subroutine

; ******************************************************************************
;
;       Name: dn2
;       Type: Subroutine
;   Category: Text
;    Summary: Make a short, high beep and delay for 1 second
;
; ******************************************************************************

.dn2

 JSR BEEP               ; Call the BEEP subroutine to make a short, high beep

 LDY #50                ; Delay for 50 vertical syncs (50/50 = 1 second) and
 JMP DELAY              ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: eq
;       Type: Subroutine
;   Category: Equipment
;    Summary: Subtract the price of equipment from the cash pot
;
; ------------------------------------------------------------------------------
;
; If we have enough cash, subtract the price of a specified piece of equipment
; from our cash pot and return from the subroutine. If we don't have enough
; cash, exit to the docking bay (i.e. show the Status Mode screen).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The item number of the piece of equipment (0-11) as
;                       shown in the table at PRXS
;
; ******************************************************************************

.eq

 JSR prx                ; Call prx to set (Y X) to the price of equipment item
                        ; number A

 JSR LCASH              ; Subtract (Y X) cash from the cash pot, but only if
                        ; we have enough cash

 BCS c                  ; If the C flag is set then we did have enough cash for
                        ; the transaction, so jump to c to return from the
                        ; subroutine (as c contains an RTS)

 LDA #197               ; Otherwise we don't have enough cash to buy this piece
 JSR prq                ; of equipment, so print recursive token 37 ("CASH")
                        ; followed by a question mark

 JMP err                ; Jump to err to beep, pause and go to the docking bay
                        ; (i.e. show the Status Mode screen)

; ******************************************************************************
;
;       Name: prx
;       Type: Subroutine
;   Category: Equipment
;    Summary: Return the price of a piece of equipment
;
; ------------------------------------------------------------------------------
;
; This routine returns the price of equipment as listed in the table at PRXS.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The item number of the piece of equipment (0-13) as
;                       shown in the table at PRXS
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   prx-3               Return the price of the item with number A - 1
;
;   c                   Contains an RTS
;
; ******************************************************************************

 SEC                    ; Decrement A (for when this routine is called via
 SBC #1                 ; prx-3)

.prx

 ASL A                  ; Set Y = A * 2, so it can act as an index into the
 TAY                    ; PRXS table, which has two bytes per entry

 LDX PRXS,Y             ; Fetch the low byte of the price into X

 LDA PRXS+1,Y           ; Fetch the high byte of the price into A and transfer
 TAY                    ; it to X, so the price is now in (Y X)

.c

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: qv
;       Type: Subroutine
;   Category: Equipment
;    Summary: Print a menu of the four space views, for buying lasers
;
; ------------------------------------------------------------------------------
;
; Print a menu in the bottom-middle of the screen, at row 16, column 12, that
; lists the four available space views, like this:
;
;                 0 Front
;                 1 Rear
;                 2 Left
;                 3 Right
;
; Also print a "View ?" prompt and ask for a view number. The menu is shown
; when we choose to buy a new laser in the Equip Ship screen.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   The chosen view number (0-3)
;
; ******************************************************************************

.qv

 LDA tek                ; If the current system's tech level is less than 8,
 CMP #8                 ; skip the next two instructions, otherwise we clear the
 BCC P%+7               ; screen to prevent the view menu from clashing with the
                        ; longer equipment menu available in higher tech systems

 LDA #32                ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 32 (Equip
                        ; Ship screen)

 LDA #16                ; Move the text cursor to row 16, and at the same time
 TAY                    ; set Y to a counter going from 16 to 19 in the loop
 JSR DOYC               ; below

.qv1

 LDA #12                ; Move the text cursor to column 12
 JSR DOXC

 TYA                    ; Transfer the counter value from Y to A

 CLC                    ; Print ASCII character "0" - 16 + A, so as A goes from
 ADC #'0'-16            ; 16 to 19, this prints "0" through "3" followed by a
 JSR spc                ; space

 LDA YC                 ; Print recursive text token 80 + YC, so as YC goes from
 CLC                    ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
 ADC #80                ; "RIGHT"
 JSR TT27

 JSR INCYC              ; Move the text cursor down a row, and increment the
                        ; counter in YC at the same time

 LDY YC                 ; Update Y with the incremented counter in YC

 CPY #20                ; If Y < 20 then loop back up to qv1 to print the next
 BCC qv1                ; view in the menu

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

.qv2

 LDA #175               ; Print recursive text token 15 ("VIEW ") followed by
 JSR prq                ; a question mark

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A (and X)

 SEC                    ; Subtract ASCII "0" from the key pressed, to leave the
 SBC #'0'               ; numeric value of the key in A (if it was a number key)

 CMP #4                 ; If the number entered in A < 4, then it is a valid
 BCC qv3                ; view number, so jump down to qv3 as we are done

 JSR CLYNS              ; Otherwise we didn't get a valid view number, so clear
                        ; the bottom three text rows of the upper screen, and
                        ; move the text cursor to column 1 on row 21

 JMP qv2                ; Jump back to qv2 to try again

.qv3

 TAX                    ; We have a valid view number, so transfer it to X

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: hm
;       Type: Subroutine
;   Category: Charts
;    Summary: Select the closest system and redraw the chart crosshairs
;
; ------------------------------------------------------------------------------
;
; Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
; system, redraw the crosshairs on the chart accordingly (if they are being
; shown), and, if this is not a space view, clear the bottom three text rows of
; the screen.
;
; ******************************************************************************

.hm

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will erase the crosshairs currently there

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will draw the crosshairs at our current home
                        ; system

 JMP CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

                        ; Return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: refund
;       Type: Subroutine
;   Category: Equipment
;    Summary: Install a new laser, processing a refund if applicable
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The power of the new laser to be fitted
;
;   X                   The view number for fitting the new laser (0-3)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A is preserved
;
;   X                   X is preserved
;
; ******************************************************************************

;.ref2                  ; These instructions are commented out in the original
;LDY #187               ; source, but they would jump to pres in the EQSHP
;JMP pres               ; routine with Y = 187, which would show the error:
;Belgium                ; "LASER PRESENT" (this code was part of the refund
                        ; bug in the disc version of Elite, which is why it is
                        ; commented out)
                        ;
                        ; There is also a comment in the original source - the
                        ; solitary word "Belgium"
                        ;
                        ; This is presumably a reference to the Hitchhiker's
                        ; Guide to the Galaxy, which says that Belgium is the
                        ; galaxy's most unspeakably rude word, so this no doubt
                        ; reflects the authors' strong feelings on the refund
                        ; bug

.refund

 STA T1                 ; Store A in T1 so we can retrieve it later

 LDA LASER,X            ; If there is no laser in view X (i.e. the laser power
 BEQ ref3               ; is zero), jump to ref3 to skip the refund code

;CMP T1                 ; These instructions are commented out in the original
;BEQ ref2               ; source, but they would jump to ref2 above if we were
                        ; trying to replace a laser with one of the same type
                        ; (this code was part of the refund bug in the disc
                        ; version of Elite, which is why it is commented out)

 LDY #4                 ; If the current laser has power #POW (pulse laser),
 CMP #POW               ; jump to ref1 with Y = 4 (the item number of a pulse
 BEQ ref1               ; laser in the table at PRXS)

 LDY #5                 ; If the current laser has power #POW+128 (beam laser),
 CMP #POW+128           ; jump to ref1 with Y = 5 (the item number of a beam
 BEQ ref1               ; laser in the table at PRXS)

 LDY #12                ; If the current laser has power #Armlas (military
 CMP #Armlas            ; laser), jump to ref1 with Y = 12 (the item number of a
 BEQ ref1               ; military laser in the table at PRXS)

 LDY #13                ; Otherwise this is a mining laser, so fall through into
                        ; ref1 with Y = 13 (the item number of a mining laser in
                        ; the table at PRXS)

.ref1

                        ; We now want to refund the laser of type Y that we are
                        ; exchanging for the new laser

 STX ZZ                 ; Store the view number in ZZ so we can retrieve it
                        ; later

 TYA                    ; Copy the laser type to be refunded from Y to A

 JSR prx                ; Call prx to set (Y X) to the price of equipment item
                        ; number A

 JSR MCASH              ; Call MCASH to add (Y X) to the cash pot

 LDX ZZ                 ; Retrieve the view number from ZZ

.ref3

                        ; Finally, we install the new laser

 LDA T1                 ; Retrieve the new laser's power from T1 into A

 STA LASER,X            ; Set the laser view to the new laser's power

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: PRXS
;       Type: Variable
;   Category: Equipment
;    Summary: Equipment prices
;
; ------------------------------------------------------------------------------
;
; Equipment prices are stored as 10 * the actual value, so we can support prices
; with fractions of credits (0.1 Cr). This is used for the price of fuel only.
;
; ******************************************************************************

.PRXS

 EQUW 1                 ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
 EQUW 300               ; 1  Missile                     30.0 Cr
 EQUW 4000              ; 2  Large Cargo Bay            400.0 Cr
 EQUW 6000              ; 3  E.C.M. System              600.0 Cr
 EQUW 4000              ; 4  Extra Pulse Lasers         400.0 Cr
 EQUW 10000             ; 5  Extra Beam Lasers         1000.0 Cr
 EQUW 5250              ; 6  Fuel Scoops                525.0 Cr
 EQUW 10000             ; 7  Escape Pod                1000.0 Cr
 EQUW 9000              ; 8  Energy Bomb                900.0 Cr
 EQUW 15000             ; 9  Energy Unit               1500.0 Cr
 EQUW 10000             ; 10 Docking Computer          1000.0 Cr
 EQUW 50000             ; 11 Galactic Hyperspace       5000.0 Cr
 EQUW 60000             ; 12 Extra Military Lasers     6000.0 Cr
 EQUW 8000              ; 13 Extra Mining Lasers        800.0 Cr

; ******************************************************************************
;
; Save ELTD.bin
;
; ******************************************************************************

 PRINT "ELITE D"
 PRINT "Assembled at ", ~CODE_D%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_D%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_D%

 PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
 SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%

; ******************************************************************************
;
; ELITE E FILE
;
; Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_E% = P%

 LOAD_E% = LOAD% + P% - CODE%

; ******************************************************************************
;
;       Name: cpl
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the selected system name
;  Deep dive: Generating system names
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Print control code 3 (the selected system name, i.e. the one in the crosshairs
; in the Short-range Chart).
;
; ******************************************************************************

.cpl

 LDX #5                 ; First we need to back up the seeds in QQ15, so set up
                        ; a counter in X to cover three 16-bit seeds (i.e.
                        ; 6 bytes)

.TT53

 LDA QQ15,X             ; Copy byte X from QQ15 to QQ19
 STA QQ19,X

 DEX                    ; Decrement the loop counter

 BPL TT53               ; Loop back for the next byte to back up

 LDY #3                 ; Step 1: Now that the seeds are backed up, we can
                        ; start the name-generation process. We will either
                        ; need to loop three or four times, so for now set
                        ; up a counter in Y to loop four times

 BIT QQ15               ; Check bit 6 of s0_lo, which is stored in QQ15

 BVS P%+3               ; If bit 6 is set then skip over the next instruction

 DEY                    ; Bit 6 is clear, so we only want to loop three times,
                        ; so decrement the loop counter in Y

 STY T                  ; Store the loop counter in T

.TT55

 LDA QQ15+5             ; Step 2: Load s2_hi, which is stored in QQ15+5, and
 AND #%00011111         ; extract bits 0-4 by AND'ing with %11111

 BEQ P%+7               ; If all those bits are zero, then skip the following
                        ; two instructions to go to step 3

 ORA #%10000000         ; We now have a number in the range 1-31, which we can
                        ; easily convert into a two-letter token, but first we
                        ; need to add 128 (or set bit 7) to get a range of
                        ; 129-159

 JSR TT27               ; Print the two-letter token in A

 JSR TT54               ; Step 3: twist the seeds in QQ15

 DEC T                  ; Decrement the loop counter

 BPL TT55               ; Loop back for the next two letters

 LDX #5                 ; We have printed the system name, so we can now
                        ; restore the seeds we backed up earlier. Set up a
                        ; counter in X to cover three 16-bit seeds (i.e. 6
                        ; bytes)

.TT56

 LDA QQ19,X             ; Copy byte X from QQ19 to QQ15
 STA QQ15,X

 DEX                    ; Decrement the loop counter

 BPL TT56               ; Loop back for the next byte to restore

 RTS                    ; Once all the seeds are restored, return from the
                        ; subroutine

.cmn

 LDY #0

.QUL4

 LDA NAME,Y
 CMP #13
 BEQ ypl-1
 JSR TT26
 INY
 BNE QUL4
 RTS

.ypl

 BIT MJ
 BMI ypl16
 JSR TT62
 JSR cpl

.TT62

 LDX #5

.TT78

 LDA QQ15,X
 LDY QQ2,X
 STA QQ2,X
 STY QQ15,X
 DEX
 BPL TT78

.ypl16

 RTS

.tal

 CLC
 LDX GCNT
 INX
 JMP pr2

.fwl

 LDA #105
 JSR TT68
 LDX QQ14
 SEC
 JSR pr2
 LDA #195
 JSR plf

.PCASH

 LDA #119
 BNE TT27

.csh

 LDX #3

.pc1

 LDA CASH,X
 STA K,X
 DEX
 BPL pc1
 LDA #9
 STA U
 SEC
 JSR BPRNT
 LDA #226

.plf

 JSR TT27
 JMP TT67

.TT68

 JSR TT27

.TT73

 LDA #$3A

.TT27

 TAX
 BEQ csh
 BMI TT43
 DEX
 BEQ tal
 DEX
 BEQ ypl
 dex
 bne P%+5
 JMP cpl
 dex
 beq cmn
 dex
 beq fwl
 dex
 bne P%+7
 LDA #128
 STA QQ17
 RTS
 DEX
 DEX
 BNE P%+5
 STX QQ17
 RTS
 dex
 beq crlf
 CMP #$60
 BCS ex
 CMP #14
 BCC P%+6
 CMP #32
 BCC qw
 LDX QQ17
 BEQ TT74
 BMI TT41
 BIT QQ17
 BVS TT46

.TT42

 CMP #65
 BCC TT44
 CMP #$5B
 BCS TT44
 ADC #32

.TT44

 JMP TT26

.TT41

 BIT QQ17
 BVS TT45
 CMP #65
 BCC TT74
 PHA
 TXA
 ORA #64
 STA QQ17
 PLA
 BNE TT44

.qw

 ADC #114
 BNE ex

.crlf

 LDA #21
 JSR DOXC
 JMP TT73

.TT45

 CPX #$FF
 BEQ TT48
 CMP #65
 BCS TT42

.TT46

 PHA
 TXA
 AND #191
 STA QQ17
 PLA

.TT74

 JMP TT26

.TT43

 CMP #160
 BCS TT47
 AND #127
 ASL A
 TAY
 LDA QQ16,Y
 JSR TT27
 LDA QQ16+1,Y
 CMP #63
 BEQ TT48
 JMP TT27

.TT47

 SBC #160

.ex

 TAX
 LDA #(QQ18 MOD 256)
 STA V
 LDA #(QQ18 DIV 256)
 STA V+1
 LDY #0
 TXA
 BEQ TT50

.TT51

 LDA (V),Y
 BEQ TT49
 INY
 BNE TT51
 INC V+1
 BNE TT51

.TT49

 INY
 BNE TT59
 INC V+1

.TT59

 DEX
 BNE TT51

.TT50

 TYA
 PHA
 LDA V+1
 PHA
 LDA (V),Y
 EOR #35
 JSR TT27
 PLA
 STA V+1
 PLA
 TAY
 INY
 BNE P%+4
 INC V+1
 LDA (V),Y
 BNE TT50

.TT48

 RTS

IF _GMA85_NTSC OR _GMA86_PAL

.SWAPPZERO

 LDX #K3+1

.SWPZL

 LDA 0,X
 LDY $CE00,X
 STA $CE00,X
 STY 0,X
 INX
 BNE SWPZL
 RTS

ENDIF

.EX2

 LDA INWK+31
 ORA #$A0
 STA INWK+31
 RTS

.DOEXP

 LDA INWK+31
 AND #64
 BEQ P%+5
 JSR PTCLS
 LDA INWK+6
 STA T
 LDA INWK+7
 CMP #$20
 BCC P%+6
 LDA #$FE
 BNE yy
 ASL T
 ROL A
 ASL T
 ROL A
 SEC
 ROL A

.yy

 STA Q
 LDY #1
 LDA (XX19),Y
 STA frump
 ADC #4
 BCS EX2
 STA (XX19),Y
 JSR DVID4
 LDA P
 CMP #$1C
 BCC P%+6
 LDA #$FE
 BNE LABEL_1
 ASL R
 ROL A
 ASL R
 ROL A
 ASL R
 ROL A

.LABEL_1

 DEY
 STA (XX19),Y
 LDA INWK+31
 AND #$BF
 STA INWK+31
 AND #8
 BEQ TT48
 LDY #2
 LDA (XX19),Y
 TAY

.EXL1

 LDA XX3-7,Y
 STA (XX19),Y
 DEY
 CPY #6
 BNE EXL1
 LDA INWK+31
 ORA #64
 STA INWK+31
 LDY frump
 CPY #18
 BNE P%+5
 JMP PTCLS2S

.PTCLS

 LDY #0
 LDA (XX19),Y
 STA Q
 INY
 LDA (XX19),Y
 BPL P%+4
 EOR #$FF
 LSR A
 LSR A
 LSR A
 LSR A
 ORA #1
 STA U
 INY
 LDA (XX19),Y
 STA TGT
 LDA RAND+1
 PHA
 LDY #6

.EXL5

 LDX #3

.EXL3

 INY
 LDA (XX19),Y
 STA K3,X
 DEX
 BPL EXL3
 STY CNT
 LDY #2

.EXL2

 INY
 LDA (XX19),Y
 EOR CNT
 STA $FFFF,Y
 CPY #6
 BNE EXL2
 LDY U

.EXL4 

; OPT  FNdornd2

 CLC
 LDA RAND
 ROL A
 TAX
 ADC RAND+2
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3

;end

 STA ZZ
 LDA K3+1
 STA R
 LDA K3
 JSR EXS1
 BNE EX11
 CPX #2*Y-1
 BCS EX11
 STX Y1
 LDA K3+3
 STA R
 LDA K3+2
 JSR EXS1
 BNE EX4
 LDA Y1
 JSR PIXEL

.EX4

 DEY
 BPL EXL4
 LDY CNT
 CPY TGT
 BCC EXL5
 PLA
 STA RAND+1
 LDA K%+6
 STA RAND+3
 RTS

.PTCLS2S

 JMP PTCLS2

.EX11

;OPT  FNdornd2

 CLC
 LDA RAND
 ROL A
 TAX
 ADC RAND+2
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3

;end

 \<BS>
 JMP EX4

.EXS1

 STA S
; OPT  FNdornd2

 CLC
 LDA RAND
 ROL A
 TAX
 ADC RAND+2
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3

;end

 ROL A
 BCS EX5
 JSR FMLTU
 ADC R
 TAX
 LDA S
 ADC #0
 RTS

.EX5

 JSR FMLTU
 STA T
 LDA R
 SBC T
 TAX
 LDA S
 SBC #0
 RTS

.exlook

 EQUB 0
 EQUB 2

.PTCLS2

 LDA #5
 JSR SETL1
 LDA INWK+7
 CMP #7
 LDA #$FD
 LDX #44
 LDY #40
 BCS noexpand
 LDA #$FF
 LDX #32
 LDY #30

.noexpand

 STA VIC+$17
 STA VIC+$1D
 STX sprx
 STY spry
 LDY #0
 LDA (XX19),Y
 STA Q
 INY
 LDA (XX19),Y
 BPL P%+4
 EOR #$FF
 LSR A
 LSR A
 LSR A
 LSR A
 ORA #1
 STA U
 INY
 LDA (XX19),Y
 STA TGT
 LDA RAND+1
 PHA
 LDY #6

.EXL52

 LDX #3

.EXL32

 INY
 LDA (XX19),Y
 STA K3,X
 DEX
 BPL EXL32
 STY CNT
 LDA K3+3
 CLC
 ADC sprx ;32
 STA SC
 LDA K3+2
 ADC #0
 BMI yonk
 CMP #2
 BCS yonk
 TAX
 LDA K3+1
 CLC
 ADC spry ;30
 TAY
 LDA K3
 ADC #0
 BNE yonk
 CPY #2*Y+50
 BCS yonk
 LDA VIC+$10
 AND #$FD
 ORA exlook,X
 STA VIC+$10
 LDX SC
 STY VIC+$3
 STX VIC+$2
 LDA VIC+$15
 ORA #2
 STA VIC+$15

.yonk

 LDY #2

.EXL22

 INY
 LDA (XX19),Y
 EOR CNT
 STA $FFFF,Y
 CPY #6
 BNE EXL22
 LDY U

.EXL42

 JSR DORND2
 STA ZZ
 LDA K3+1
 STA R
 LDA K3
 JSR EXS1
 BNE EX112
 CPX #2*Y-1
 BCS EX112
 STX Y1
 LDA K3+3
 STA R
 LDA K3+2
 JSR EXS1
 BNE EX42
 LDA Y1
 JSR PIXEL

.EX42

 DEY
 BPL EXL42
 LDY CNT
 CPY TGT
 BCS P%+5
 JMP EXL52
 PLA
 STA RAND+1
 LDA #4
 JSR SETL1
 LDA K%+6
 STA RAND+3
 RTS

.EX112

 JSR DORND2
 JMP EX42

.SOS1

 JSR msblob
 LDA #127
 STA INWK+29
 STA INWK+30
 LDA tek
 AND #2
 ORA #128
 JMP NWSHP

.SOLAR

 LDA TRIBBLE
 BEQ nobirths
 LDA #0
 STA QQ20
 STA QQ20+6 ;Eat food & Narc
 JSR DORND
 AND #15
 ADC TRIBBLE
 ORA #4
 ROL A
 STA TRIBBLE
 ROL TRIBBLE+1
 BPL nobirths
 ROR TRIBBLE+1

.nobirths

 LSR FIST
 JSR ZINF
 LDA QQ15+1
 AND #3
 ADC #3
 STA INWK+8
 ROR A
 STA INWK+2
 STA INWK+5
 JSR SOS1
 LDA QQ15+3
 AND #7
 ORA #129
 STA INWK+8
 LDA QQ15+5
 AND #3
 STA INWK+2
 STA INWK+1
 LDA #0
 STA INWK+29
 STA INWK+30
 LDA #$81
 JSR NWSHP

.NWSTARS

 LDA QQ11
;ORA MJ
 BNE WPSHPS

.nWq

 LDY NOSTM

.SAL4

 JSR DORND
 ORA #8
 STA SZ,Y
 STA ZZ
 JSR DORND
 STA SX,Y
 STA X1
 JSR DORND
 STA SY,Y
 STA Y1
 JSR PIXEL2
 DEY
 BNE SAL4
 \\JSRPBFL

.WPSHPS

 LDX #0

.WSL1

 LDA FRIN,X
 BEQ WS2
 BMI WS1
 STA TYPE
 JSR GINF
 LDY #31

.WSL2

 LDA (INF),Y
 STA INWK,Y
 DEY
 BPL WSL2
 STX XSAV
 JSR SCAN
 LDX XSAV
 LDY #31
 LDA (INF),Y
 AND #$A7
 STA (INF),Y

.WS1

 INX
 BNE WSL1

.WS2

 LDX #0
 STX LSP
 DEX
 STX LSX2
 STX LSY2

.FLFLLS

 LDY #199
 LDA #0

.SAL6

 STA LSO,Y
 DEY
 BNE SAL6
 DEY
 STY LSX
 RTS

.DET1

 RTS ;X is input-undraw dials
 DEX
 RTS

.SHD

 INX
 BEQ SHD-2

.DENGY

 DEC ENERGY
 PHP
 BNE P%+5
 INC ENERGY
 PLP
 RTS

.COMPAS

 JSR DOT
 LDA SSPR
 BNE SP1
 JSR SPS1
 JMP SP2

.SPS2

 ASL A
 TAX
 LDA #0
 ROR A
 TAY
 LDA #20 ;14
 STA Q
 TXA
 JSR DVID4
 LDX P
 TYA
 BMI LL163
 LDY #0
 RTS

.LL163

 LDY #$FF
 TXA
 EOR #$FF
 TAX
 INX
 RTS

.SPS4

 LDX #8

.SPL1

 LDA K%+NI%,X
 STA K3,X
 DEX
 BPL SPL1
 JMP TAS2

.SP1

 JSR SPS4

.SP2

 LDA XX15
 JSR SPS2
 TXA
 ADC #195 ; X-1
 STA COMX
 LDA XX15+1
 JSR SPS2
 STX T
 LDA #156 ;204
 SBC T
 STA COMY
 LDA #YELLOW
 LDX XX15+2
 BPL P%+4
 LDA #GREEN
 STA COMC
 JMP DOT

.OOPS

 STA T
 LDX #0
 LDY #8
 LDA (INF),Y
 BMI OO1
 LDA FSH
 SBC T
 BCC OO2
 STA FSH
 RTS

.OO2

 LDX #0
 STX FSH
 BCC OO3

.OO1

 LDA ASH
 SBC T
 BCC OO5
 STA ASH
 RTS

.OO5

 LDX #0
 STX ASH

.OO3

 ADC ENERGY
 STA ENERGY
 BEQ P%+4
 BCS P%+5
 JMP DEATH
 JSR EXNO3
 JMP OUCH

.SPS3

 LDA K%+1,X
 STA K3,X
 LDA K%+2,X
 TAY
 AND #127
 STA K3+1,X
 TYA
 AND #128
 STA K3+2,X
 RTS

.NWSPS

 JSR SPBLB
 LDX #$81
 STX INWK+32
 LDX #0
 STX INWK+30
 STX NEWB
;STX INWK+31
 STX FRIN+1
 DEX
 STX INWK+29
 LDX #10
 JSR NwS1
 JSR NwS1
 JSR NwS1
 LDA spasto
 STA XX21+2*SST-2
 LDA spasto+1
 STA XX21+2*SST-1
 LDA tek
 CMP #10
 BCC notadodo
 LDA XX21+2*DOD-2
 STA XX21+2*SST-2
 LDA XX21+2*DOD-1
 STA XX21+2*SST-1

.notadodo

 LDA #(LSO MOD 256)
 STA INWK+33
 LDA #(LSO DIV 256)
 STA INWK+34
 LDA #SST

.NWSHP

 STA T
 LDX #0

.NWL1

 LDA FRIN,X
 BEQ NW1
 INX
 CPX #NOSH
 BCC NWL1

.NW3

 CLC
 RTS

.NW1

 JSR GINF
 LDA T
 BMI NW2
 ASL A
 TAY
 LDA XX21-1,Y
 BEQ NW3
 STA XX0+1
 LDA XX21-2,Y
 STA XX0
 CPY #2*SST
 BEQ NW6
 LDY #5
 LDA (XX0),Y
 STA T1
 LDA SLSP
 SEC
 SBC T1
 STA INWK+33
 LDA SLSP+1
 SBC #0
 STA INWK+34
 LDA INWK+33
;SEC 
 SBC INF
 TAY
 LDA INWK+34
 SBC INF+1
 BCC NW3+1
 BNE NW4
 CPY #NI%
 BCC NW3+1

.NW4

 LDA INWK+33
 STA SLSP
 LDA INWK+34
 STA SLSP+1

.NW6

 LDY #14
 LDA (XX0),Y
 STA INWK+35
 LDY #19
 LDA (XX0),Y
 AND #7
 STA INWK+31
 LDA T

.NW2

 STA FRIN,X
 TAX
 BMI NW8
 CPX #HER
 BEQ gangbang
 CPX #JL
 BCC NW7
 CPX #JH
 BCS NW7

.gangbang

 INC JUNK

.NW7

 INC MANY,X

.NW8

 LDY T
 LDA E%-1,Y
 AND #$6F
 ORA NEWB
 STA NEWB
 LDY #NI%-1

.NWL3

 LDA INWK,Y
 STA (INF),Y
 DEY
 BPL NWL3
 SEC
 RTS

.NwS1

 LDA INWK,X
 EOR #128
 STA INWK,X
 INX
 INX
 RTS

.ABORT

 LDX #$FF

.ABORT2

 STX MSTG
 LDX NOMSL
 JSR MSBAR
 STY MSAR
 RTS

.msbpars

 EQUB 4
 EQUD 0

.PROJ

 LDA INWK
 STA P
 LDA INWK+1
 STA P+1
 LDA INWK+2
 JSR PLS6
 BCS PL2-1
 LDA K
 ADC #X
 STA K3
 TXA
 ADC #0
 STA K3+1
 LDA INWK+3
 STA P
 LDA INWK+4
 STA P+1
 LDA INWK+5
 EOR #128
 JSR PLS6
 BCS PL2-1
 LDA K
 ADC #Y
 STA K4
 TXA
 ADC #0
 STA K4+1
 CLC
 RTS

.PL2

 LDA TYPE
 LSR A
 BCS P%+5
 JMP WPLS2
 JMP WPLS

.PLANET

 LDA INWK+8
;BMI PL2
 CMP #48
 BCS PL2
 ORA INWK+7
 BEQ PL2
 JSR PROJ
 BCS PL2
 LDA #96
 STA P+1
 LDA #0
 STA P
 JSR DVID3B2
 LDA K+1
 BEQ PL82
 LDA #$F8
 STA K

.PL82

 LDA TYPE
 LSR A
 BCC PL9
 JMP SUN

.PL9

 JSR WPLS2
 JSR CIRCLE
 BCS PL20
 LDA K+1
 BEQ PL25

.PL20

 RTS

.PL25

 LDA PLTOG
 BEQ PL20 ;sob!
 LDA TYPE
 CMP #$80
 BNE PL26
 LDA K
 CMP #6
 BCC PL20
 LDA INWK+14
 EOR #128
 STA P
 LDA INWK+20
 JSR PLS4
 LDX #9
 JSR PLS1
 STA K2
 STY XX16
 JSR PLS1
 STA K2+1
 STY XX16+1
 LDX #15
 JSR PLS5
 JSR PLS2
 LDA INWK+14
 EOR #128
 STA P
 LDA INWK+26
 JSR PLS4
 LDX #21
 JSR PLS5
 JMP PLS2

.PL26 ; crtr 

 LDA INWK+20
 BMI PL20
 LDX #15
 JSR PLS3
 CLC
 ADC K3
 STA K3
 TYA
 ADC K3+1
 STA K3+1
 JSR PLS3
 STA P
 LDA K4
 SEC
 SBC P
 STA K4
 STY P
 LDA K4+1
 SBC P
 STA K4+1
 LDX #9
 JSR PLS1
 LSR A
 STA K2
 STY XX16
 JSR PLS1
 LSR A
 STA K2+1
 STY XX16+1
 LDX #21
 JSR PLS1
 LSR A
 STA K2+2
 STY XX16+2
 JSR PLS1
 LSR A
 STA K2+3
 STY XX16+3
 LDA #64
 STA TGT
 LDA #0
 STA CNT2
 JMP PLS22

.PLS1

 LDA INWK,X
 STA P
 LDA INWK+1,X
 AND #127
 STA P+1
 LDA INWK+1,X
 AND #128
 JSR DVID3B2
 LDA K
 LDY K+1
 BEQ P%+4
 LDA #$FE
 LDY K+3
 INX
 INX
 RTS

.PLS2

 LDA #31
 STA TGT

.PLS22

 LDX #0
 STX CNT
 DEX
 STX FLAG

.PLL4

 LDA CNT2
 AND #31
 TAX
 LDA SNE,X
 STA Q
 LDA K2+2
 JSR FMLTU
 STA R
 LDA K2+3
 JSR FMLTU
 STA K
 LDX CNT2
 CPX #33
 LDA #0
 ROR A
 STA XX16+5
 LDA CNT2
 CLC
 ADC #16
 AND #31
 TAX
 LDA SNE,X
 STA Q
 LDA K2+1
 JSR FMLTU
 STA K+2
 LDA K2
 JSR FMLTU
 STA P
 LDA CNT2
 ADC #15
 AND #63
 CMP #33
 LDA #0
 ROR A
 STA XX16+4
 LDA XX16+5
 EOR XX16+2
 STA S
 LDA XX16+4
 EOR XX16
 JSR ADD
 STA T
 BPL PL42
 TXA
 EOR #$FF
 CLC
 ADC #1
 TAX
 LDA T
 EOR #$7F
 ADC #0
 STA T

.PL42 

 TXA
 ADC K3
 STA K6
 LDA T
 ADC K3+1
 STA K6+1
 LDA K
 STA R
 LDA XX16+5
 EOR XX16+3
 STA S
 LDA K+2
 STA P
 LDA XX16+4
 EOR XX16+1
 JSR ADD
 EOR #128
 STA T
 BPL PL43
 TXA
 EOR #$FF
 CLC
 ADC #1
 TAX
 LDA T
 EOR #$7F
 ADC #0
 STA T

.PL43

 JSR BLINE
 CMP TGT
 BEQ P%+4
 BCS PL40
 LDA CNT2
 CLC
 ADC STP
 AND #63
 STA CNT2
 JMP PLL4

.PL40

 RTS

.PLF3M3

 JMP WPLS

.PLF3

 TXA
 EOR #$FF
 CLC
 ADC #1
 TAX

.PLF17

 LDA #$FF
 JMP PLF5

.SUN

 LDA #1
 STA LSX
 JSR CHKON
 BCS PLF3M3
 LDA #0
 LDX K
 CPX #$60
 ROL A
 CPX #$28
 ROL A
 CPX #$10
 ROL A

.PLF18

 STA CNT
 LDA Yx2M1
 LDX P+2
 BNE PLF2
 CMP P+1
 BCC PLF2
 LDA P+1
 BNE PLF2
 LDA #1

.PLF2

 STA TGT
 LDA Yx2M1
 SEC
 SBC K4
 TAX
 LDA #0
 SBC K4+1
 BMI PLF3
 BNE PLF4
 INX
 DEX
 BEQ PLF17
 CPX K
 BCC PLF5

.PLF4

 LDX K
 LDA #0

.PLF5

 STX V
 STA V+1
 LDA K
 JSR SQUA2
 STA K2+1
 LDA P
 STA K2
 LDY Yx2M1
 LDA SUNX
 STA YY
 LDA SUNX+1
 STA YY+1

.PLFL2

 CPY TGT
 BEQ PLFL
 LDA LSO,Y
 BEQ PLF13
 JSR HLOIN2

.PLF13

 DEY
 BNE PLFL2

.PLFL

 LDA V
 JSR SQUA2
 STA T
 LDA K2
 SEC
 SBC P
 STA Q
 LDA K2+1
 SBC T
 STA R
 STY Y1
 JSR LL5
 LDY Y1
 JSR DORND
 AND CNT
 CLC
 ADC Q
 BCC PLF44
 LDA #$FF

.PLF44

 LDX LSO,Y
 STA LSO,Y
 BEQ PLF11
 LDA SUNX
 STA YY
 LDA SUNX+1
 STA YY+1
 TXA
 JSR EDGES
 LDA X1
 STA XX
 LDA X2
 STA XX+1
 LDA K3
 STA YY
 LDA K3+1
 STA YY+1
 LDA LSO,Y
 JSR EDGES
 BCS PLF23
 LDA X2
 LDX XX
 STX X2
 STA XX
 JSR HLOIN

.PLF23

 LDA XX
 STA X1
 LDA XX+1
 STA X2

.PLF16

 JSR HLOIN

.PLF6

 DEY
 BEQ PLF8
 LDA V+1
 BNE PLF10
 DEC V
 BNE PLFL
 DEC V+1

.PLFLS

 JMP PLFL

.PLF11

 LDX K3
 STX YY
 LDX K3+1
 STX YY+1
 JSR EDGES
 BCC PLF16
 LDA #0
 STA LSO,Y
 BEQ PLF6

.PLF10

 LDX V
 INX
 STX V
 CPX K
 BCC PLFLS
 BEQ PLFLS
 LDA SUNX
 STA YY
 LDA SUNX+1
 STA YY+1

.PLFL3

 LDA LSO,Y
 BEQ PLF9
 JSR HLOIN2

.PLF9

 DEY
 BNE PLFL3

.PLF8

 CLC
 LDA K3
 STA SUNX
 LDA K3+1
 STA SUNX+1

.RTS2

 RTS

.CIRCLE

 JSR CHKON
 BCS RTS2
 LDA #0
 STA LSX2
 LDX K
 LDA #8
 CPX #8
 BCC PL89
 LSR A
 CPX #60
 BCC PL89
 LSR A

.PL89

 STA STP

.CIRCLE2

 LDX #$FF
 STX FLAG
 INX
 STX CNT

.PLL3

 LDA CNT
 JSR FMLTU2
 LDX #0
 STX T
 LDX CNT
 CPX #33
 BCC PL37
 EOR #$FF
 ADC #0
 TAX
 LDA #$FF
 ADC #0
 STA T
 TXA
 CLC

.PL37

 ADC K3
 STA K6
 LDA K3+1
 ADC T
 STA K6+1
 LDA CNT
 CLC
 ADC #16
 JSR FMLTU2
 TAX
 LDA #0
 STA T
 LDA CNT
 ADC #15
 AND #63
 CMP #33
 BCC PL38
 TXA
 EOR #$FF
 ADC #0
 TAX
 LDA #$FF
 ADC #0
 STA T
 CLC

.PL38

 JSR BLINE
 CMP #65
 BCS P%+5
 JMP PLL3
 CLC
 RTS

.WPLS2

 LDY LSX2
 BNE WP1

.WPL1

 CPY LSP
 BCS WP1
 LDA LSY2,Y
 CMP #$FF
 BEQ WP2
 STA Y2
 LDA LSX2,Y
 STA X2
 JSR LOIN
 INY
 LDA SWAP
 BNE WPL1
 LDA X2
 STA X1
 LDA Y2
 STA Y1
 JMP WPL1

.WP2

 INY
 LDA LSX2,Y
 STA X1
 LDA LSY2,Y
 STA Y1
 INY
 JMP WPL1

.WP1

 LDA #1
 STA LSP
 LDA #$FF
 STA LSX2
 RTS

.WPLS

 LDA LSX
 BMI WPLS-1
 LDA SUNX
 STA YY
 LDA SUNX+1
 STA YY+1
 LDY #2*Y-1

.WPL2

 LDA LSO,Y
 BEQ P%+5
 JSR HLOIN2
 DEY
 BNE WPL2
 DEY
 STY LSX
 RTS

.EDGES

 STA T
 CLC
 ADC YY
 STA X2
 LDA YY+1
 ADC #0
 BMI ED1
 BEQ P%+6
 LDA #$FF
 STA X2
 LDA YY
 SEC
 SBC T
 STA X1
 LDA YY+1
 SBC #0
 BNE ED3
 CLC
 RTS

.ED3

 BPL ED1
 LDA #0
 STA X1
 CLC
 RTS

.ED1

 LDA #0
 STA LSO,Y
 SEC
 RTS

.CHKON

 LDA K3
 CLC
 ADC K
 LDA K3+1
 ADC #0
 BMI PL21
 LDA K3
 SEC
 SBC K
 LDA K3+1
 SBC #0
 BMI PL31
 BNE PL21

.PL31

 LDA K4
 CLC
 ADC K
 STA P+1
 LDA K4+1
 ADC #0
 BMI PL21
 STA P+2
 LDA K4
 SEC
 SBC K
 TAX
 LDA K4+1
 SBC #0
 BMI PL44
 BNE PL21
 CPX Yx2M1
 RTS

.PL21

 SEC
 RTS

.PLS3

 JSR PLS1
 STA P
 LDA #222
 STA Q
 STX U
 JSR MULTU
 LDX U
 LDY K+3
 BPL PL12
 EOR #$FF
 CLC
 ADC #1
 BEQ PL12
 LDY #$FF
 RTS

.PL12

 LDY #0
 RTS

.PLS4

 STA Q
 JSR ARCTAN
 LDX INWK+14
 BMI P%+4
 EOR #128
 LSR A
 LSR A
 STA CNT2
 RTS

.PLS5

 JSR PLS1
 STA K2+2
 STY XX16+2
 JSR PLS1
 STA K2+3
 STY XX16+3
 RTS

.PLS6

 JSR DVID3B2
 LDA K+3
 AND #127
 ORA K+2
 BNE PL21
 LDX K+1
 CPX #4
 BCS PL6
 LDA K+3
;CLC 
 BPL PL6
 LDA K
 EOR #$FF
 ADC #1
 STA K
 TXA
 EOR #$FF
 ADC #0
 TAX

.PL44

 CLC

.PL6

 RTS

.YESNO

 JSR t
 CMP #'Y'
 BEQ PL6
 CMP #'N'
 BNE YESNO
 CLC
 RTS

.TT17

 LDA QQ11
 BNE TT17afterall
 JSR DOKEY
 TXA
 RTS

.TT17afterall

 JSR DOKEY
 LDA JSTK
 BEQ TJ1
 LDA KY3
 BIT KY4
 BPL P%+4
 LDA #1
 BIT KY7
 BPL P%+4
 ASL A
 ASL A
 TAX
 LDA KY5
 BIT KY6
 BPL P%+4
 LDA #1
 BIT KY7
 BPL P%+4
 ASL A
 ASL A
 TAY
 LDA #0
 STA KY3
 STA KY4
 STA KY5
 STA KY6
 STA KY7
 LDA thiskey
 RTS

.TJ1

 LDA KLO+$3E
 BEQ noxmove
 LDA #1
 ORA KLO+$31
 ORA KLO+$C

.noxmove

 BIT KLO+$3F
 BPL P%+4
 ASL A
 ASL A
 TAX
 LDA KLO+$39
 BEQ noymove
 LDA #1
 ORA KLO+$31
 ORA KLO+$C
 EOR #$FE

.noymove

 BIT KLO+$3F
 BPL P%+4
 ASL A
 ASL A
 TAY
 LDA thiskey
 RTS

; ******************************************************************************
;
; Save ELTE.bin
;
; ******************************************************************************

 PRINT "ELITE E"
 PRINT "Assembled at ", ~CODE_E%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_E%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_E%

 PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
 SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%

; ******************************************************************************
;
; ELITE F FILE
;
; Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_F% = P%

 LOAD_F% = LOAD% + P% - CODE%

IF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

.SWAPPZERO

 LDX #K3+1

.SWPZL

 LDA 0,X
 LDY $CE00,X
 STA $CE00,X
 STY 0,X
 INX
 BNE SWPZL
 RTS

ENDIF

.NOSPRITES

 LDA #5
 JSR SETL1
 LDA #0
 STA VIC+$15

IF NOT(USA%)

 LDA #PALCK

.UKCHK2

 BIT VIC+$11
 BPL UKCHK2
 CMP VIC+$12
 BNE UKCHK2 ;UK Machine?

ENDIF

 LDA #4

.SETL1

 SEI
 STA L1M
 LDA l1
 AND #$F8
 ORA L1M
 STA l1
 CLI
 RTS

.L1M

 EQUB 4

.KS3

 LDA P
 STA SLSP
 LDA P+1
 STA SLSP+1
 RTS

.KS1

 LDX XSAV
 JSR KILLSHP
 LDX XSAV
 JMP MAL1

.KS4

 JSR ZINF
 JSR FLFLLS
 STA FRIN+1
 STA SSPR
 JSR SPBLB
 LDA #6
 STA INWK+5
 LDA #$81
 JMP NWSHP

.KS2

 LDX #$FF

.KSL4

 INX
 LDA FRIN,X
 BEQ KS3
 CMP #MSL
 BNE KSL4
 TXA
 ASL A
 TAY
 LDA UNIV,Y
 STA SC
 LDA UNIV+1,Y
 STA SC+1
 LDY #32
 LDA (SC),Y
 BPL KSL4
 AND #$7F
 LSR A
 CMP XX4
 BCC KSL4
 BEQ KS6
 SBC #1
 ASL A
 ORA #128
 STA (SC),Y
 BNE KSL4

.KS6

 LDA #0
 STA (SC),Y
 BEQ KSL4

.KILLSHP

 STX XX4
 LDA MSTG
 CMP XX4
 BNE KS5
 LDY #GREEN2
 JSR ABORT
 LDA #200
 JSR MESS

.KS5

 LDY XX4
 LDX FRIN,Y
 CPX #SST
 BEQ KS4
 CPX #CON
 BNE lll
 LDA TP
 ORA #2
 STA TP
 INC TALLY+1  ; --BT

.lll

 CPX #HER
 BEQ blacksuspenders
 CPX #JL
 BCC KS7
 CPX #JH
 BCS KS7

.blacksuspenders

 DEC JUNK

.KS7

 DEC MANY,X
 LDX XX4
 LDY #5
 LDA (XX0),Y
 LDY #33
 CLC
 ADC (INF),Y
 STA P
 INY
 LDA (INF),Y
 ADC #0
 STA P+1

.KSL1

 INX
 LDA FRIN,X
 STA FRIN-1,X
 BNE P%+5
 JMP KS2
 ASL A
 TAY
 LDA XX21-2,Y
 STA SC
 LDA XX21-1,Y
 STA SC+1
 LDY #5
 LDA (SC),Y
 STA T
 LDA P
 SEC
 SBC T
 STA P
 LDA P+1
 SBC #0
 STA P+1
 TXA
 ASL A
 TAY
 LDA UNIV,Y
 STA SC
 LDA UNIV+1,Y
 STA SC+1
 LDY #36
 LDA (SC),Y
 STA (INF),Y
 DEY
 LDA (SC),Y
 STA (INF),Y
 DEY
 LDA (SC),Y
 STA K+1
 LDA P+1
 STA (INF),Y
 DEY
 LDA (SC),Y
 STA K
 LDA P
 STA (INF),Y
 DEY

.KSL2

;DEY 
 LDA (SC),Y
 STA (INF),Y
;TYA 
 DEY
 BPL KSL2
 LDA SC
 STA INF
 LDA SC+1
 STA INF+1
 LDY T

.KSL3

 DEY
 LDA (K),Y
 STA (P),Y
 TYA
 BNE KSL3
 BEQ KSL1

.THERE

 LDX GCNT
 DEX
 BNE THEX
 LDA QQ0
 CMP #144
 BNE THEX
 LDA QQ1
 CMP #33
 BEQ THEX+1

.THEX

 CLC
 RTS

.RESET

 JSR ZERO
 LDX #6

.SAL3

 STA BETA,X
 DEX
 BPL SAL3
 TXA
 STA QQ12
 LDX #2

.REL5

 STA FSH,X
 DEX
 BPL REL5

.RES2

 JSR stopbd
 LDA BOMB
 BPL BOMBOK
 JSR BOMBOFF
 STA BOMB

.BOMBOK

 LDA #NOST
 STA NOSTM
 LDX #$FF
 STX LSX2
 STX LSY2
 STX MSTG
 LDA #128
 STA JSTY
 STA ALP2
 STA BET2
 ASL A
 STA BETA
 STA BET1
 STA ALP2+1
 STA BET2+1
 STA MCNT
 STA TRIBCT
 LDA #3
 STA DELTA
 STA ALPHA
 STA ALP1
 LDA #$10
 STA COL2 ; <<
 LDA #0
 STA dontclip
 LDA #2*Y-1
 STA Yx2M1
 LDA SSPR
 BEQ P%+5
 JSR SPBLB
 LDA ECMA
 BEQ yu
 JSR ECMOF

.yu

 JSR WPSHPS
 JSR ZERO
 LDA #(LS%MOD 256)
 STA SLSP
 LDA #(LS%DIV 256)
 STA SLSP+1

.ZINF

 LDY #NI%-1
 LDA #0

.ZI1

 STA INWK,Y
 DEY
 BPL ZI1
 LDA #96
 STA INWK+18
 STA INWK+22
 ORA #128
 STA INWK+14
 RTS

.msblob

 LDX #4

.ss

 CPX NOMSL
 BEQ SAL8
 LDY #BLACK2
 JSR MSBAR
 DEX
 BNE ss
 RTS

.SAL8

 LDY #GREEN2
 JSR MSBAR
 DEX
 BNE SAL8
 RTS

.me2

 LDA QQ11
 BNE clynsneed
 LDA MCH
 JSR MESS
 LDA #0
 STA DLY
 JMP me3

.clynsneed

 JSR CLYNS
 JMP me3

.Ze

 JSR ZINF
 JSR DORND
 STA T1
 AND #128
 STA INWK+2
 TXA
 AND #128
 STA INWK+5
 LDA #25
 STA INWK+1
 STA INWK+4
 STA INWK+7
 TXA
 CMP #245
 ROL A
 ORA #$C0
 STA INWK+32

.DORND2

 CLC

.DORND

 LDA RAND
 ROL A
 TAX
 ADC RAND+2
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3
 RTS

.MTT4

 JSR DORND
 LSR A
 STA INWK+32
 STA INWK+29
 ROL INWK+31
 AND #31
 ORA #16
 STA INWK+27
 JSR DORND
 BMI nodo
 LDA INWK+32
 ORA #$C0
 STA INWK+32
 LDX #16
 STX NEWB

.nodo

 AND #2
 ADC #CYL
 CMP #HER
 BEQ TT100
 JSR NWSHP ; trader

.TT100 ; MLoop

 JSR M%
 DEC DLY
 BEQ me2
 BPL me3
 INC DLY

.me3

 DEC MCNT
 BEQ P%+5

.ytq

 JMP MLOOP
 LDA MJ
 BNE ytq
 JSR DORND
 CMP #35
 BCS MTT1
 LDA JUNK
 CMP #3
 BCS MTT1
 JSR ZINF
 LDA #38
 STA INWK+7
 JSR DORND
 STA INWK
 STX INWK+3
 AND #128
 STA INWK+2
 TXA
 AND #128
 STA INWK+5
 ROL INWK+1
 ROL INWK+1
 JSR DORND
 BVS MTT4
 ORA #$6F
 STA INWK+29
 LDA SSPR
 BNE MTT1
 TXA
 BCS MTT2
 AND #31
 ORA #16
 STA INWK+27
 BCC MTT3

.MTT2

 ORA #127
 STA INWK+30

.MTT3

 JSR DORND
 CMP #252
 BCC thongs
 LDA #HER
 STA INWK+32
 BNE whips

.thongs

 CMP #10
 AND #1
 ADC #OIL

.whips

 JSR NWSHP ;junk

.MTT1

 LDA SSPR
 BEQ P%+5

.MLOOPS

 JMP MLOOP
 JSR BAD
 ASL A
 LDX MANY+COPS
 BEQ P%+5
 ORA FIST
 STA T
 JSR Ze
 CMP #136
 BEQ fothg
 CMP T
 BCS P%+7
 LDA #COPS
 JSR NWSHP
 LDA MANY+COPS
 BNE MLOOPS
 DEC EV
 BPL MLOOPS
 INC EV
 LDA TP
 AND #$C
 CMP #8
 BNE nopl
 JSR DORND
 CMP #200
 BCC nopl

.fothg2

 JSR GTHG

.nopl

 JSR DORND
 LDY gov
 BEQ LABEL_2
 CMP #90
 BCS MLOOPS
 AND #7
 CMP gov
 BCC MLOOPS

.LABEL_2

 JSR Ze
 CMP #100
 BCS mt1
 INC EV
 AND #3
 ADC #CYL2
 TAY
 JSR THERE
 BCC NOCON
 LDA #$F9
 STA INWK+32
 LDA TP
 AND #3
 LSR A
 BCC NOCON
 ORA MANY+CON
 BEQ YESCON

.NOCON

 LDA #4
 STA NEWB
 JSR DORND
 CMP #200
 ROL A
 ORA #$C0
 STA INWK+32
 TYA
 EQUB $2C

.YESCON

 LDA #CON

.focoug

 JSR NWSHP

.mj1

 JMP MLOOP

.fothg

 LDA K%+6
 AND #$3E
 BNE fothg2
 LDA #18
 STA INWK+27
 LDA #$79
 STA INWK+32
 LDA #COU
 BNE focoug

.mt1

 AND #3
 STA EV
 STA XX13

.mt3

 JSR DORND
 STA T
 JSR DORND
 AND T
 AND #7
 ADC #PACK
 JSR NWSHP ;pack
 DEC XX13
 BPL mt3

.MLOOP

 LDX #$FF
 TXS
 LDX GNTMP
 BEQ EE20
 DEC GNTMP

.EE20

 LDX LASCT
 BEQ NOLASCT
 DEX
 BEQ P%+3
 DEX
 STX LASCT

.NOLASCT

 LDA QQ11
 BNE P%+5
 JSR DIALS
 LDA QQ11
 BEQ plus13

 AND PATG
 LSR A
 BCS plus13
 LDY #2
 JSR DELAY

.plus13

 LDA TRIBBLE+1
 BEQ nobabies
 JSR DORND
 CMP #220
 LDA TRIBBLE
 ADC #0
 STA TRIBBLE
 BCC nobabies
 INC TRIBBLE+1
 BPL nobabies
 DEC TRIBBLE+1

.nobabies

 \--BT
 LDA TRIBBLE+1
 BEQ NOSQUEEK
 STA T
 LDA CABTMP
 CMP #$E0
 BCS P%+4
 ASL T
 JSR DORND
 CMP T
 BCS NOSQUEEK
 JSR DORND
 ORA #$40
 TAX
 LDA #$80
 LDY CABTMP
 CPY #$E0
 BCC burnthebastards
 TXA
 AND #$F
 TAX
 LDA #$F1

.burnthebastards

 LDY #sfxtrib
 JSR NOISE2

.NOSQUEEK

 JSR TT17

.FRCE

 JSR TT102
 LDA QQ12
 BEQ P%+5
 JMP MLOOP
 JMP TT100

.TT102

 CMP #f8
 BNE P%+5
 JMP STATUS
 CMP #f4
 BNE P%+5
 JMP TT22
 CMP #f5
 BNE P%+5
 JMP TT23
 CMP #f6
 BNE TT92
 JSR TT111
 JMP TT25

.TT92

 CMP #f9
 BNE P%+5
 JMP TT213
 CMP #f7
 BNE P%+5
 JMP TT167
 CMP #f0
 BNE fvw
 JMP TT110

.fvw

 BIT QQ12
 BPL INSP
 CMP #f3
 BNE P%+5
 JMP EQSHP
 CMP #f1
 BNE P%+5
 JMP TT219
 CMP #$12
 BNE nosave
 JSR SVE
 BCC P%+5
 JMP QU5
 JMP BAY

.nosave

 CMP #f2
 BNE LABEL_3
 JMP TT208

.INSP

 CMP #f12
 BEQ chview1
 CMP #f22
 BEQ chview2
 CMP #f32
 BNE LABEL_3
 LDX #3
 EQUB $2C

.chview2

 LDX #2
 EQUB $2C

.chview1

 LDX #1
 JMP LOOK1

.LABEL_3

 BIT KLO+HINT
 BPL P%+5
 JMP hyp

.NWDAV5 

 CMP #DINT
 BEQ T95
 CMP #FINT ; Find
 BNE HME1
 LDA QQ12
 BEQ t95
 LDA QQ11
 AND #192
 BEQ t95
 JMP HME2

.HME1

 STA T1
 LDA QQ11
 AND #192
 BEQ TT107
 LDA QQ22+1
 BNE TT107
 LDA T1
 CMP #OINT
 BNE ee2
 JSR TT103
 JSR ping
 JMP TT103

.ee2

 JSR TT16

.TT107 

 LDA QQ22+1
 BEQ t95
 DEC QQ22
 BNE t95
 LDX QQ22+1
 DEX
 JSR ee3
 LDA #5
 STA QQ22
 LDX QQ22+1
 JSR ee3
 DEC QQ22+1
 BNE t95
 JMP TT18

.t95

 RTS

.T95

 LDA QQ11
 AND #192
 BEQ t95
;LDA #CYAN
;JSR DOCOL
 JSR hm
 STA QQ17
 JSR cpl
 LDA #128
 STA QQ17
 LDA #12
 JSR TT26
;LDA #10
;JSR TT26
;LDA #1
;JSR DOXC
;JSR INCYC
 JMP TT146

.BAD

 LDA QQ20+3
 CLC
 ADC QQ20+6
 ASL A
 ADC QQ20+10
 RTS

.FAROF

 LDA #$E0

.FAROF2

 CMP INWK+1
 BCC FA1
 CMP INWK+4
 BCC FA1
 CMP INWK+7

.FA1

 RTS

.MAS4

 ORA INWK+1
 ORA INWK+4
 ORA INWK+7
 RTS

.brkd

 EQUB 0

.BRBR

 DEC brkd
 LDX #$FF
 TXS
 JSR backtonormal
 TAY
 LDA #7

.BRBRLOOP

 JSR CHPR
 INY
 LDA ($FD),Y
 BNE BRBRLOOP
 JMP BR1

.DEATH

 JSR EXNO3
 JSR RES2
 ASL DELTA
 ASL DELTA
 LDX #24
 JSR DET1
 JSR TT66
 JSR BOX
 LDA #0
 STA SCBASE+$1F1F
 STA SCBASE+$118
 JSR nWq
 LDA #12
 JSR DOYC
 JSR DOXC
;LDA #YELLOW
;JSR DOCOL
 LDA #146
 JSR ex

.D1

 JSR Ze
 LSR A
 LSR A
 STA INWK
 LDY #0
 STY QQ11
 STY INWK+1
 STY INWK+4
 STY INWK+7
 STY INWK+32
 DEY
 STY MCNT
 EOR #42
 STA INWK+3
 ORA #80
 STA INWK+6
 TXA
 AND #$8F
 STA INWK+29
 LDY #$40
 STY LASCT
 SEC
 ROR A
 AND #$87
 STA INWK+30
 LDX #OIL
 LDA XX21-1+2*PLT
 BEQ D3
 BCC D3
 DEX

.D3

 JSR fq1
 JSR DORND
 AND #128
 LDY #31
 STA (INF),Y
 LDA FRIN+4
 BEQ D1
 JSR U%
 STA DELTA
 JSR M%
 JSR NOSPRITES

.D2

 JSR M%
 DEC LASCT
 BNE D2
 LDX #31
 JSR DET1
 JMP DEATH2

.spasto

 EQUW $8888

.BEGIN

;JSR BRKBK
 LDX #(MUSILLY-COMC)
 LDA #0

.BEL1

 STA COMC,X
 DEX
 BPL BEL1
 LDA XX21+SST*2-2
 STA spasto
 LDA XX21+SST*2-1
 STA spasto+1
 JSR JAMESON

.TT170

 LDX #$FF
 TXS
 JSR RESET

.DEATH2 

 LDX #$FF
 TXS
 JSR RES2

.BR1

 JSR ZEKTRAN
 LDA #3
 JSR DOXC

IF _GMA85_NTSC OR _GMA86_PAL

 JSR $91FE

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

;JSR FX200

ENDIF

 LDX #CYL
 LDA #6
 LDY #210
 JSR TITLE
 CMP #YINT
 BNE QU5

IF _GMA85_NTSC OR _GMA86_PAL

 JSR $9245

ENDIF

 JSR DFAULT
 JSR SVE

IF _GMA85_NTSC OR _GMA86_PAL

 JSR $91FE

ENDIF

.QU5

 JSR DFAULT
 JSR msblob
 LDA #7
 LDX #ADA
 LDY #48
 JSR TITLE

IF _GMA85_NTSC OR _GMA86_PAL

 JSR $9245

ENDIF

 JSR ping
;JSR hyp1 was here...
 JSR TT111
 JSR jmp
 LDX #5

.likeTT112

 LDA QQ15,X
 STA QQ2,X
 DEX
 BPL likeTT112
 INX
 STX EV
 LDA QQ3
 STA QQ28
 LDA QQ5
 STA tek
 LDA QQ4
 STA gov

.BAY

 LDA #$FF
 STA QQ12
 LDA #f8
 JMP FRCE

.DFAULT

 LDX #NT%+8

.QUL1

 LDA NA%-1,X
 STA NAME-1,X
 DEX
 BNE QUL1
 STX QQ11

.doitagain

 JSR CHECK
 CMP CHK
 BNE doitagain
 EOR #$A9
 TAX
 LDA COK
 CPX CHK2
 BEQ tZ
 ORA #128

.tZ

 ORA #64
 STA COK
 JSR CHECK2
 CMP CHK3
 BNE doitagain
 RTS

.TITLE

 STY distaway
 PHA
 STX TYPE

IF _GMA85_NTSC OR _GMA86_PAL

 LDA #$FF
 STA $1D13

ENDIF

 JSR RESET

IF _GMA85_NTSC OR _GMA86_PAL

 LDA #0
 STA $1D13

ENDIF

 JSR ZEKTRAN
 LDA #32
 JSR DOVDU19
 LDA #13
 JSR TT66
;LDA #RED
;JSR DOCOL
 lda #0
 sta QQ11
 LDA #96
 STA INWK+14
 LDA #96
 STA INWK+7
 LDX #127
 STX INWK+29
 STX INWK+30
 INX
 STX QQ17
 LDA TYPE
 JSR NWSHP
 LDA #6
 JSR DOXC
 LDA #30
 JSR plf
 LDA #10
 JSR TT26
 LDA #6
 JSR DOXC
 LDA PATG
 BEQ awe
 LDA #13
 JSR DETOK

.awe

 LDA brkd
 BEQ BRBR2
 INC brkd
 LDA #7
 JSR DOXC
 LDA #10
 JSR DOYC
 LDY #0
 JSR CHPR
 INY
 LDA ($FD),Y
 BNE P%-6

.BRBR2

 LDY #0
 STY DELTA
 STY JSTK ; **
 LDA #15
 STA YC
 LDA #1
 STA XC
 PLA
;JSR ex
 JSR DETOK
 LDA #3 ;<<<
 JSR DOXC
 LDA #12
 JSR DETOK
 LDA #12
 STA CNT2
 LDA #5
 STA MCNT
 LDA #$FF
 STA JSTK

.TLL2

 LDA INWK+7
 CMP #1
 BEQ TL1
 DEC INWK+7

.TL1

 JSR MVEIT
 LDX distaway
 STX INWK+6
 LDA MCNT
 AND #3
 lda #0
 sta INWK
 sta INWK+3
 JSR LL9
 JSR RDKEY
 DEC MCNT
 BIT KY7
 BMI TL3
 BCC TLL2
 INC JSTK

.TL3

 RTS

.CHECK

 LDX #NT%-3
 CLC
 TXA

.QUL2

 ADC NA%+7,X
 EOR NA%+8,X
 DEX
 BNE QUL2
 RTS

.CHECK2

 LDX #NT%-3
 CLC
 TXA

.QU2L2

 STX T
 EOR T
 ROR A
 ADC NA%+7,X
 EOR NA%+8,X
 DEX
 BNE QU2L2
 RTS

.JAMESON

 LDY #(NAEND%-NA2%)

.JAMEL1

 LDA NA2%,Y
 STA NA%,Y
 DEY
 BPL JAMEL1
 LDY #7
 STY oldlong
 RTS

.TRNME

 LDX #7
 LDA thislong
 STA oldlong

.GTL1

 LDA INWK+5,X
 STA NA%,X
 DEX
 BPL GTL1

.TR1

 LDX #7

.GTL2

 LDA NA%,X
 STA INWK+5,X
 DEX
 BPL GTL2
 RTS

.GTNMEW

;LDY #8
;JSR DELAY

.GTNME

 LDX #4

.GTL3

 LDA NA%-5,X
 STA INWK,X
 DEX
 BPL GTL3
 LDA #7
 STA RLINE+2
 LDA #8
 JSR DETOK
 JSR MT26
 LDA #9
 STA RLINE+2
 TYA
 BEQ TR1
 STY thislong
 RTS

.MT26

 \OSWORD 0 mimic to INWK+5
 LDA #MAG2
 STA COL2
 LDY #8
 JSR DELAY
 JSR FLKB
 LDY #0

.OSW0L

 JSR TT217
 CMP #13
 BEQ OSW03
 CMP #27
 BEQ OSW04
 CMP #$7F
 BEQ OSW05
 CPY RLINE+2
 BCS OSW01
 CMP RLINE+3
 BCC OSW01
 CMP RLINE+4
 BCS OSW01
 STA INWK+5,Y
 INY
 EQUB $2C

.OSW01

 LDA #7

.OSW06

 JSR CHPR
 BCC OSW0L

.OSW03

 STA INWK+5,Y
 LDA #$10
 STA COL2
 LDA #12
 JMP CHPR

.OSW04

 LDA #$10
 STA COL2
 SEC
 RTS

.OSW05

 TYA
 BEQ OSW01
 DEY
 LDA #$7F
 BNE OSW06

.RLINE

 EQUW (INWK+5)
 EQUB 9
 EQUB $21
 EQUB $7B

.FILEPR

 LDA#3
 CLC
 ADC DISK
 JMP DETOK

.OTHERFILEPR

 LDA #2
 SEC
 SBC DISK
 JMP DETOK

.ZERO

 LDX #(de-FRIN)
 LDA #0

.ZEL2

 STA FRIN,X
 DEX
 BPL ZEL2
 RTS

.ZEBC

 RTS
 LDX #$C
 JSR ZES1
 DEX  ;<<

.ZES1

 LDY #0
 STY SC

.ZES2

 LDA #0
 STX SC+1

.ZEL1

 STA (SC),Y
 INY
 BNE ZEL1
 RTS

.SVE

 LDA #1
 JSR DETOK
 JSR t
 CMP #$31
 BEQ loading
 CMP #$32
 BEQ SV1
 CMP #$33
 BEQ feb10
 CMP #$34
 BNE feb13
 LDA #224
 JSR DETOK
 JSR YESNO
 BCC feb13
 JSR JAMESON
 JMP DFAULT

.feb13

 CLC
 RTS

.feb10

 LDA DISK
 EOR #$FF
 STA DISK
 JMP SVE

.loading

 JSR GTNMEW
 JSR LOD
 JSR TRNME
 SEC
 RTS

.SV1

 JSR GTNMEW
 JSR TRNME
 LSR SVC
 LDA #4 ;C64
 JSR DETOK
 LDX #NT%

.SVL1

 LDA TP,X
;STA $B00,X
 STA NA%+8,X
 DEX
 BPL SVL1
 JSR CHECK2
 STA CHK3
 JSR CHECK
 STA CHK
 PHA
 ORA #128
 STA K
 EOR COK
 STA K+2
 EOR CASH+2
 STA K+1
 EOR #$5A
 EOR TALLY+1
 STA K+3
 CLC
 JSR BPRNT
 JSR TT67
 JSR TT67
 PLA
;STA $B00+NT% <<
 EOR #$A9
 STA CHK2
;STA $AFF+NT% <<
;LDA #0
;JSR QUS1device instead of drive? **
 JSR KERNALSETUP
 LDA #((NA%+8)MOD 256)
 STA $FD ; SC
 LDA #((NA%+8)DIV 256)
 STA $FE ; SC+1
 LDA #$FD ; SC
 LDX #((CHK+1)MOD 256)
 LDY #((CHK+1)DIV 256)
 JSR KERNALSVE
 PHP
 SEI
 BIT CIA+$D
 LDA #1
 STA CIA+$D ; disable timer
 LDX #0
 STX RASTCT
 INX
 STX VIC+$1A ;enable Raster int
 LDA VIC+$11
 AND #$7F
 STA VIC+$11
 LDA #40
 STA VIC+$12 ;set first Raster int
 LDA #4
 JSR SETL1
 CLI
 JSR SWAPPZERO
 PLP
 CLI
 BCS saveerror
 JSR DFAULT
 \SC over BASIC
 JSR t

.SVEX

 CLC
 RTS

.saveerror

 JMP tapeerror

.thislong

 EQUB 7

.oldlong

 EQUB 7

.KERNALSETUP

 JSR SWAPPZERO
 LDA #6
 SEI
 JSR SETL1
 LDA #0
 STA VIC+$1A
 CLI  ;tell Ian to go away
 LDA #$81
 STA CIA+$D ; turn on IRQ
 LDA #$C0
 JSR KERNALSETMSG ;enable tape messages
 LDX DISK
 INX
 LDA filesys,X
 TAX
 LDA #1 ; <<
 LDY #0 ; FF
 JSR KERNALSETLFS ;file system
 LDA thislong
 LDX #(INWK+5)
 LDY #0
 JMP KERNALSETNAM

.GTDRV

 LDA #2
 JSR DETOK
 JSR t
 ORA #$10
 JSR CHPR
 PHA
 JSR FEED
 PLA
 CMP #$30
 BCC LOR
 CMP #$34
 RTS

.filesys

 EQUB 8
 EQUB 1

.LOD

 JSR KERNALSETUP
 LDA #0
 LDX #(TAP%MOD 256)
 LDY #(TAP%DIV 256)
 JSR KERNALLOAD
 PHP
 LDA #1
 STA CIA+$D
 SEI
 LDX #0
 STX RASTCT
 INX
 STX VIC+$1A ; enable Raster int
 LDA VIC+$11
 AND #$7F
 STA VIC+$11
 LDA #40
 STA VIC+$12
 LDA #4
 JSR SETL1
 CLI
 JSR SWAPPZERO
 PLP
 CLI
 BCS tapeerror
 LDA TAP%
 BMI ELT2F
 LDY #NT%

.copyme

 LDA TAP%,Y
 STA NA%+8,Y
 DEY
 BPL copyme

.LOR

 SEC
 RTS

.ELT2F

 LDA #9
 JSR DETOK
 JSR t
 JMP SVE

.backtonormal

 RTS
 \VIAE,DODOSVN

.tapeerror

 LDA #255
 JSR DETOK
 JSR t
 JMP SVE

.CLDELAY

 RTS

.ZEKTRAN

 LDX #$40
 LDA #0
 STA thiskey

.ZEKLOOP

 STA KEYLOOK,X
 DEX
 BPL ZEKLOOP
 RTS
 RTS

.SPS1

 LDX #0
 JSR SPS3
 LDX #3
 JSR SPS3
 LDX #6
 JSR SPS3

.TAS2

 LDA K3
 ORA K3+3
 ORA K3+6
 ORA #1
 STA K3+9
 LDA K3+1
 ORA K3+4
 ORA K3+7

.TAL2

 ASL K3+9
 ROL A
 BCS TA2
 ASL K3
 ROL K3+1
 ASL K3+3
 ROL K3+4
 ASL K3+6
 ROL K3+7
 BCC TAL2

.TA2

 LDA K3+1
 LSR A
 ORA K3+2
 STA XX15
 LDA K3+4
 LSR A
 ORA K3+5
 STA XX15+1
 LDA K3+7
 LSR A
 ORA K3+8
 STA XX15+2

.NORM

 LDA XX15
 JSR SQUA
 STA R
 LDA P
 STA Q
 LDA XX15+1
 JSR SQUA
 STA T
 LDA P
 ADC Q
 STA Q
 LDA T
 ADC R
 STA R
 LDA XX15+2
 JSR SQUA
 STA T
 LDA P
 ADC Q
 STA Q
 LDA T
 ADC R
 STA R
 JSR LL5
 LDA XX15
 JSR TIS2
 STA XX15 ;*96/Q
 LDA XX15+1
 JSR TIS2
 STA XX15+1
 LDA XX15+2
 JSR TIS2
 STA XX15+2

.NO1

 RTS

.KEYLOOK

 EQUS "123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF01234567"
 \..............

 KLO = KEYLOOK
 KY1 = KLO+9
 KY2 = KLO+4
 KY3 = KLO+$11
 KY4 = KLO+$14
 KY5 = KLO+$29
 KY6 = KLO+$33
 KY7 = KLO+$36
 KY12 = KLO+$03
 KY13 = KLO+$07
 KY14 = KLO+$2A
 KY15 = KLO+$22
 KY16 = KLO+$1C
 KY17 = KLO+$32
 KY18 = KLO+$1E
 KY19 = KLO+$2C
 KY20 = KLO+$17

.RDKEY

 TYA
 PHA
 LDA #5
 JSR SETL1
 LDA VIC+$15
 AND #$FD
 STA VIC+$15
 JSR ZEKTRAN
 LDX JSTK
 BEQ scanmatrix
 LDA CIA
 AND #$1F

IF _GMA85_NTSC OR _GMA86_PAL

 EOR #$1F

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 CMP #$1F

ENDIF

 BNE dojoystick

.scanmatrix

 CLC
 LDX #0
 SEI
 STX $DC00
 LDX $DC01
 CLI
 INX
 BEQ nokeys2
 LDX #$40
 LDA #$FE

.Rdi1

 SEI
 STA $DC00
 PHA
 LDY #8

.Rdi0

 LDA $DC01
 CMP $DC01
 BNE Rdi0 ;**
 CLI

.Rdi2

 LSR A
 BCS Rdi3
 DEC KEYLOOK,X
 STX thiskey
 SEC

.Rdi3

 DEX
 BMI Rdiex
 DEY
 BNE Rdi2
 PLA
 ROL A
 BNE Rdi1

.Rdiex

 PLA
 SEC

.nokeys2

 LDA #$7F
 STA $DC00
 BNE nojoyst

IF _GMA85_NTSC OR _GMA86_PAL

.dojoystick

 LSR A
 BCC downj
 STX KY6

.downj

 LSR A
 BCC upj
 STX KY5

.upj

 LSR A
 BCC leftj
 STX KY3

.leftj

 LSR A
 BCC rightj
 STX KY4

.rightj

 LSR A
 BCC firej
 STX KY7

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

.dojoystick

 LSR A
 BCS downj
 STX KY6

.downj

 LSR A
 BCS upj
 STX KY5

.upj

 LSR A
 BCS leftj
 STX KY3

.leftj

 LSR A
 BCS rightj
 STX KY4

.rightj

 LSR A
 BCS firej
 STX KY7

ENDIF

IF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 EQUB $24 

ENDIF

.firej

IF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 CLC

ENDIF

 LDA JSTGY
 BEQ noswapys
 LDA KY5
 LDX KY6

IF _GMA85_NTSC OR _GMA86_PAL

 EQUB $8D, $3F, $8D, $8E, $35, $8D

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 STA KY6
 STX KY5

ENDIF

.noswapys

 LDA JSTE
 BEQ noswapxs
 LDA KY5
 LDX KY6
 STA KY6
 STX KY5
 LDA KY3
 LDX KY4
 STA KY4
 STX KY3

.noswapxs

.nojoyst

 LDA QQ11
 BEQ allkeys
 LDA #0
 STA KY12
 STA KY13
 STA KY14
 STA KY15
 STA KY16
 STA KY17
 STA KY18
 STA KY19
 STA KY20

.allkeys

 LDA #4
 JSR SETL1
 PLA
 TAY
 LDA thiskey
 TAX
 RTS  ;!!

.WARP

 LDX JUNK
 LDA FRIN+2,X
 ORA SSPR
 ORA MJ
 BNE WA1
 LDY K%+8
 BMI WA3
 TAY
 JSR MAS2
 CMP #2
 BCC WA1

.WA3

 LDY K%+NI%+8
 BMI WA2
 LDY #NI%
 JSR m
 CMP #2
 BCC WA1

.WA2

 LDA #$81
 STA S
 STA R
 STA P
 LDA K%+8
 JSR ADD
 STA K%+8
 LDA K%+NI%+8
 JSR ADD
 STA K%+NI%+8
 LDA #1
 STA QQ11
 STA MCNT
 LSR A
 STA EV
 LDX VIEW
 JMP LOOK1

.WA1

 LDY #sfxboop
 JMP NOISE

.KYTB

 RTS
 EQUB $E8
 EQUB $E2
 EQUB $E6
 EQUB $E7
 EQUB $C2
 EQUB $D1
 EQUB $C1
 \EQUD &56336443
 EQUD &35237060
 EQUW $2265
 EQUB $45
 EQUB $52
 EQUB $37 ;? <>XSA.FBRLtabescTUMEJCP

.CTRL

 LDX #6

.DKS4

 LDA KEYLOOK,X
 TAX
 RTS

.DKSANYKEY

 LDA #5
 JSR SETL1
 SEI
 STX $DC00
 LDX $DC01
 CLI
 INX
 BEQ DKSL1
 LDX #$FF

.DKSL1

 LDA #4
 JSR SETL1
 TXA
 RTS
 RTS

.DKS2

 LDA KTRAN+7,X
 EOR JSTE
 RTS

.DKS3

 TXA
 CMP TGINT,Y
 BNE Dk3
 LDA DAMP,Y
 EOR #$FF
 STA DAMP,Y
 JSR BELL
 TYA
 PHA
 LDY #20
 JSR DELAY
 PLA
 TAY

.Dk3

 RTS
 \DKJ1 LDAauto
;BNE auton
;LDA KTRAN+1
;STA KL+1
;LDA KTRAN+2
;STA KL+2
 \BS1 LDAKTRAN+12
 \$FE40
;TAX 
;AND #16
;EOR #16
;STA KL+7
;LDX #1
;JSR DKS2
;ORA #1
;STA JSTX
;LDX #2
;JSR DKS2
;EOR JSTGY
;STA JSTY
;JMP DK4

.U%

 LDA #0
 LDY #$38

.DKL3

 STA KLO,Y
 DEY
 BNE DKL3
 STA KL
 RTS

.DOKEY

 JSR RDKEY
;JSR U%
;JMP DK15
 LDA auto
 BEQ DK15

.auton

 JSR ZINF
 LDA #96
 STA INWK+14
 ORA #128
 STA INWK+22
 STA TYPE
 LDA DELTA
 STA INWK+27
 JSR DOCKIT
 LDA INWK+27
 CMP #22
 BCC P%+4
 LDA #22
 STA DELTA
 LDA #$FF
 LDX #(KY1-KLO)
 LDY INWK+28
 BEQ DK11
 BMI P%+4
 LDX #(KY2-KLO)
 STA KLO,X

.DK11

 LDA #128
 LDX #(KY3-KLO)
 ASL INWK+29
 BEQ DK12
 BCC P%+4
 LDX #(KY4-KLO)
 BIT INWK+29
 BPL DK14
 LDA #64
 STA JSTX
 LDA #0

.DK14

 STA KLO,X
 LDA JSTX

.DK12

 STA JSTX
 LDA #128
 LDX #(KY5-KLO)
 ASL INWK+30
 BEQ DK13
 BCS P%+4
 LDX #(KY6-KLO)
 STA KLO,X
 LDA JSTY

.DK13

 STA JSTY

.DK15

 LDX JSTX
 LDA #14
 LDY KY3
 BEQ P%+5
 JSR BUMP2
 LDY KY4
 BEQ P%+5
 JSR REDU2
 STX JSTX
;ASL A
 LDX JSTY
 LDY KY5
 BEQ P%+5
 JSR REDU2
 LDY KY6
 BEQ P%+5
 JSR BUMP2
 STX JSTY
 LDA JSTK
 BEQ ant
 LDA auto
 BNE ant
 LDX #128
 LDA KY3
 ORA KY4
 BNE termite
 STX JSTX

.termite

 LDA KY5
 ORA KY6
 BNE ant
 STX JSTY

.ant

.DK4

 LDX thiskey
 STX KL
 CPX #$40
 BNE DK2

.FREEZE

 JSR WSCAN
 JSR RDKEY
 CPX #$02
 BNE DK6
 STX DNOIZ

.DK6

 LDY #0

.DKL4

 JSR DKS3
 INY
 CPY #(MUFOR-DAMP)
 BNE DKL4
 BIT PATG
 BPL nosillytog

.DKL42

 JSR DKS3
 INY
 CPY #(MUSILLY-DAMP+1)
 BNE DKL42

.nosillytog

 LDA MUTOK
 CMP MUTOKOLD
 BEQ P%+5
 JSR MUTOKCH
 CPX #$33
 BNE DK7
 LDA #0
 STA DNOIZ

.DK7

 CPX #$07
 BNE P%+5
 JMP DEATH2
 CPX #$0D
 BNE FREEZE

.DK2

 RTS

.TT217

 STY YSAV

.t

 LDY #2
 JSR DELAY
 JSR RDKEY
 BNE t

.t2

 JSR RDKEY
 BEQ t2
 LDA TRANTABLE,X
 LDY YSAV
 TAX

.out

 RTS

.me1

 STX DLY
 PHA
 LDA MCH
 JSR mes9
 PLA

.MESS

 PHA
 LDA #16
 LDX QQ11
 BEQ infrontvw
 JSR CLYNS
 LDA #25
 EQUB $2C

.infrontvw

 STA YC
 LDX #0
 STX QQ17
 LDA messXC
 JSR DOXC
 PLA
 LDY #20
 CPX DLY
 BNE me1
 STY DLY
 STA MCH
 LDA #$C0
 STA DTW4
 LDA de
 LSR A
 LDA #0
 BCC P%+4
 LDA #10
 STA DTW5
 LDA MCH
 JSR TT27
 LDA #32
 SEC
 SBC DTW5
 LSR A
 STA messXC
 JSR DOXC
 JSR MT15
 LDA MCH

.mes9

 JSR TT27
 LSR de
 BCC out
 LDA #253
 JMP TT27

.OUCH

 JSR DORND
 BMI out
 CPX #22
 BCS out
 LDA QQ20,X
 BEQ out
 LDA DLY
 BNE out
 LDY #3
 STY de
 STA QQ20,X
 CPX #17
 BCS ou1
 TXA
 ADC #208
 JMP MESS ;was BNE <<----

.ou1

 BEQ ou2
 CPX #18
 BEQ ou3
 TXA
 ADC #113-20
 JMP MESS

.ou2

 lda #108
 JMP MESS

.ou3

 lda #111
 JMP MESS

.QQ23 ; Prxs 

 EQUD &1068213
 EQUD &30A8114
 EQUD &7028341 ;Food
 EQUD &1FE28528
 EQUD &FFB8553
 EQUD &33608C4
 EQUD &78081DEB ;slvs..
 EQUD &3380E9A
 EQUD &7280675
 EQUD &1F11014E
 EQUD &71D0D7C ;comps
 EQUD &3FDC89B0
 EQUD &03358120
;EQUD &360A118
 EQUD &742A161
 EQUD &1F37A2AB ;platnm
 EQUD &FFAC12D
 EQUD &7C00F35 ;Gms.

.TI2

 TYA
 LDY #2
 JSR TIS3
 STA INWK+20 ; Uz = -(FxUx+FyUy)/Fz
 JMP TI3

.TI1

 TAX
 LDA XX15+1
 AND #$60
 BEQ TI2
 LDA #2
 JSR TIS3
 STA INWK+18
 JMP TI3

.TIDY

 LDA INWK+10
 STA XX15
 LDA INWK+12
 STA XX15+1
 LDA INWK+14
 STA XX15+2
 JSR NORM
 LDA XX15
 STA INWK+10
 LDA XX15+1
 STA INWK+12
 LDA XX15+2
 STA INWK+14
 LDY #4
 LDA XX15
 AND #$60
 BEQ TI1
 LDX #2
 LDA #0
 JSR TIS3
 STA INWK+16

.TI3

 LDA INWK+16
 STA XX15
 LDA INWK+18
 STA XX15+1
 LDA INWK+20
 STA XX15+2
 JSR NORM
 LDA XX15
 STA INWK+16
 LDA XX15+1
 STA INWK+18
 LDA XX15+2
 STA INWK+20
 LDA INWK+12
 STA Q
 LDA INWK+20
 JSR MULT12
 LDX INWK+14
 LDA INWK+18
 JSR TIS1
 EOR #128
 STA INWK+22
 LDA INWK+16
 JSR MULT12
 LDX INWK+10
 LDA INWK+20
 JSR TIS1
 EOR #128
 STA INWK+24
 LDA INWK+18
 JSR MULT12
 LDX INWK+12
 LDA INWK+16
 JSR TIS1
 EOR #128
 STA INWK+26 ;FxU/96(LHS)
 LDA #0
 LDX #14

.TIL1

 STA INWK+9,X
 DEX
 DEX
 BPL TIL1
 RTS

.TIS2

 TAY
 AND #127
 CMP Q
 BCS TI4
 LDX #254
 STX T

.TIL2

 ASL A
 CMP Q
 BCC P%+4
 SBC Q
 ROL T
 BCS TIL2
 LDA T
 LSR A
 LSR A
 STA T
 LSR A
 ADC T
 STA T
 TYA
 AND #128
 ORA T
 RTS

.TI4

 TYA
 AND #128
 ORA #96
 RTS

.TIS3

 STA P+2
 LDA INWK+10,X
 STA Q
 LDA INWK+16,X
 JSR MULT12
 LDX INWK+10,Y
 STX Q
 LDA INWK+16,Y
 JSR MAD
 STX P
 LDY P+2
 LDX INWK+10,Y
 STX Q
 EOR #128

.DVIDT ; A = AP/Q 

 STA P+1
 EOR Q
 AND #128
 STA T
 LDA #0
 LDX #16
 ASL P
 ROL P+1
 ASL Q
 LSR Q

.DVL2

 ROL A
 CMP Q
 BCC P%+4
 SBC Q
 ROL P
 ROL P+1
 DEX
 BNE DVL2
 LDA P
 ORA T

.itsoff

 RTS
 \...........

IF _GMA85_NTSC OR _GMA86_PAL

.L91FE

 LDA #$63
 LDX #$C1
 BNE L920D

ENDIF

.startbd

IF _GMA85_NTSC OR _GMA86_PAL

 BIT $1D11
 BMI L91FE
 LDA #$2C
 LDX #$B7

.L920D

 STA $B4D0
 STX $B4D1

ENDIF

 BIT MUPLA
 BMI itsoff
 BIT MUFOR
 BMI april16
 BIT MUTOK
 BMI itsoff

.april16

 LDA #5
 JSR SETL1
 JSR BDENTRY
 LDA #$FF
 STA MUPLA
 BNE coffeeex

.MUTOKCH

 STA MUTOKOLD
 EOR #$FF
 AND auto
 BMI april16

.stopbd

IF _GMA85_NTSC OR _GMA86_PAL

 BIT L1D13
 BMI itsoff

ENDIF

 BIT MUFOR
 BMI startbd
 BIT MUPLA
 BPL itsoff
 JSR SOFLUSH
 LDA #5
 JSR SETL1
 LDA #0
 STA MUPLA
 LDX #$18
 SEI

.coffeeloop

 STA SID,X
 DEX
 BPL coffeeloop
 LDA #$F
 STA SID+$18
 CLI

.coffeeex

 LDA #4
 JMP SETL1
 \..............

.buf

 EQUB 2
 EQUB 15

.KTRAN

 EQUS "12345678901234567"

.TRANTABLE

 EQUB 0
 EQUB 1
 EQUS "Q"
 EQUB 2
 EQUS " 2"
 EQUB 3
 EQUB 27
 EQUS "1/^="
 EQUB 5
 EQUB 6
 EQUS ";*"
 EQUS "`,@:.-LP"
 EQUS "+NOKM0JI"
 EQUS "9VUHB8GY"
 EQUS "7XTFC6DR"
 EQUS "5"
 EQUB 7
 EQUS "ESZ4AW"
 EQUS "3"
 EQUB 8
 EQUB 9
 EQUB 10
 EQUB 11
 EQUB 12
 EQUB 14
 EQUB 13
 EQUB $7F ;DEL
 \............

; ******************************************************************************
;
; Save ELTF.bin
;
; ******************************************************************************

 PRINT "ELITE F"
 PRINT "Assembled at ", ~CODE_F%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_F%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_F%

 PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
 SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%

; ******************************************************************************
;
; ELITE G FILE
;
; Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_G% = P%

 LOAD_G% = LOAD% + P% - CODE%

IF _GMA85_NTSC OR _GMA86_PAL

 EQUB $A9, $05, $20, $7F, $82, $A9, $00, $8D
 EQUB $15, $D0, $A9, $04, $78, $8D, $8E, $82
 EQUB $A5, $01, $29, $F8, $0D, $8E, $82, $85
 EQUB $01, $58, $60, $04, $A5, $2E, $8D, $F2
 EQUB $04, $A5, $2F, $8D, $F3, $04, $60, $A6
 EQUB $9D, $20, $F3, $82, $A6, $9D, $4C, $2F
 EQUB $20, $20, $47, $84, $20, $4F, $7B, $8D
 EQUB $53, $04, $8D, $5F, $04, $20, $0E, $B1
 EQUB $A9

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

; Noise - contains SWAPPZERO

 EQUB $A2, $36, $B5, $00, $BC, $00, $CE, $9D
 EQUB $00, $CE, $94, $00, $E8, $D0, $F3, $60

; Noise - contains NOSPRITES and start of KS3

 EQUB $A9, $05, $20, $7F, $8B, $A9, $00, $8D
 EQUB $15, $D0, $A9, $04, $78, $8D, $8E, $8B
 EQUB $A5, $01, $29, $F8, $0D, $8E, $8B, $85
 EQUB $01, $58, $60, $04, $A5, $2E, $8D, $F2
 EQUB $04, $A5, $2F, $8D, $F3, $04, $60, $A6
 EQUB $9D, $20, $F3, $8B, $A6, $9D, $4C, $2C
 EQUB $20, $20, $47, $8D, $20, $3F, $84, $8D
 EQUB $53, $04, $8D, $5F, $04, $20, $0E, $BA
 EQUB $A9, $06, $85, $0E, $A9, $81, $4C, $5B
 EQUB $85, $A2, $FF, $E8, $BD, $52, $04, $F0
 EQUB $CB, $C9, $01, $D0, $F6, $8A, $0A, $A8
 EQUB $B9, $A1, $28, $85, $07, $B9, $A2

ENDIF

.log

IF _GMA85_NTSC OR _GMA86_PAL

 EQUB $06

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 EQUB $28

ENDIF

 EQUB $00, $20, $32, $40, $4A, $52, $59
 EQUB $5F, $65, $6A, $6E, $72, $76, $79, $7D
 EQUB $80, $82, $85, $87, $8A, $8C, $8E, $90
 EQUB $92, $94, $96, $98, $99, $9B, $9D, $9E
 EQUB $A0, $A1, $A2, $A4, $A5, $A6, $A7, $A9
 EQUB $AA, $AB, $AC, $AD, $AE, $AF, $B0, $B1
 EQUB $B2, $B3, $B4, $B5, $B6, $B7, $B8, $B9
 EQUB $B9, $BA, $BB, $BC, $BD, $BD, $BE, $BF
 EQUB $BF, $C0, $C1, $C2, $C2, $C3, $C4, $C4
 EQUB $C5, $C6, $C6, $C7, $C7, $C8, $C9, $C9
 EQUB $CA, $CA, $CB, $CC, $CC, $CD, $CD, $CE
 EQUB $CE, $CF, $CF, $D0, $D0, $D1, $D1, $D2
 EQUB $D2, $D3, $D3, $D4, $D4, $D5, $D5, $D5
 EQUB $D6, $D6, $D7, $D7, $D8, $D8, $D9, $D9
 EQUB $D9, $DA, $DA, $DB, $DB, $DB, $DC, $DC
 EQUB $DD, $DD, $DD, $DE, $DE, $DE, $DF, $DF
 EQUB $E0, $E0, $E0, $E1, $E1, $E1, $E2, $E2
 EQUB $E2, $E3, $E3, $E3, $E4, $E4, $E4, $E5
 EQUB $E5, $E5, $E6, $E6, $E6, $E7, $E7, $E7
 EQUB $E7, $E8, $E8, $E8, $E9, $E9, $E9, $EA
 EQUB $EA, $EA, $EA, $EB, $EB, $EB, $EC, $EC
 EQUB $EC, $EC, $ED, $ED, $ED, $ED, $EE, $EE
 EQUB $EE, $EE, $EF, $EF, $EF, $EF, $F0, $F0
 EQUB $F0, $F1, $F1, $F1, $F1, $F1, $F2, $F2
 EQUB $F2, $F2, $F3, $F3, $F3, $F3, $F4, $F4
 EQUB $F4, $F4, $F5, $F5, $F5, $F5, $F5, $F6
 EQUB $F6, $F6, $F6, $F7, $F7, $F7, $F7, $F7
 EQUB $F8, $F8, $F8, $F8, $F9, $F9, $F9, $F9
 EQUB $F9, $FA, $FA, $FA, $FA, $FA, $FB, $FB
 EQUB $FB, $FB, $FB, $FC, $FC, $FC, $FC, $FC
 EQUB $FD, $FD, $FD, $FD, $FD, $FD, $FE, $FE
 EQUB $FE, $FE, $FE, $FF, $FF, $FF, $FF, $FF

.logL

IF _GMA85_NTSC OR _GMA86_PAL

 EQUB $AE

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 EQUB $10

ENDIF

 EQUB $00, $00, $B8, $00, $4D, $B8, $D5
 EQUB $FF, $70, $4D, $B3, $B8, $6A, $D5, $05
 EQUB $00, $CC, $70, $EF, $4D, $8D, $B3, $C1
 EQUB $B8, $9A, $6A, $28, $D5, $74, $05, $88
 EQUB $00, $6B, $CC, $23, $70, $B3, $EF, $22
 EQUB $4D, $71, $8D, $A3, $B3, $BD, $C1, $BF
 EQUB $B8, $AB, $9A, $84, $6A, $4B, $28, $00
 EQUB $D5, $A7, $74, $3E, $05, $C8, $88, $45
 EQUB $FF, $B7, $6B, $1D, $CC, $79, $23, $CA
 EQUB $70, $13, $B3, $52, $EF, $89, $22, $B8
 EQUB $4D, $E0, $71, $00, $8D, $19, $A3, $2C
 EQUB $B3, $39, $BD, $3F, $C1, $40, $BF, $3C
 EQUB $B8, $32, $AB, $23, $9A, $10, $84, $F7
 EQUB $6A, $DB, $4B, $BA, $28, $94, $00, $6B
 EQUB $D5, $3E, $A7, $0E, $74, $DA, $3E, $A2
 EQUB $05, $67, $C8, $29, $88, $E7, $45, $A3
 EQUB $00, $5B, $B7, $11, $6B, $C4, $1D, $75
 EQUB $CC, $23, $79, $CE, $23, $77, $CA, $1D
 EQUB $70, $C1, $13, $63, $B3, $03, $52, $A1
 EQUB $EF, $3C, $89, $D6, $22, $6D, $B8, $03
 EQUB $4D, $96, $E0, $28, $71, $B8, $00, $47
 EQUB $8D, $D4, $19, $5F, $A3, $E8, $2C, $70
 EQUB $B3, $F6, $39, $7B, $BD, $FE, $3F, $80
 EQUB $C1, $01, $40, $80, $BF, $FD, $3C, $7A
 EQUB $B8, $F5, $32, $6F, $AB, $E7, $23, $5F
 EQUB $9A, $D5, $10, $4A, $84, $BE, $F7, $31
 EQUB $6A, $A2, $DB, $13, $4B, $82, $BA, $F1
 EQUB $28, $5E, $94, $CB, $00, $36, $6B, $A0
 EQUB $D5, $0A, $3E, $73, $A7, $DA, $0E, $41
 EQUB $74, $A7, $DA, $0C, $3E, $70, $A2, $D3
 EQUB $05, $36, $67, $98, $C8, $F8, $29, $59
 EQUB $88, $B8, $E7, $16, $45, $74, $A3, $D1

.antilog

 FOR I%, 0, 255

  EQUB INT(2^((I% / 2 + 128) / 16) + 0.5) DIV 256

 NEXT

.antilogODD

 FOR I%, 0, 255

  EQUB INT(2^((I% / 2 + 128.25) / 16) + 0.5) DIV 256

 NEXT

.ylookupl

 FOR I%, 0, 255

  EQUB (SCBASE + $20 + ((I% AND $F8) * 40)) MOD 256

 NEXT

.ylookuph

 FOR I%, 0, 255

  EQUB (SCBASE + $20 + ((I% AND $F8) * 40)) DIV 256

 NEXT

.celllookl

 FOR I%, 0, 24

  EQUB (SCBASE + $2003 + (40 * I%)) MOD 256

 NEXT

.celllookh

 FOR I%, 0, 24

  EQUB (SCBASE + $2003 + (40 * I%)) DIV 256

 NEXT

.SHPPT

 JSR EE51
 JSR PROJ
 ORA K3+1
 BNE nono
 LDA K4
 CMP #Y*2-2
 BCS nono
 LDY #2
 jsr Shpt
 ldy #6
 lda K4
 ADC #1
 jsr Shpt
 LDA #8
 ORA XX1+31
 STA XX1+31
 LDA #8
 JMP LL81+2
 PLA
 PLA

.nono

 lda #$F7
 and XX1+31
 sta XX1+31
 RTS

.Shpt

 STA (XX19),Y
 iny
 iny
 STA (XX19),Y
 LDA K3
 DEY
 STA (XX19),Y
 ADC #3
 BCS nono-2
 dey
 dey
 STA (XX19),Y
 rts

.LL5

 \2BSQRT Q = SQR(RQ)
 LDY R
 LDA Q
 STA S
 LDX #0
 STX Q
 LDA #8
 STA T

.LL6

 CPX Q
 BCC LL7
 BNE P%+6
 CPY #$40
 BCC LL7
 TYA
 SBC #$40
 TAY
 TXA
 SBC Q
 TAX

.LL7

 ROL Q
 ASL S
 TYA
 ROL A
 TAY
 TXA
 ROL A
 TAX
 ASL S
 TYA
 ROL A
 TAY
 TXA
 ROL A
 TAX
 DEC T
 BNE LL6
 RTS

.LL28

 \BFRDIV R = A*256/Q
 CMP Q
 BCS LL2
 STA widget
 TAX
 BEQ LLfix
 LDA logL,X
 LDX Q
 SEC
 SBC logL,X
 BMI noddlog
 LDX widget
 LDA log,X
 LDX Q
 SBC log,X
 BCS LL2
 TAX
 LDA antilog,X

.LLfix

 STA R
 RTS

.noddlog

 LDX widget
 LDA log,X
 LDX Q
 SBC log,X
 BCS LL2
 TAX
 LDA antilogODD,X
 STA R
 RTS
 \LL28 CMPQ
 BCS LL2
 LDX #254
 STX R

.LL31

 ASL A
 BCS LL29
 CMP Q
 BCC P%+4
 SBC Q
 ROL R
 BCS LL31
 RTS

.LL29

 SBC Q
 SEC
 ROL R
 BCS LL31
 LDA R
 RTS

.LL2

 LDA #$FF
 STA R
 RTS

.LL38

 \BADD(S)A = R+Q(SA)
 EOR S
 BMI LL39
 LDA Q
 CLC
 ADC R
 RTS

.LL39

 LDA R
 SEC
 SBC Q
 BCC LL40
 CLC
 RTS

.LL40

 PHA
 LDA S
 EOR #128
 STA S
 PLA
 EOR #255
 ADC #1
 RTS

.LL51

 \XX12 = XX15.XX16
 LDX #0
 LDY #0

.ll51

 LDA XX15
 STA Q
 LDA XX16,X
 JSR FMLTU
 STA T
 LDA XX15+1
 EOR XX16+1,X
 STA S
 LDA XX15+2
 STA Q
 LDA XX16+2,X
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX15+3
 EOR XX16+3,X
 JSR LL38
 STA T
 LDA XX15+4
 STA Q
 LDA XX16+4,X
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX15+5
 EOR XX16+5,X
 JSR LL38
 STA XX12,Y
 LDA S
 STA XX12+1,Y
 INY
 INY
 TXA
 CLC
 ADC #6
 TAX
 CMP #17
 BCC ll51
 RTS

.LL25

 JMP PLANET

.LL9

 \ENTRY
 LDA TYPE
 BMI LL25
 LDA #31
 STA XX4
 LDA NEWB
 BMI EE51
 LDA #32
 BIT XX1+31
 BNE EE28
 BPL EE28
 \Initiate explosion
 ORA XX1+31
 AND #$3F
 STA XX1+31
 LDA #0
 LDY #28
 STA (INF),Y
 LDY #30
 STA (INF),Y
 JSR EE51
 LDY #1
 LDA #18
 STA (XX19),Y
 LDY #7
 LDA (XX0),Y
 LDY #2
 STA (XX19),Y

.EE55

 INY
 JSR DORND
 STA (XX19),Y
 CPY #6
 BNE EE55

.EE28

 LDA XX1+8

.EE49

 BPL LL10

.LL14

 LDA XX1+31
 AND #32
 BEQ EE51
 LDA XX1+31
 AND #$F7
 STA XX1+31
 JMP DOEXP

.EE51

 LDA #8
 BIT XX1+31
 BEQ LL10-1
 EOR XX1+31
 STA XX1+31
 JMP LL155
 RTS

.LL10

 LDA XX1+7
 CMP #$C0
 BCS LL14
 LDA XX1
 CMP XX1+6
 LDA XX1+1
 SBC XX1+7
 BCS LL14
 LDA XX1+3
 CMP XX1+6
 LDA XX1+4
 SBC XX1+7
 BCS LL14
 LDY #6
 LDA (XX0),Y
 TAX
 LDA #255
 STA XX3,X
 STA XX3+1,X
 LDA XX1+6
 STA T
 LDA XX1+7
 LSR A
 ROR T
 LSR A
 ROR T
 LSR A
 ROR T
 LSR A
 BNE LL13
 LDA T
 ROR A
 LSR A
 LSR A
 LSR A
 STA XX4
 BPL LL17

.LL13

 LDY #13
 LDA (XX0),Y
 CMP XX1+7
 BCS LL17
 LDA #32
 AND XX1+31
 BNE LL17
 JMP SHPPT

.LL17

 LDX #5

.LL15

 LDA XX1+21,X
 STA XX16,X
 LDA XX1+15,X
 STA XX16+6,X
 LDA XX1+9,X
 STA XX16+12,X
 DEX
 BPL LL15
 LDA #197 ;NORM
 STA Q
 LDY #16

.LL21

 LDA XX16,Y
 ASL A
 LDA XX16+1,Y
 ROL A
 JSR LL28
 LDX R
 STX XX16,Y
 DEY
 DEY
 BPL LL21
 LDX #8

.ll91

 LDA XX1,X
 STA XX18,X
 DEX
 BPL ll91
 LDA #255
 STA XX2+15
 LDY #12
 LDA XX1+31
 AND #32
 BEQ EE29
 LDA (XX0),Y
 LSR A
 LSR A
 TAX
 LDA #$FF

.EE30

 STA XX2,X
 DEX
 BPL EE30
 INX
 STX XX4

.LL41

 JMP LL42

.EE29

 LDA (XX0),Y
 BEQ LL41
 STA XX20
 \DtProd^XX2
 LDY #18
 LDA (XX0),Y
 TAX
 LDA XX18+7

.LL90

 TAY
 BEQ LL91
 INX
 LSR XX18+4
 ROR XX18+3
 LSR XX18+1
 ROR XX18
 LSR A
 ROR XX18+6
 TAY
 BNE LL90+3

.LL91

 STX XX17
 LDA XX18+8
 STA XX15+5
 LDA XX18
 STA XX15
 LDA XX18+2
 STA XX15+1
 LDA XX18+3
 STA XX15+2
 LDA XX18+5
 STA XX15+3
 LDA XX18+6
 STA XX15+4
 JSR LL51
 LDA XX12
 STA XX18
 LDA XX12+1
 STA XX18+2
 LDA XX12+2
 STA XX18+3
 LDA XX12+3
 STA XX18+5
 LDA XX12+4
 STA XX18+6
 LDA XX12+5
 STA XX18+8
 LDY #4
 LDA (XX0),Y
 CLC
 ADC XX0
 STA V
 LDY #17
 LDA (XX0),Y
 ADC XX0+1
 STA V+1
 LDY #0

.LL86

 LDA (V),Y
 STA XX12+1
 AND #31
 CMP XX4
 BCS LL87
 TYA
 LSR A
 LSR A
 TAX
 LDA #255
 STA XX2,X
 TYA
 ADC #4
 TAY
 JMP LL88

.LL87

 LDA XX12+1
 ASL A
 STA XX12+3
 ASL A
 STA XX12+5
 INY
 LDA (V),Y
 STA XX12
 INY
 LDA (V),Y
 STA XX12+2
 INY
 LDA (V),Y
 STA XX12+4
 LDX XX17
 CPX #4
 BCC LL92

.LL143

 \Fce ofst<<PV
 LDA XX18
 STA XX15
 LDA XX18+2
 STA XX15+1
 LDA XX18+3
 STA XX15+2
 LDA XX18+5
 STA XX15+3
 LDA XX18+6
 STA XX15+4
 LDA XX18+8
 STA XX15+5
 JMP LL89

.ovflw

 LSR XX18
 LSR XX18+6
 LSR XX18+3
 LDX #1

.LL92

 LDA XX12
 STA XX15
 LDA XX12+2
 STA XX15+2
 LDA XX12+4

.LL93

 DEX
 BMI LL94
 LSR XX15
 LSR XX15+2
 LSR A
 DEX
 BPL LL93+3

.LL94

 STA R
 LDA XX12+5
 STA S
 LDA XX18+6
 STA Q
 LDA XX18+8
 JSR LL38
 BCS ovflw
 STA XX15+4
 LDA S
 STA XX15+5
 LDA XX15
 STA R
 LDA XX12+1
 STA S
 LDA XX18
 STA Q
 LDA XX18+2
 JSR LL38
 BCS ovflw
 STA XX15
 LDA S
 STA XX15+1
 LDA XX15+2
 STA R
 LDA XX12+3
 STA S
 LDA XX18+3
 STA Q
 LDA XX18+5
 JSR LL38
 BCS ovflw
 STA XX15+2
 LDA S
 STA XX15+3

.LL89

 LDA XX12
 STA Q
 LDA XX15
 JSR FMLTU
 STA T
 LDA XX12+1
 EOR XX15+1
 STA S
 LDA XX12+2
 STA Q
 LDA XX15+2
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX12+3
 EOR XX15+3
 JSR LL38
 STA T
 LDA XX12+4
 STA Q
 LDA XX15+4
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX15+5
 EOR XX12+5
 JSR LL38
 PHA
 TYA
 LSR A
 LSR A
 TAX
 PLA
 BIT S
 BMI P%+4
 LDA #0
 STA XX2,X
 INY

.LL88

 CPY XX20
 BCS LL42
 JMP LL86

.LL42

 \ndeX-Ycrds
 \TrnspMat
 LDY XX16+2
 LDX XX16+3
 LDA XX16+6
 STA XX16+2
 LDA XX16+7
 STA XX16+3
 STY XX16+6
 STX XX16+7
 LDY XX16+4
 LDX XX16+5
 LDA XX16+12
 STA XX16+4
 LDA XX16+13
 STA XX16+5
 STY XX16+12
 STX XX16+13
 LDY XX16+10
 LDX XX16+11
 LDA XX16+14
 STA XX16+10
 LDA XX16+15
 STA XX16+11
 STY XX16+14
 STX XX16+15
 LDY #8
 LDA (XX0),Y
 STA XX20
 LDA XX0
 CLC
 ADC #20
 STA V
 LDA XX0+1
 ADC #0
 STA V+1
 LDY #0
 STY CNT

.LL48

 STY XX17
 LDA (V),Y
 STA XX15
 INY
 LDA (V),Y
 STA XX15+2
 INY
 LDA (V),Y
 STA XX15+4
 INY
 LDA (V),Y
 STA T
 AND #31
 CMP XX4
 BCC LL49-3
 INY
 LDA (V),Y
 STA P
 AND #15
 TAX
 LDA XX2,X
 BNE LL49
 LDA P
 LSR A
 LSR A
 LSR A
 LSR A
 TAX
 LDA XX2,X
 BNE LL49
 INY
 LDA (V),Y
 STA P
 AND #15
 TAX
 LDA XX2,X
 BNE LL49
 LDA P
 LSR A
 LSR A
 LSR A
 LSR A
 TAX
 LDA XX2,X
 BNE LL49
 JMP LL50

.LL49

 LDA T
 STA XX15+1
 ASL A
 STA XX15+3
 ASL A
 STA XX15+5
 JSR LL51
 LDA XX1+2
 STA XX15+2
 EOR XX12+1
 BMI LL52
 CLC
 LDA XX12
 ADC XX1
 STA XX15
 LDA XX1+1
 ADC #0
 STA XX15+1
 JMP LL53

.LL52

 LDA XX1
 SEC
 SBC XX12
 STA XX15
 LDA XX1+1
 SBC #0
 STA XX15+1
 BCS LL53
 EOR #$FF
 STA XX15+1
 LDA #1
 SBC XX15
 STA XX15
 BCC P%+4
 INC XX15+1
 LDA XX15+2
 EOR #128
 STA XX15+2

.LL53

 LDA XX1+5
 STA XX15+5
 EOR XX12+3
 BMI LL54
 CLC
 LDA XX12+2
 ADC XX1+3
 STA XX15+3
 LDA XX1+4
 ADC #0
 STA XX15+4
 JMP LL55

.LL54

 LDA XX1+3
 SEC
 SBC XX12+2
 STA XX15+3
 LDA XX1+4
 SBC #0
 STA XX15+4
 BCS LL55
 EOR #255
 STA XX15+4
 LDA XX15+3
 EOR #255
 ADC #1
 STA XX15+3
 LDA XX15+5
 EOR #128
 STA XX15+5
 BCC LL55
 INC XX15+4

.LL55

 LDA XX12+5
 BMI LL56
 LDA XX12+4
 CLC
 ADC XX1+6
 STA T
 LDA XX1+7
 ADC #0
 STA U
 JMP LL57

.LL61

 LDX Q
 BEQ LL84
 LDX #0

.LL63

 LSR A
 INX
 CMP Q
 BCS LL63
 STX S
 JSR LL28
 LDX S
 LDA R

.LL64

 ASL A
 ROL U
 BMI LL84
 DEX
 BNE LL64
 STA R
 RTS

.LL84

 LDA #50
 STA R
 STA U
 RTS

.LL62

 LDA #128
 SEC
 SBC R
 STA XX3,X
 INX
 LDA #0
 SBC U
 STA XX3,X
 JMP LL66

.LL56

 LDA XX1+6
 SEC
 SBC XX12+4
 STA T
 LDA XX1+7
 SBC #0
 STA U
 BCC LL140
 BNE LL57
 LDA T
 CMP #4
 BCS LL57

.LL140

 LDA #0
 STA U
 LDA #4
 STA T

.LL57

 LDA U
 ORA XX15+1
 ORA XX15+4
 BEQ LL60
 LSR XX15+1
 ROR XX15
 LSR XX15+4
 ROR XX15+3
 LSR U
 ROR T
 JMP LL57

.LL60

 LDA T
 STA Q
 LDA XX15
 CMP Q
 BCC LL69
 JSR LL61
 JMP LL69+3

.LL69

 JSR LL28
 LDX CNT
 LDA XX15+2
 BMI LL62
 LDA R
 CLC
 ADC #128
 STA XX3,X
 INX
 LDA U
 ADC #0
 STA XX3,X

.LL66

 TXA
 PHA
 LDA #0
 STA U
 LDA T
 STA Q
 LDA XX15+3
 CMP Q
 BCC LL67
 JSR LL61
 JMP LL68

.LL70

 LDA #Y
 CLC
 ADC R
 STA XX3,X
 INX
 LDA #0
 ADC U
 STA XX3,X
 JMP LL50

.LL67

 JSR LL28

.LL68

 PLA
 TAX
 INX
 LDA XX15+5
 BMI LL70
 LDA #Y
 SEC
 SBC R
 STA XX3,X
 INX
 LDA #0
 SBC U
 STA XX3,X

.LL50

 CLC
 LDA CNT
 ADC #4
 STA CNT
 LDA XX17
 ADC #6
 TAY
 BCS LL72
 CMP XX20
 BCS LL72
 JMP LL48

.LL72

 LDA XX1+31
 AND #32
 BEQ EE31
 LDA XX1+31
 ORA #8
 STA XX1+31
 JMP DOEXP

.EE31

 LDA #8
 BIT XX1+31
 BEQ LL74
 JSR LL155
 LDA #8

.LL74

 ORA XX1+31
 STA XX1+31
 LDY #9
 LDA (XX0),Y
 STA XX20
 LDY #0
 STY U
 STY XX17
 INC U
 BIT XX1+31
 BVC LL170
 LDA XX1+31
 AND #$BF
 STA XX1+31
 LDY #6
 LDA (XX0),Y
 TAY
 LDX XX3,Y
 STX XX15
 INX
 BEQ LL170
 LDX XX3+1,Y
 STX XX15+1
 INX
 BEQ LL170
 LDX XX3+2,Y
 STX XX15+2
 LDX XX3+3,Y
 STX XX15+3
 LDA #0
 STA XX15+4
 STA XX15+5
 STA XX12+1
 LDA XX1+6
 STA XX12
 LDA XX1+2
 BPL P%+4
 DEC XX15+4
 JSR LL145
 BCS LL170
 LDY U
 LDA XX15
 STA (XX19),Y
 INY
 LDA XX15+1
 STA (XX19),Y
 INY
 LDA XX15+2
 STA (XX19),Y
 INY
 LDA XX15+3
 STA (XX19),Y
 INY
 STY U

.LL170

 \nw lns
 LDY #3
 CLC
 LDA (XX0),Y
 ADC XX0
 STA V
 LDY #16
 LDA (XX0),Y
 ADC XX0+1
 STA V+1
 LDY #5
 LDA (XX0),Y
 STA T1
 LDY XX17

.LL75

 LDA (V),Y
 CMP XX4
 BCC LL79-3
 INY
 LDA (V),Y
 INY
 STA P
 AND #15
 TAX
 LDA XX2,X
 BNE LL79
 LDA P
 LSR A
 LSR A
 LSR A
 LSR A
 TAX
 LDA XX2,X
 BNE LL79
 JMP LL78

.LL79

 LDA (V),Y
 TAX
 INY
 LDA (V),Y
 STA Q
 LDA XX3+1,X
 STA XX15+1
 LDA XX3,X
 STA XX15
 LDA XX3+2,X
 STA XX15+2
 LDA XX3+3,X
 STA XX15+3
 LDX Q
 LDA XX3,X
 STA XX15+4
 LDA XX3+3,X
 STA XX12+1
 LDA XX3+2,X
 STA XX12
 LDA XX3+1,X
 STA XX15+5
 JSR LL147
 BCS LL79-3
 JMP LL80

.LL145

 \CLIP
 LDA #0
 STA SWAP
 LDA XX15+5

.LL147

 BIT dontclip
 BMI LL146
 LDX #Y*2-1
 ORA XX12+1
 BNE LL107
 CPX XX12
 BCC LL107
 LDX #0

.LL107

 STX XX13
 LDA XX15+1
 ORA XX15+3
 BNE LL83
 LDA #Y*2-1
 CMP XX15+2
 BCC LL83
 LDA XX13
 BNE LL109+2

.LL146

 LDA XX15+2
 STA XX15+1
 LDA XX15+4
 STA XX15+2
 LDA XX12
 STA XX15+3
 CLC
 RTS

.LL109

 SEC
 RTS
 LSR XX13

.LL83

 LDA XX13
 BPL LL115
 LDA XX15+1
 AND XX15+5
 BMI LL109
 LDA XX15+3
 AND XX12+1
 BMI LL109
 LDX XX15+1
 DEX
 TXA
 LDX XX15+5
 DEX
 STX XX12+2
 ORA XX12+2
 BPL LL109
 LDA XX15+2
 CMP #Y*2
 LDA XX15+3
 SBC #0
 STA XX12+2
 LDA XX12
 CMP #Y*2
 LDA XX12+1
 SBC #0
 ORA XX12+2
 BPL LL109

.LL115

 TYA
 PHA
 LDA XX15+4
 SEC
 SBC XX15
 STA XX12+2
 LDA XX15+5
 SBC XX15+1
 STA XX12+3
 LDA XX12
 SEC
 SBC XX15+2
 STA XX12+4
 LDA XX12+1
 SBC XX15+3
 STA XX12+5
 EOR XX12+3
 STA S
 LDA XX12+5
 BPL LL110
 LDA #0
 SEC
 SBC XX12+4
 STA XX12+4
 LDA #0
 SBC XX12+5
 STA XX12+5

.LL110

 LDA XX12+3
 BPL LL111
 SEC
 LDA #0
 SBC XX12+2
 STA XX12+2
 LDA #0
 SBC XX12+3
 \GETgrad

.LL111

 TAX
 BNE LL112
 LDX XX12+5
 BEQ LL113

.LL112

 LSR A
 ROR XX12+2
 LSR XX12+5
 ROR XX12+4
 JMP LL111

.LL113

 STX T
 LDA XX12+2
 CMP XX12+4
 BCC LL114
 STA Q
 LDA XX12+4
 JSR LL28
 \ Use Y/X grad.
 JMP LL116

.LL114

 LDA XX12+4
 STA Q
 LDA XX12+2
 JSR LL28
 \ Use X/Y grad.
 DEC T

.LL116

 LDA R
 STA XX12+2
 LDA S
 STA XX12+3
 LDA XX13
 BEQ P%+4
 BPL LLX117
 JSR LL118
 LDA XX13
 BPL LL124

.LL117

 LDA XX15+1
 ORA XX15+3
 BNE LL137
 LDA XX15+2
 CMP #Y*2
 BCS LL137

.LLX117

 LDX XX15
 LDA XX15+4
 STA XX15
 STX XX15+4
 LDA XX15+5
 LDX XX15+1
 STX XX15+5
 STA XX15+1
 LDX XX15+2
 LDA XX12
 STA XX15+2
 STX XX12
 LDA XX12+1
 LDX XX15+3
 STX XX12+1
 STA XX15+3
 JSR LL118
 DEC SWAP

.LL124

 PLA
 TAY
 JMP LL146

.LL137

 PLA
 TAY
 SEC
 RTS

.LL80

 LDY U
 LDA XX15
 STA (XX19),Y
 INY
 LDA XX15+1
 STA (XX19),Y
 INY
 LDA XX15+2
 STA (XX19),Y
 INY
 LDA XX15+3
 STA (XX19),Y
 INY
 STY U
 CPY T1
 BCS LL81

.LL78

 INC XX17
 LDY XX17
 CPY XX20
 BCS LL81
 LDY #0
 LDA V
 ADC #4
 \"
 STA V
 BCC ll81
 INC V+1

.ll81

 JMP LL75

.LL81

 LDA U
 LDY #0
 STA (XX19),Y

.LL155

 \ CLEAR LINEstr
 LDY #0
 LDA (XX19),Y
 STA XX20
 CMP #4
 BCC LL82
 INY

.LL27

 LDA (XX19),Y
 STA XX15
 INY
 LDA (XX19),Y
 STA XX15+1
 INY
 LDA (XX19),Y
 STA XX15+2
 INY
 LDA (XX19),Y
 STA XX15+3
 JSR LL30
 INY
 CPY XX20
 BCC LL27

.LL82

 RTS

.LL118

 \mv XX15,XX15+2 to scrn-grd.XX12+2
 LDA XX15+1
 BPL LL119
 STA S
 JSR LL120 ;X1<0
 TXA
 CLC
 ADC XX15+2
 STA XX15+2
 TYA
 ADC XX15+3
 STA XX15+3
 LDA #0
 STA XX15
 STA XX15+1
 TAX

.LL119

 BEQ LL134
 STA S
 DEC S
 JSR LL120 ;X1>FF
 TXA
 CLC
 ADC XX15+2
 STA XX15+2
 TYA
 ADC XX15+3
 STA XX15+3
 LDX #$FF
 STX XX15
 INX
 STX XX15+1

.LL134

 LDA XX15+3
 BPL LL135
 STA S
 LDA XX15+2
 STA R ;Y1<0
 JSR LL123
 TXA
 CLC
 ADC XX15
 STA XX15
 TYA
 ADC XX15+1
 STA XX15+1
 LDA #0
 STA XX15+2
 STA XX15+3

.LL135

;BNE LL139
 LDA XX15+2
 SEC
 SBC #Y*2
 STA R ;Y1>191
 LDA XX15+3
 SBC #0
 STA S
 BCC LL136

.LL139

 JSR LL123
 TXA
 CLC
 ADC XX15
 STA XX15
 TYA
 ADC XX15+1
 STA XX15+1
 LDA #Y*2-1
 STA XX15+2
 LDA #0
 STA XX15+3

.LL136

 RTS
 \YX = SR*M/256

.LL120

 LDA XX15
 STA R
 \.LL120
 JSR LL129
 PHA
 LDX T
 BNE LL121

.LL122

 LDA #0
 TAX
 TAY
 LSR S
 ROR R
 ASL Q
 BCC LL126

.LL125

 TXA
 CLC
 ADC R
 TAX
 TYA
 ADC S
 TAY

.LL126

 LSR S
 ROR R
 ASL Q
 BCS LL125
 BNE LL126
 PLA
 BPL LL133
 RTS
 \ YX = SR*256/M (M = grad.)

.LL123

 JSR LL129
 PHA
 LDX T
 BNE LL122

.LL121

 LDA #255
 TAY
 ASL A
 TAX

.LL130

 ASL R
 ROL S
 LDA S
 BCS LL131
 CMP Q
 BCC LL132

.LL131

 SBC Q
 STA S
 LDA R
 SBC #0
 STA R
 SEC

.LL132

 TXA
 ROL A
 TAX
 TYA
 ROL A
 TAY
 BCS LL130
 PLA
 BMI LL128

.LL133

 TXA
 EOR #$FF
;CLC 
 ADC #1
 TAX
 TYA
 EOR #$FF
 ADC #0
 TAY

.LL128

 RTS

.LL129

 LDX XX12+2
 STX Q
 LDA S
 BPL LL127
 LDA #0
 SEC
 SBC R
 STA R
 LDA S
 PHA
 EOR #255
 ADC #0
 STA S
 PLA

.LL127

 EOR XX12+3
 RTS

; ******************************************************************************
;
; Save ELTG.bin
;
; ******************************************************************************

 PRINT "ELITE G"
 PRINT "Assembled at ", ~CODE_G%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_G%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_G%

 PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
 SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%

; ******************************************************************************
;
; ELITE H FILE
;
; Produces the binary file ELTH.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_H% = P%

 LOAD_H% = LOAD% + P% - CODE%

.MVEIT

 LDA INWK+31
 AND #$A0
 BNE MV30
 LDA MCNT
 EOR XSAV
 AND #15
 BNE MV3
 JSR TIDY

.MV3

 LDX TYPE
 BPL P%+5
 JMP MV40
 LDA INWK+32
 BPL MV30
 CPX #MSL
 BEQ MV26
 LDA MCNT
 EOR XSAV
 AND #7
 BNE MV30

.MV26

 JSR TACTICS

.MV30

 JSR SCAN
 LDA INWK+27
 ASL A
 ASL A
 STA Q
 LDA INWK+10
 AND #127
 JSR FMLTU
 STA R
 LDA INWK+10
 LDX #0
 JSR MVT1-2
 LDA INWK+12
 AND #127
 JSR FMLTU
 STA R
 LDA INWK+12
 LDX #3
 JSR MVT1-2
 LDA INWK+14
 AND #127
 JSR FMLTU
 STA R
 LDA INWK+14
 LDX #6
 JSR MVT1-2
 LDA INWK+27
 CLC
 ADC INWK+28
 BPL P%+4
 LDA #0
 LDY #15
 CMP (XX0),Y
 BCC P%+4
 LDA (XX0),Y
 STA INWK+27
 LDA #0
 STA INWK+28
 LDX ALP1
 LDA INWK
 EOR #$FF
 STA P
 LDA INWK+1
 JSR MLTU2-2
 STA P+2
 LDA ALP2+1
 EOR INWK+2
 LDX #3
 JSR MVT6
 STA K2+3
 LDA P+1
 STA K2+1
 EOR #$FF
 STA P
 LDA P+2
 STA K2+2 ; K2 = Y-aX
 LDX BET1
 JSR MLTU2-2
 STA P+2
 LDA K2+3
 EOR BET2
 LDX #6
 JSR MVT6
 STA INWK+8
 LDA P+1
 STA INWK+6
 EOR #$FF
 STA P
 LDA P+2
 STA INWK+7 ; Z = Z+bK2
 JSR MLTU2
 STA P+2
 LDA K2+3
 STA INWK+5
 EOR BET2
 EOR INWK+8
 BPL MV43
 LDA P+1
 ADC K2+1
 STA INWK+3
 LDA P+2
 ADC K2+2
 STA INWK+4
 JMP MV44

.MV43

 LDA K2+1
 SBC P+1
 STA INWK+3
 LDA K2+2
 SBC P+2
 STA INWK+4
 BCS MV44
 LDA #1
 SBC INWK+3
 STA INWK+3
 LDA #0
 SBC INWK+4
 STA INWK+4
 LDA INWK+5
 EOR #128
 STA INWK+5

.MV44 ; Y = K2-bZ 

 LDX ALP1
 LDA INWK+3
 EOR #$FF
 STA P
 LDA INWK+4
 JSR MLTU2-2
 STA P+2
 LDA ALP2
 EOR INWK+5
 LDX #0
 JSR MVT6
 STA INWK+2
 LDA P+2
 STA INWK+1
 LDA P+1
 STA INWK ; X = X+aY

.MV45

 LDA DELTA
 STA R
 LDA #128
 LDX #6
 JSR MVT1
 LDA TYPE
 AND #$81
 CMP #$81
 BNE P%+3
 RTS ;Z = Z-d
 LDY #9
 JSR MVS4
 LDY #15
 JSR MVS4
 LDY #21
 JSR MVS4
 LDA INWK+30
 AND #128
 STA RAT2
 LDA INWK+30
 AND #127
 BEQ MV8
 CMP #127
 SBC #0
 ORA RAT2
 STA INWK+30
 LDX #15
 LDY #9
 JSR MVS5
 LDX #17
 LDY #11
 JSR MVS5
 LDX #19
 LDY #13
 JSR MVS5

.MV8

 LDA INWK+29
 AND #128
 STA RAT2
 LDA INWK+29
 AND #127
 BEQ MV5
 CMP #127
 SBC #0
 ORA RAT2
 STA INWK+29
 LDX #15
 LDY #21
 JSR MVS5
 LDX #17
 LDY #23
 JSR MVS5
 LDX #19
 LDY #25
 JSR MVS5

.MV5

 LDA INWK+31
 AND #$A0
 BNE MVD1
 LDA INWK+31
 ORA #16
 STA INWK+31
 JMP SCAN

.MVD1

 LDA INWK+31
 AND #$EF
 STA INWK+31
 RTS
 AND #128

.MVT1

 ASL A
 STA S
 LDA #0
 ROR A
 STA T
 LSR S
 EOR INWK+2,X
 BMI MV10
 LDA R
 ADC INWK,X
 STA INWK,X
 LDA S
 ADC INWK+1,X
 STA INWK+1,X
 LDA INWK+2,X
 ADC #0
 ORA T
 STA INWK+2,X
 RTS

.MV10

 LDA INWK,X
 SEC
 SBC R
 STA INWK,X
 LDA INWK+1,X
 SBC S
 STA INWK+1,X
 LDA INWK+2,X
 AND #127
 SBC #0
 ORA #128
 EOR T
 STA INWK+2,X
 BCS MV11
 LDA #1
 SBC INWK,X
 STA INWK,X
 LDA #0
 SBC INWK+1,X
 STA INWK+1,X
 LDA #0
 SBC INWK+2,X
 AND #127
 ORA T
 STA INWK+2,X

.MV11

 RTS

.MVS4

 LDA ALPHA
 STA Q
 LDX INWK+2,Y
 STX R
 LDX INWK+3,Y
 STX S
 LDX INWK,Y
 STX P
 LDA INWK+1,Y
 EOR #128
 JSR MAD
 STA INWK+3,Y
 STX INWK+2,Y
 STXP ; Y = Y-aX
 LDX INWK,Y
 STX R
 LDX INWK+1,Y
 STX S
 LDA INWK+3,Y
 JSR MAD
 STA INWK+1,Y
 STX INWK,Y
 STXP ; X = X+aY
 LDA BETA
 STA Q
 LDX INWK+2,Y
 STX R
 LDX INWK+3,Y
 STX S
 LDX INWK+4,Y
 STX P
 LDA INWK+5,Y
 EOR #128
 JSR MAD
 STA INWK+3,Y
 STX INWK+2,Y
 STXP ; Y = Y-bZ
 LDX INWK+4,Y
 STX R
 LDX INWK+5,Y
 STX S
 LDA INWK+3,Y
 JSR MAD
 STA INWK+5,Y
 STX INWK+4,Y
 RTS ;Z = Z+bY

.MVT6

 TAY
 EOR INWK+2,X
 BMI MV50
 LDA P+1
 CLC
 ADC INWK,X
 STA P+1
 LDA P+2
 ADC INWK+1,X
 STA P+2
 TYA
 RTS

.MV50

 LDA INWK,X
 SEC
 SBC P+1
 STA P+1
 LDA INWK+1,X
 SBC P+2
 STA P+2
 BCC MV51
 TYA
 EOR #128
 RTS

.MV51

 LDA #1
 SBC P+1
 STA P+1
 LDA #0
 SBC P+2
 STA P+2
 TYA
 RTS

.MV40

 LDA ALPHA
 EOR #128
 STA Q
 LDA INWK
 STA P
 LDA INWK+1
 STA P+1
 LDA INWK+2
 JSR MULT3
 LDX #3
 JSR MVT3 ; K = Y-aX
 LDA K+1
 STA K2+1
 STA P
 LDA K+2
 STA K2+2
 STA P+1
 LDA BETA
 STA Q
 LDA K+3
 STA K2+3
 JSR MULT3
 LDX #6
 JSR MVT3
 LDA K+1
 STA P
 STA INWK+6
 LDA K+2
 STA P+1
 STA INWK+7
 LDA K+3
 STA INWK+8 ; Z = Z+bK2
 EOR #128
 JSR MULT3
 LDA K+3
 AND #128
 STA T
 EOR K2+3
 BMI MV1
 LDA K
 CLC
 ADC K2
 LDA K+1
 ADC K2+1
 STA INWK+3
 LDA K+2
 ADC K2+2
 STA INWK+4
 LDA K+3
 ADC K2+3
 JMP MV2

.MV1

 LDA K
 SEC
 SBC K2
 LDA K+1
 SBC K2+1
 STA INWK+3
 LDA K+2
 SBC K2+2
 STA INWK+4
 LDA K2+3
 AND #127
 STA P
 LDA K+3
 AND #127
 SBC P
 STA P
 BCS MV2
 LDA #1
 SBC INWK+3
 STA INWK+3
 LDA #0
 SBC INWK+4
 STA INWK+4
 LDA #0
 SBC P
 ORA #128

.MV2

 EOR T
 STA INWK+5 ; Y = K2-bZ
 LDA ALPHA
 STA Q
 LDA INWK+3
 STA P
 LDA INWK+4
 STA P+1
 LDA INWK+5
 JSR MULT3
 LDX #0
 JSR MVT3
 LDA K+1
 STA INWK
 LDA K+2
 STA INWK+1
 LDA K+3
 STA INWK+2 ; X = X+aY
 JMP MV45

.Checksum

 SEC
 LDY #0
 STY V
 LDX #$10
 LDA (SC),Y ; ,,
 TXA

.CHKLoop

 STX V+1
 STY T
 ADC (V),Y
 EOR T
 SBC V+1
 DEY
 BNE CHKLoop
 INX
 CPX #$A0
 BCC CHKLoop
 CMP S%-1
 BNE Checksum
 RTS

.PLUT

 LDX VIEW
 BEQ PU2-1

.PU1

 DEX
 BNE PU2
 LDA INWK+2
 EOR #128
 STA INWK+2
 LDA INWK+8
 EOR #128
 STA INWK+8
 LDA INWK+10
 EOR #128
 STA INWK+10
 LDA INWK+14
 EOR #128
 STA INWK+14
 LDA INWK+16
 EOR #128
 STA INWK+16
 LDA INWK+20
 EOR #128
 STA INWK+20
 LDA INWK+22
 EOR #128
 STA INWK+22
 LDA INWK+26
 EOR #128
 STA INWK+26
 RTS

.PU2

 LDA #0
 CPX #2
 ROR A
 STA RAT2
 EOR #128
 STA RAT
 LDA INWK
 LDX INWK+6
 STA INWK+6
 STX INWK
 LDA INWK+1
 LDX INWK+7
 STA INWK+7
 STX INWK+1
 LDA INWK+2
 EOR RAT
 TAX
 LDA INWK+8
 EOR RAT2
 STA INWK+2
 STX INWK+8
 LDY #9
 JSR PUS1
 LDY #15
 JSR PUS1
 LDY #21

.PUS1

 LDA INWK,Y
 LDX INWK+4,Y
 STA INWK+4,Y
 STX INWK,Y
 LDA INWK+1,Y
 EOR RAT
 TAX
 LDA INWK+5,Y
 EOR RAT2
 STA INWK+1,Y
 STX INWK+5,Y

.LO2

 RTS

.LQ

 STX VIEW
 JSR TT66
 JSR SIGHT
 JMP NWSTARS

.LOOK1

 LDA #0
 JSR DOVDU19
 LDY QQ11
 BNE LQ
 CPX VIEW
 BEQ LO2
 STX VIEW
 JSR TT66
 JSR FLIP
 JSR WPSHPS

.SIGHT

 LDA #5
 JSR SETL1
 LDY VIEW
 LDA LASER,Y
 BEQ SIG3

IF _GMA85_NTSC OR _GMA86_PAL

 LDY #$A0

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDY #$C4

ENDIF

 CMP #POW
 BEQ SIG1
 INY
 CMP #(POW+128)
 BEQ SIG1
 INY
 CMP #Armlas
 BEQ SIG1
 INY

.SIG1

 STY $63F8
 STY $67F8

IF _GMA85_NTSC OR _GMA86_PAL

 LDA sightcol-$A0,Y

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDA sightcol-$C4,Y

ENDIF

 STA VIC+$27
 LDA #1

.SIG3

 STA T
 LDA TRIBBLE+1
 AND #127
 LSR A
 LSR A
 LSR A
 LSR A
;LSR A
;ORA #3
 TAX
 LDA TRIBTA,X
 STA TRIBCT
 LDA TRIBMA,X
 ORA T
 STA VIC+$15
 LDA #4
 JMP SETL1

.TRIBTA

 EQUB 0
 EQUB 1
 EQUB 2
 EQUB 3
 EQUB 4
 EQUB 5
 EQUB 6
 EQUB 6

.TRIBMA

 EQUB 0
 EQUB 4
 EQUB $C
 EQUB $1C
 EQUB $3C
 EQUB $7C
 EQUB $FC
 EQUB $FC

.TT66

 STA QQ11

.TTX66

 JSR MT2
;JSR PBZE
;JSR HBZE
 LDA #0
 \\STALBUP
 STA LSP
 LDA #128
 STA QQ17
 STA DTW2
 JSR FLFLLS
;LDA #YELLOW
;JSR DOCOL
 LDA #0
 STA LAS2
 STA DLY
 STA de ; ,,
 LDA #1
 STA XC
 STA YC
 JSR TTX66K
 LDX QQ22+1
 BEQ OLDBOX
 JSR ee3

.OLDBOX 

 LDA #1
 JSR DOYC
 LDA QQ11
 BNE tt66
 LDA #11
 JSR DOXC
 LDA VIEW
 ORA #$60
 JSR TT27
 JSR TT162
 LDA #175
 JSR TT27

.tt66

 LDX #1
 STX XC
 STX YC
 DEX
 STX QQ17
 RTS

; ******************************************************************************
;
; Save ELTH.bin
;
; ******************************************************************************

 PRINT "ELITE H"
 PRINT "Assembled at ", ~CODE_H%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_H%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_H%

 PRINT "S.ELTH ", ~CODE_H%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_H%
 SAVE "3-assembled-output/ELTH.bin", CODE_H%, P%, LOAD%

; ******************************************************************************
;
; ELITE I FILE
;
; Produces the binary file ELTI.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_I% = P%

 LOAD_I% = LOAD% + P% - CODE%

.yetanotherrts 

.DEMON

 RTS ;<<

.ECMOF

 LDA #0
 STA ECMA
 STA ECMP
 JSR ECBLB
 LDY #sfxecm
 JMP NOISEOFF

.SFRMIS

 LDX #MSL
 JSR SFS1-2
 BCC yetanotherrts
 LDA #$78
 JSR MESS
 LDY #sfxwhosh
 JMP NOISE

.EXNO2

 LDA TALLYL
 CLC
 ADC KWL%-1,X
 STA TALLYL
 LDA TALLY
 ADC KWH%-1,X
 STA TALLY
 BCC davidscockup
 INC TALLY+1
 LDA #101
 JSR MESS

.davidscockup

 LDA INWK+7
 LDX #$B
 CMP #16
 BCS quiet2
 INX
 CMP #8
 BCS quiet2
 INX
 CMP #6
 BCS quiet2
 INX
 CMP #3
 BCS quiet2
 INX

.quiet2

 TXA
 ASL A
 ASL A
 ASL A
 ASL A
 ORA #3
 LDY #sfxexpl
 LDX #$51
 JMP NOISE2

.EXNO

 LDA INWK+7
 LDX #$B
 CMP #8
 BCS quiet
 INX
 CMP #4
 BCS quiet
 INX
 CMP #3
 BCS quiet
 INX
 CMP #2
 BCS quiet
 INX

.quiet

 TXA
 ASL A
 ASL A
 ASL A
 ASL A
 ORA #3
 LDY #sfxhit
 LDX #$D0
 JMP NOISE2
 \...................

.BEEP

 LDY #sfxbeep
 BNE NOISE

.EXNO3

 LDY #sfxexpl
 BNE NOISE

.SOFLUSH

 LDY #3
 LDA #1

.SOUL2

 STA SOCNT-1,Y
 DEY
 BNE SOUL2

.SOUR1

 RTS  ;!!

.NOISEOFF

 LDX #3
 INY
 STY XX15+2

.SOUL1

 DEX
 BMI SOUR1
 LDA SOFLG,X
 AND #63
 CMP XX15+2
 BNE SOUL1
 LDA #1
 STA SOCNT,X
 RTS

.HYPNOISE

 LDY #sfxhyp1
 LDA #$F5
 LDX #$F0
 JSR NOISE2
 LDY #sfxwhosh
 JSR NOISE
 LDY #1
 JSR DELAY
 LDY #(sfxhyp1+128)
 BNE NOISE

.NOISE2

 BIT SOUR1
;SEV 
 STA XX15
 STX XX15+1
 EQUB $50
;BVC   -Vol in A, Freq in X

.NOISE

 CLV
 LDA DNOIZ
 BNE SOUR1
 LDX #2
 INY
 STY XX15+2
 DEY
 LDA SFXPR,Y
 LSR A
 BCS SOUX9 ;dont flush

.SOUX7

 LDA SOFLG,X
 AND #63
 CMP XX15+2
 BEQ SOUX6
 DEX
 BPL SOUX7

.SOUX9

 LDX #0
 LDA SOPR
 CMP SOPR+1
 BCC SOUX1
 INX
 LDA SOPR+1

.SOUX1

 CMP SOPR+2
 BCC P%+4
 LDX #2

.SOUX6

 \X contains ch no.
 TYA
 AND #127
 TAY
 LDA SFXPR,Y
 CMP SOPR,X
 BCC SOUR1
 SEI
 STA SOPR,X
 BVS SOUX4
 LDA SFXSUS,Y
 EQUB $CD
;CMP abs

.SOUX4

 LDA XX15
 STA SOSUS,X
 LDA SFXCNT,Y
 STA SOCNT,X
 LDA SFXFRCH,Y
 STA SOFRCH,X
 LDA SFXCR,Y
 STA SOCR,X
 BVS SOUX5
 LDA SFXFQ,Y
 EQUB $CD

.SOUX5

 LDA XX15+1
 STA SOFRQ,X
 LDA SFXATK,Y
 STA SOATK,X
 LDA SFXVCH,Y
 STA SOVCH,X
 INY
 TYA
 ORA #128
 STA SOFLG,X
 CLI
 SEC
 RTS
 \............

.RASTCT

 EQUB 0

.zebop

 EQUB $81

.abraxas

 EQUB $81

.innersec

 EQUB 1
 EQUB 0

.shango

 EQUB 51+143
 EQUB 51

.moonflower

 EQUB $C0

.caravanserai

 EQUB $C0

.santana

 EQUB $FE
 EQUB $FC

.lotus

 EQUB 2
 EQUB 0

.welcome

 EQUB 0
 EQUB 0

.SOUL3b

 DEY
 BPL SOUL8
 PLA
 TAY

.COMIRQ3

 PLA
 TAX
 LDA l1
 AND #$F8
 ORA L1M
 STA l1
 PLA
 RTI

.COMIRQ1

 PHA
 LDA l1
 AND #$F8
 ORA #5
 STA l1
 \Page in I/O

.iansint

 LDA VIC+$19
 ORA #128
 STA VIC+$19
 TXA
 PHA
 LDX RASTCT
 LDA zebop,X
 STA VIC+$18
 LDA moonflower,X
 STA VIC+$16 ;Mode Change
 LDA shango,X
 STA VIC+$12 ;Raster
 LDA santana,X
 STA VIC+$1C ;Multicol
 LDA lotus,X
 STA VIC+$28 ;Sp1Col
 BIT BOMB
 BPL nobombef
 INC welcome

.nobombef

 LDA welcome,X
 STA VIC+$21
 LDA innersec,X
 STA RASTCT
 BNE COMIRQ3
 TYA
 PHA
 BIT MUPLA
 BPL SOINT
 JSR BDirqhere
 BIT MUSILLY
 BMI SOINT
 JMP coffee

.SOINT

 LDY #2

.SOUL8

 LDA SOFLG,Y
 BEQ SOUL3b
 BMI SOUL4
 LDX SEVENS,Y
 LDA SOFRCH,Y
 BEQ SOUL5
 BNE SOUX2
;EQUB $2C

.SOUL4

 LDA SEVENS,Y
 STA SOUX3+1 ; %%
 LDA #0
 LDX #6

.SOUX3

 STA SID,X
 DEX
 BPL SOUX3
 LDX SEVENS,Y
 LDA SOCR,Y
 STA SID+4,X
 LDA SOATK,Y
 STA SID+5,X
 LDA SOSUS,Y
 STA SID+6,X
 LDA #0

.SOUX2

 CLC
 CLD
 ADC SOFRQ,Y
 STA SOFRQ,Y
 PHA
 LSR A
 LSR A
 STA SID+1,X
 PLA
 ASL A
 ASL A
 ASL A
 ASL A
 ASL A
 ASL A
 STA SID,X
 LDA PULSEW
 STA SID+3,X

.SOUL5

 LDA SOFLG,Y
 BMI SOUL6
 TYA
 TAX
 DEC SOPR,X
 BNE P%+5
 INC SOPR,X
 DEC SOCNT,X
 BEQ SOKILL
 LDA SOCNT,X
 AND SOVCH,Y
 BNE SOUL3
 LDA SOSUS,Y
 SEC
 SBC #16
 STA SOSUS,Y
 LDX SEVENS,Y
 STA SID+6,X
 JMP SOUL3

.SOKILL

 LDX SEVENS,Y
 LDA SOCR,Y
 AND #$FE
 STA SID+4,X
 LDA #0
 STA SOFLG,Y
 STA SOPR,Y
 BEQ SOUL3

.SOUL6 

 AND #127
 STA SOFLG,Y

.SOUL3

 DEY
 BMI P%+5
 JMP SOUL8 ;**
 LDA PULSEW
 EOR #4
 STA PULSEW
;LDA #1
;STA intcnt

.coffee

 PLA
 TAY
 PLA
 TAX
 LDA l1
 AND #$F8
 ORA L1M
 STA l1
 PLA
 RTI 

.SOFLG

 EQUB 0
 EQUB 0
 EQUB 0

.SOCNT

 EQUB 0
 EQUB 0
 EQUB 0

.SOPR

 EQUB 0
 EQUB 0
 EQUB 0

.PULSEW

 EQUB 2

.SOFRCH

 EQUB 0
 EQUB 0
 EQUB 0

.SOFRQ

 EQUB 0
 EQUB 0
 EQUB 0

.SOCR

 EQUB 0
 EQUB 0
 EQUB 0

.SOATK

 EQUB 0
 EQUB 0
 EQUB 0

.SOSUS

 EQUB 0
 EQUB 0
 EQUB 0

.SOVCH

 EQUB 0
 EQUB 0
 EQUB 0

.SEVENS

 EQUB 0
 EQUB 7
 EQUB 14

 \        0-Plas  1-Elas  2-Hit   3-Expl  4-Whosh 5-Beep  6-Boop  7-Hyp1  8-Eng   9-ECM  10-Blas 11-Alas 12-Mlas          14-Trib

.SFXPR

 EQUB $72
 EQUB $70
 EQUB $74
 EQUB $77
 EQUB $73
 EQUB $68
 EQUB $60
 EQUB $F0
 EQUB $30
 EQUB $FE
 EQUB $72
 EQUB $72
 EQUB $92
 EQUB $E1
 EQUB $51
 EQUB $02

.SFXCNT

 EQUB $14
 EQUB $0E
 EQUB $0C
 EQUB $50
 EQUB $3F
 EQUB $05
 EQUB $18
 EQUB $80
 EQUB $30
 EQUB $FF
 EQUB $10
 EQUB $10
 EQUB $70
 EQUB $40
 EQUB $0F
 EQUB $0E

.SFXFQ

 EQUB $45
 EQUB $48
 EQUB $D0
 EQUB $51
 EQUB $40
 EQUB $F0
 EQUB $40
 EQUB $80
 EQUB $10
 EQUB $50
 EQUB $34
 EQUB $33
 EQUB $60
 EQUB $55
 EQUB $80
 EQUB $40

.SFXCR

 EQUB $41
 EQUB $11
 EQUB $81
 EQUB $81
 EQUB $81
 EQUB $11
 EQUB $11
 EQUB $41
 EQUB $21
 EQUB $41
 EQUB $21
 EQUB $21
 EQUB $11
 EQUB $81
 EQUB $11
 EQUB $21

.SFXATK

 EQUB $01
 EQUB $09
 EQUB $20
 EQUB $08
 EQUB $0C
 EQUB $00
 EQUB $63
 EQUB $18
 EQUB $44
 EQUB $11
 EQUB $00
 EQUB $00
 EQUB $44
 EQUB $11
 EQUB $18
 EQUB $09

.SFXSUS

 EQUB $D1
 EQUB $F1
 EQUB $E5
 EQUB $FB
 EQUB $DC
 EQUB $F0
 EQUB $F3
 EQUB $D8
 EQUB $00
 EQUB $E1
 EQUB $E1
 EQUB $F1
 EQUB $F4
 EQUB $E3
 EQUB $B0
 EQUB $A1

.SFXFRCH

 EQUB $FE
 EQUB $FE
 EQUB $F3
 EQUB $FF
 EQUB $00
 EQUB $00
 EQUB $00
 EQUB $44
 EQUB $00
 EQUB $55
 EQUB $FE
 EQUB $FF
 EQUB $EF
 EQUB $77
 EQUB $7B
 EQUB $FE

.SFXVCH

 EQUB $03
 EQUB $03
 EQUB $03
 EQUB $0F
 EQUB $0F
 EQUB $FF
 EQUB $FF
 EQUB $1F
 EQUB $FF
 EQUB $FF
 EQUB $03
 EQUB $03
 EQUB $0F
 EQUB $FF
 EQUB $FF
 EQUB $03

.COLD

 \Page out KERNAL etc
 LDA #4
 STA SC+1
 LDX #3
 LDA #0
 STA SC
 TAY

.zerowksploop

 STA (SC),Y
 INY
 BNE zerowksploop
 INC SC+1
 DEX
 BNE zerowksploop
 LDA #(NMIpissoff MOD 256)
 STA NMIV
 LDA #(NMIpissoff DIV 256)
 STA NMIV+1
 LDA #(CHPR2 MOD 256)
 STA CHRV
 LDA #(CHPR2 DIV 256)
 STA CHRV+1
 LDA #5
 JSR SETL1 ; I/O in
 SEI

IF NOT(USA%)

 LDA #PALCK

.UKCHK

 BIT VIC+$11
 BPL UKCHK
 CMP VIC+$12
 BNE UKCHK  ;UK Machine?

ENDIF

 LDA #3
 STA CIA+$D
 STA CIA2+$D ; kill CIAs  \<<
;LDA #2
;STA VIC+$20
 LDA #$F
 STA SID+$18 ;Volume
 LDX #0
 STX RASTCT
 INX
 STX VIC+$1A ;enable Raster int
 LDA VIC+$11
 AND #$7F
 STA VIC+$11
 LDA #40
 STA VIC+$12 ;set first Raster int
 LDA l1
 AND #$F8
 ORA #4
 STA l1
 LDA #4
 STA L1M ;I/O out
 LDA #(NMIpissoff MOD 256)
 STA $FFFA
 LDA #(NMIpissoff DIV 256)
 STA $FFFB
 LDA #(COMIRQ1 DIV 256)
 STA $FFFF
 LDA #(COMIRQ1 MOD 256)
 STA $FFFE
 CLI ;Sound
 RTS

.NMIpissoff

 CLI
 RTI

; ******************************************************************************
;
; Save ELTI.bin
;
; ******************************************************************************

 PRINT "ELITE I"
 PRINT "Assembled at ", ~CODE_I%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_I%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_I%

 PRINT "S.ELTI ", ~CODE_I%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_H%
 SAVE "3-assembled-output/ELTI.bin", CODE_I%, P%, LOAD%

; ******************************************************************************
;
; ELITE J FILE
;
; Produces the binary file ELTJ.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_J% = P%

 LOAD_J% = LOAD% + P% - CODE%

{
 Pa = P
 P = T+1
 Q = T+2
 R = T+3
 S = T+4
 T = T+5
 T1 = T+6
; SC = FNZTZT(2)
; SCH = SC+1
; FF = $FF
 OSWRCH = $FFEE
 OSBYTE = $FFF4
 OSWORD = $FFF1
 OSFILE = $FFDD
 SCLI = $FFF7
 VIA = $FE40
 USVIA = VIA
 IRQ1V = $204
 VSCAN = 57
 XX21 = D%
 WRCHV = $20E
 WORDV = $20C
 RDCHV = $210
 protlen = 0
 BULBCOL = $E0
 ECELL = SCBASE+$2400+23*40+11
 SCELL = SCBASE+$2400+23*40+28
 MCELL = SCBASE+$2400+24*40+6

.STARTUP

 LDA #$FF
 STA COL

 \ ............. OSWRCH revectored bumbling ..................... 

.PUTBACK

 RTS  ;LDA#128

;.DOHFX ;STAHFX
;JMP PUTBACK ;Hyperspace colours

.DOCOL

 STA COL
 RTS

.DOSVN

;STA svn
;JMP PUTBACK 

 \  ...................... Scanners  .............................. 

.TWOS

 EQUD &10204080
 EQUD &01020408
 EQUW $4080

.DTWOS

 EQUD &030C30C0

.TWOS2

 EQUD &3060C0C0
 EQUD &03060C18

.CTWOS2

 EQUD &3030C0C0
 EQUD &03030C0C
 EQUW $C0C0 

.LIJT1

 EQUB (LI81 MOD 256)
 EQUB (LI82 MOD 256)
 EQUB (LI83 MOD 256)
 EQUB (LI84 MOD 256)
 EQUB (LI85 MOD 256)
 EQUB (LI86 MOD 256)
 EQUB (LI87 MOD 256)
 EQUB (LI88 MOD 256)

.LIJT2

 EQUB (LI81 DIV 256)
 EQUB (LI82 DIV 256)
 EQUB (LI83 DIV 256)
 EQUB (LI84 DIV 256)
 EQUB (LI85 DIV 256)
 EQUB (LI86 DIV 256)
 EQUB (LI87 DIV 256)
 EQUB (LI88 DIV 256)

.LIJT3

 EQUB ((LI81+6)MOD 256)
 EQUB ((LI82+6)MOD 256)
 EQUB ((LI83+6)MOD 256)
 EQUB ((LI84+6)MOD 256)
 EQUB ((LI85+6)MOD 256)
 EQUB ((LI86+6)MOD 256)
 EQUB ((LI87+6)MOD 256)
 EQUB ((LI88+6)MOD 256)

.LIJT4

 EQUB ((LI81+6)DIV 256)
 EQUB ((LI82+6)DIV 256)
 EQUB ((LI83+6)DIV 256)
 EQUB ((LI84+6)DIV 256)
 EQUB ((LI85+6)DIV 256)
 EQUB ((LI86+6)DIV 256)
 EQUB ((LI87+6)DIV 256)
 EQUB ((LI88+6)DIV 256)
 \...

.LIJT5

 EQUB (LI21 MOD 256)
 EQUB (LI22 MOD 256)
 EQUB (LI23 MOD 256)
 EQUB (LI24 MOD 256)
 EQUB (LI25 MOD 256)
 EQUB (LI26 MOD 256)
 EQUB (LI27 MOD 256)
 EQUB (LI28 MOD 256)

.LIJT6

 EQUB (LI21 DIV 256)
 EQUB (LI22 DIV 256)
 EQUB (LI23 DIV 256)
 EQUB (LI24 DIV 256)
 EQUB (LI25 DIV 256)
 EQUB (LI26 DIV 256)
 EQUB (LI27 DIV 256)
 EQUB (LI28 DIV 256)

.LIJT7

 EQUB ((LI21+6)MOD 256)
 EQUB ((LI22+6)MOD 256)
 EQUB ((LI23+6)MOD 256)
 EQUB ((LI24+6)MOD 256)
 EQUB ((LI25+6)MOD 256)
 EQUB ((LI26+6)MOD 256)
 EQUB ((LI27+6)MOD 256)
 EQUB ((LI28+6)MOD 256)

.LIJT8

 EQUB ((LI21+6)DIV 256)
 EQUB ((LI22+6)DIV 256)
 EQUB ((LI23+6)DIV 256)
 EQUB ((LI24+6)DIV 256)
 EQUB ((LI25+6)DIV 256)
 EQUB ((LI26+6)DIV 256)
 EQUB ((LI27+6)DIV 256)
 EQUB ((LI28+6)DIV 256)

 \............. Line Draw .............. 

.^LL30 

.^LOIN

 STY YSAV
 LDA #128
 STA S
 ASL A
 STA SWAP
 LDA X2
 SBC X1
 BCS LI1
 EOR #$FF
 ADC #1

.LI1

 STA P
 SEC
 LDA Y2
 SBC Y1
 BCS LI2
 EOR #$FF
 ADC #1

.LI2

 STA Q
 CMP P
 BCC STPX
 JMP STPY

.STPX

 LDX X1
 CPX X2
 BCC LI3
 DEC SWAP
 LDA X2
 STA X1
 STX X2
 TAX
 LDA Y2
 LDY Y1
 STA Y1
 STY Y2

.LI3

 LDX Q
 BEQ LIlog7
 LDA logL,X
 LDX P
 SEC
 SBC logL,X
 BMI LIlog4
 LDX Q
 LDA log,X
 LDX P
 SBC log,X
 BCS LIlog5
 TAX
 LDA antilog,X
 JMP LIlog6

.LIlog5

 LDA #$FF
 BNE LIlog6

.LIlog7

 LDA #0
 BEQ LIlog6

.LIlog4

 LDX Q
 LDA log,X
 LDX P
 SBC log,X
 BCS LIlog5
 TAX
 LDA antilogODD,X

.LIlog6

 STA Q
 CLC
 LDY Y1
 CPY Y2
 BCS P%+5
 JMP DOWN
 LDA X1
 AND #$F8
 CLC
 ADC ylookupl,Y
 STA SC
 LDA ylookuph,Y
 ADC #0
 STA SC+1
 TYA
 AND #7
 TAY
 LDA X1
 AND #7
 TAX
 BIT SWAP
 BMI LI70
 LDA LIJT1,X
 STA LI71+1
 LDA LIJT2,X
 STA LI71+2
 LDX P

.LI71

 JMP $8888 ;~~!!

.LI70

 LDA LIJT3,X
 STA LI72+1
 LDA LIJT4,X
 STA LI72+2
 LDX P
 INX
 BEQ LIE1 ; **

.LI72

 JMP $8888 ;~~!!

.LIE1

 LDY YSAV
 RTS

.LI81

 LDA #$80
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE1
 LDA S
 ADC Q
 STA S
 BCC LI82
 DEY
 BPL LI82-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI82

 LDA #$40
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE1
 LDA S
 ADC Q
 STA S
 BCC LI83
 DEY
 BPL LI83-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI83

 LDA #$20
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE1
 LDA S
 ADC Q
 STA S
 BCC LI84
 DEY
 BPL LI84-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI84

 LDA #$10
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE1
 LDA S
 ADC Q
 STA S
 BCC LI85
 DEY
 BPL LI85-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI85

 LDA #$08
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE0S
 LDA S
 ADC Q
 STA S
 BCC LI86
 DEY
 BPL LI86-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI86

 LDA #$04
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE0
 LDA S
 ADC Q
 STA S
 BCC LI87
 DEY
 BPL LI87-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI87

 LDA #$02
 EOR (SC),Y
 STA (SC),Y
 DEX

.LIE0S

 BEQ LIE0
 LDA S
 ADC Q
 STA S
 BCC LI88
 DEY
 BPL LI88-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI88

 LDA #$01
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE0
 LDA S
 ADC Q
 STA S
 BCC LI89
 DEY
 BPL LI89-1
 LDA SC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1
 LDY #7
 CLC

.LI89

 LDA SC
 ADC #8
 STA SC
 BCS P%+5
 JMP LI81
 INC SC+1
 JMP LI81

.LIE0

 LDY YSAV
 RTS
 \.....

.DOWN

 LDA ylookuph,Y
 STA SC+1
 LDA X1
 AND #$F8
 ADC ylookupl,Y
 STA SC
 BCC P%+5
 INC SC+1
 CLC
 SBC #$F7
 STA SC
 BCS P%+4
 DEC SC+1
 TYA
 AND #7
 EOR #$F8
 TAY
 LDA X1
 AND #7
 TAX
 BIT SWAP
 BMI LI90
 LDA LIJT5,X
 STA LI91+1
 LDA LIJT6,X
 STA LI91+2
 LDX P
 BEQ LIE0

.LI91

 JMP $8888 ;~~!!

.LI90

 LDA LIJT7,X
 STA LI92+1
 LDA LIJT8,X
 STA LI92+2
 LDX P
 INX
 BEQ LIE0 ; **

.LI92

 JMP $8888 ;~~!!

.LIE3

 LDY YSAV
 RTS

.LI21

 LDA #$80
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE3
 LDA S
 ADC Q
 STA S
 BCC LI22
 INY
 BNE LI22-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI22

 LDA #$40
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE3
 LDA S
 ADC Q
 STA S
 BCC LI23
 INY
 BNE LI23-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI23

 LDA #$20
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE3
 LDA S
 ADC Q
 STA S
 BCC LI24
 INY
 BNE LI24-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI24

 LDA #$10
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE2S
 LDA S
 ADC Q
 STA S
 BCC LI25
 INY
 BNE LI25-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI25

 LDA #$08
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE2S
 LDA S
 ADC Q
 STA S
 BCC LI26
 INY
 BNE LI26-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI26

 LDA #$04
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE2
 LDA S
 ADC Q
 STA S
 BCC LI27
 INY
 BNE LI27-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI27

 LDA #$02
 EOR (SC),Y
 STA (SC),Y
 DEX

.LIE2S

 BEQ LIE2
 LDA S
 ADC Q
 STA S
 BCC LI28
 INY
 BNE LI28-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI28

 LDA #$01
 EOR (SC),Y
 STA (SC),Y
 DEX
 BEQ LIE2
 LDA S
 ADC Q
 STA S
 BCC LI29
 INY
 BNE LI29-1
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 LDY #$F8
 CLC

.LI29

 LDA SC
 ADC #8
 STA SC
 BCC P%+4
 INC SC+1
 JMP LI21

.LIE2

 LDY YSAV
 RTS

 \.... 

.STPY

 LDY Y1
 TYA
 LDX X1
 CPY Y2
 BCS LI15
 DEC SWAP
 LDA X2
 STA X1
 STX X2
 TAX
 LDA Y2
 STA Y1
 STY Y2
 TAY

.LI15

 TXA
 AND #$F8
 CLC
 ADC ylookupl,Y
 STA SC
 LDA ylookuph,Y
 ADC #0
 STA SC+1
 TYA
 AND #7
 TAY
 TXA
 AND #7
 TAX
 LDA TWOS,X
 STA R
 LDX P
 BEQ LIfudge
 LDA logL,X
 LDX Q
 SEC
 SBC logL,X
 BMI LIloG
 LDX P
 LDA log,X
 LDX Q
 SBC log,X
 BCS LIlog3
 TAX
 LDA antilog,X
 JMP LIlog2

.LIlog3

 LDA #$FF
 BNE LIlog2

.LIloG

 LDX P
 LDA log,X
 LDX Q
 SBC log,X
 BCS LIlog3
 TAX
 LDA antilogODD,X

.LIlog2

 STA P

.LIfudge

 SEC
 LDX Q
 INX
 LDA X2
 SBC X1
 BCC LFT
 CLC
 LDA SWAP
 BEQ LI17
 DEX

.LIL5

 LDA R
 EOR (SC),Y
 STA (SC),Y

.LI17

 DEY
 BPL LI16
 LDA SC
 SBC #$3F
 STA SC
 LDA SCH
 SBC #1
 STA SCH
 LDY #7

.LI16

 LDA S
 ADC P
 STA S
 BCC LIC5
 LSR R
 BCC LIC5
 ROR R
 LDA SC
 ADC #8
 STA SC
 BCC P%+5
 INC SCH
 CLC

.LIC5

 DEX
 BNE LIL5
 LDY YSAV
 RTS

.LFT

 LDA SWAP
 BEQ LI18
 DEX

.LIL6

 LDA R
 EOR (SC),Y
 STA (SC),Y

.LI18

 DEY
 BPL LI19
 LDA SC
 SBC #$3F
 STA SC
 LDA SCH
 SBC #1
 STA SCH
 LDY #7

.LI19

 LDA S
 ADC P
 STA S
 BCC LIC6
 ASL R
 BCC LIC6
 ROL R
 LDA SC
 SBC #7
 STA SC
 BCS P%+4
 DEC SCH
 CLC

.LIC6

 DEX
 BNE LIL6
 LDY YSAV

.HL6

 RTS
 \ ............HLOIN.......... 

.^HLOIN

 STY YSAV
 LDX X1
 CPX X2
 BEQ HL6
 BCC HL5
 LDA X2
 STA X1
 STX X2
 TAX

.HL5

 DEC X2
 LDA Y1
 TAY
 AND #7
 STA SC
 LDA ylookuph,Y
 STA SC+1
 TXA
 AND #$F8
 CLC
 ADC ylookupl,Y
 TAY
 BCC P%+4
 INC SC+1

.HL1

 TXA
 AND #$F8
 STA T
 LDA X2
 AND #$F8
 SEC
 SBC T
 BEQ HL2
 LSR A
 LSR A
 LSR A
 STA R
 LDA X1
 AND #7
 TAX
 LDA TWFR,X
 EOR (SC),Y
 STA (SC),Y
 TYA
 ADC #8
 TAY
 BCC P%+4
 INC SC+1
 LDX R
 DEX
 BEQ HL3
 CLC

.HLL1

 LDA #$FF
 EOR (SC),Y
 STA (SC),Y
 TYA
 ADC #8
 TAY
 BCC P%+5
 INC SC+1
 CLC
 DEX
 BNE HLL1

.HL3

 LDA X2
 AND #7
 TAX
 LDA TWFL,X
 EOR (SC),Y
 STA (SC),Y
 LDY YSAV
 RTS

.HL2

 LDA X1
 AND #7
 TAX
 LDA TWFR,X
 STA T
 LDA X2
 AND #7
 TAX
 LDA TWFL,X
 AND T
 EOR (SC),Y
 STA (SC),Y
 LDY YSAV
 RTS

;.TWFL

 EQUD &F0E0C080
 EQUW $FCF8
 EQUB $FE

;.TWFR

 EQUD &1F3F7FFF
 EQUD &0103070F
 \................... 

.^DOT

 LDA COMY
 STA Y1
 LDA COMX
 STA X1
 LDA COMC
 STA COL
 CMP #YELLOW
 BNE CPIX2

.CPIX4

 JSR CPIX2
 DEC Y1

.CPIX2

 LDY Y1
 LDA X1
 AND #$F8
 CLC
 ADC ylookupl,Y
 STA SC
 LDA ylookuph,Y
 ADC #0
 STA SC+1
 TYA
 AND #7
 TAY
 LDA X1
 AND #7
 TAX
 LDA CTWOS2,X
 AND COL
 EOR (SC),Y
 STA (SC),Y
;JSR P%+3
;INX 
 LDA CTWOS2+2,X
 BPL CP1
 LDA SC
 CLC
 ADC #8
 STA SC
 BCC P%+4
 INC SC+1
 LDA CTWOS2+2,X

.CP1

 AND COL
 EOR (SC),Y
 STA (SC),Y
 RTS
 \...........

.^ECBLB2

 LDA #32
 STA ECMA
 LDY #sfxecm
 JSR NOISE

.^ECBLB

 LDA ECELL
 EOR #BULBCOL
 STA ECELL
 LDA ECELL+40
 EOR #BULBCOL
 STA ECELL+40
 RTS

.^SPBLB

 LDA SCELL
 EOR #BULBCOL
 STA SCELL
 LDA SCELL+40
 EOR #BULBCOL
 STA SCELL+40
 RTS

.^MSBAR

 DEX
 TXA
 INX
 EOR #3
 STY SC
 TAY
 LDA SC
 STA MCELL,Y
 LDY #0
 RTS ;pres X,y = 0 on exit,a = Yin

.newosrdch

 JSR $FFFF
 CMP #128
 BCC P%+6

.badkey

 LDA #7
 CLC
 RTS
 CMP #32
 BCS coolkey
 CMP #13
 BEQ coolkey
 CMP #21
 BNE badkey

.coolkey

 CLC
 RTS
 \ADD AX = AP+SR  Should be in ELITEC (?)

 \..........Bay View.......... 

.^WSCAN

 PHA

.WSC1

 LDA RASTCT
 BEQ WSC1

.WSC2

 LDA RASTCT
 BNE WSC2
 PLA
 RTS

 \ ............. Character Print ..................... 

.^CHPR2

 CMP #123
 BCS whosentthisshit
 CMP #13
 BCC whosentthisshit
 BNE CHPR
 LDA #12
 JSR CHPR
 LDA #13

.whosentthisshit

 CLC
 RTS  ; tape CHPR

.R5

 JSR BEEP
 JMP RR4

.clss

 JSR TT66simp
 LDA K3
 JMP RRafter

.RR4S

 JMP RR4

.TT67
.^TT67_copy

 LDA #12

.^CHPR

 \PRINT   Rewrite for Mode 4 Map
 STA K3
 STY YSAV2
 STX XSAV2
 LDY QQ17
 CPY #$FF
 BEQ RR4S

.RRafter

 CMP #7
 BEQ R5
 CMP #32
 BCS RR1
 CMP #10
 BEQ RRX1

.RRX2

 LDX #1
 STX XC

.RRX1

 CMP #13
 BEQ RR4S
 INC YC
 BNE RR4S

.RR1

 TAY
 LDX #((FONT DIV 256)-1)
 ASL A
 ASL A
 BCC P%+4
 LDX #((FONT DIV 256)+1)
 ASL A
 BCC P%+3
 INX
 STA Pa+1
 STX Pa+2
 LDA XC
 CMP #31
 BCS RRX2
 LDA #128
 STA SC
 LDA YC
 CMP #24
 BCC RR3
 JMP clss

.RR3

 LSR A
 ROR SC
 LSR A
 ROR SC
 ADC YC
 ADC #(SCBASE DIV 256)
 STA SC+1
 LDA XC
 ASL A
 ASL A
 ASL A
 ADC SC
 STA SC
 BCC P%+4
 INC SC+1
 CPY #$7F
 BNE RR2
 DEC XC
 DEC SC+1
 LDY #$F8
 JSR ZESNEW
 BEQ RR4

.RR2

 INC XC
 EQUB $2C
 STA SC+1
 LDY #7

.RRL1

 LDA (Pa+1),Y
 EOR (SC),Y
 STA (SC),Y
 DEY
 BPL RRL1
 LDY YC
 LDA celllookl,Y
 STA SC
 LDA celllookh,Y
 STA SC+1
 LDY XC
 LDA COL2
 STA (SC),Y

.RR4

 LDY YSAV2
 LDX XSAV2
 LDA K3
 CLC
 RTS ;must exit CHPR with C = 0
 \
 \.....TTX66K......
 \

.^TTX66K

 LDA #4
 STA SC
 LDA #$60
 STA SC+1
 LDX #24

.BOL3

 LDA #$10
 LDY #31

.BOL4

 STA (SC),Y
 DEY
 BPL BOL4
 LDA SC
 CLC
 ADC #40
 STA SC
 BCC P%+4
 INC SC+1
 DEX
 BNE BOL3
 LDX #(SCBASE DIV 256)

.BOL1

 JSR ZES1k
 INX
 CPX #((DLOC% DIV 256))
 BNE BOL1
 LDY #((DLOC%MOD 256)-1)
 JSR ZES2k
 STA (SC),Y ; <<
 LDA #1
 STA XC
 STA YC
 LDA QQ11
 BEQ wantSTEP
 CMP #13
 BNE P%+5

.wantSTEP

 JMP wantdials
 LDA #$81
 STA abraxas
 LDA #$C0
 STA caravanserai

.BOL2

 JSR ZES1k
 INX
 CPX #((SCBASE DIV 256)+$20)
 BNE BOL2
 LDX #0
 STX COMC
 STX DFLAG
 INX
 STX XC
 STX YC
 JSR BLUEBAND
 JSR zonkscanners
 JSR NOSPRITES
 LDY #31
 LDA #$70

.BOL5

 STA $6004,Y
 DEY
 BPL BOL5 ;Top Row Yellow
 LDX QQ11
 CPX #2
 BEQ BOX
 CPX #64
 BEQ BOX
 CPX #128
 BEQ BOX
 LDY #31

.BOL6

 STA $6054,Y
 DEY
 BPL BOL6 ;Third Row Yellow

.^BOX

 LDX #199
 JSR BOXS
 LDA #$FF
 STA SCBASE+$1F1F ; <<
 LDX #25
 EQUB $2C

.BOX2

 LDX #18
 STX T
 LDY #((SCBASE+$18)MOD 256)
 STY SC
 LDY #((SCBASE+$18)DIV 256)
 LDA #3
 JSR BOXS2
 LDY #((SCBASE+$120)MOD 256)
 STY SC
 LDY #((SCBASE+$120)DIV 256)
 LDA #$C0
 LDX T
 JSR BOXS2
 LDA #1
 STA SCBASE+$118 ; <<
 LDX #0

.BOXS

 STX Y1

 LDX #0
 STX X1
 DEX
 STX X2
 JMP HLOIN

.BOXS2

 STA R
 STY SC+1

.BOXL2

 LDY #7

.BOXL3

 LDA R
 EOR (SC),Y
 STA (SC),Y
 DEY
 BPL BOXL3
 LDA SC
 CLC
 ADC #$40
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 DEX
 BNE BOXL2
 RTS
 \....

.wantdials

 JSR BOX2
 LDA #$91
 STA abraxas
 LDA #$D0
 STA caravanserai
 LDA DFLAG
 BNE nearlyxmas
 LDX #8
 LDA #(DSTORE%MOD 256)
 STA V
 LDA #(DSTORE%DIV 256)
 STA V+1
 LDA #(DLOC%MOD 256)
 STA SC
 LDA #(DLOC%DIV 256)
 STA SC+1
 JSR mvblockK
 LDY #$C0
 LDX #1
 JSR mvbllop
 JSR zonkscanners
 JSR DIALS

.nearlyxmas

 JSR BLUEBAND
 JSR NOSPRITES
 LDA #$FF
 STA DFLAG
 RTS

.zonkscanners

 LDX #0

.zonkL

 LDA FRIN,X
 BEQ zonk1
 BMI zonk2
 JSR GINF
 LDY #31
 LDA (INF),Y
 AND #$EF
 STA (INF),Y

.zonk2

 INX
 BNE zonkL

.zonk1

 RTS
 \....

.BLUEBAND

 LDX #((SCBASE)MOD 256)
 LDY #((SCBASE)DIV 256)
 JSR BLUEBANDS
 LDX #((SCBASE+$128)MOD 256)
 LDY #((SCBASE+$128)DIV 256)

.BLUEBANDS

 STX SC
 STY SC+1
 LDX #18

.BLUEL2

 LDY #23

.BLUEL1

 LDA #$FF
 STA (SC),Y
 DEY
 BPL BLUEL1
 LDA SC
 CLC
 ADC #$40
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 DEX
 BNE BLUEL2
 RTS
 \.......

.TT66simp

 LDX #8
 LDY #0
 CLC

.T6SL1

 LDA ylookupl,X
 STA SC
 LDA ylookuph,X
 STA SC+1
 TYA

.T6SL2

 STA (SC),Y
 DEY
 BNE T6SL2
 TXA
 ADC #8
 TAX
 CMP #24*8
 BCC T6SL1
 INY
 STY XC
 STY YC
 RTS
 \....

.ZES1k

 LDY #0
 STY SC

.ZES2k

 LDA #0
 STX SC+1

.ZEL1k

 STA (SC),Y
 DEY
 BNE ZEL1k
 RTS

.ZESNEW

 LDA #0

.ZESNEWL

 STA (SC),Y
 INY
 BNE ZESNEWL
 RTS

.SETXC

 STA XC
 RTS  ;JMPPUTBACK

.SETYC

 STA YC
 RTS  ;JMPPUTBACK 

.mvblockK

 LDY #0

.mvbllop

 LDA (V),Y
 STA (SC),Y
 DEY
 BNE mvbllop
 INC V+1
 INC SC+1
 DEX
 BNE mvbllop
 RTS  ;remember ELITEK has different SC! 

.^CLYNS

 LDA #0
 STA DLY
 STA de

.CLYNS2

 LDA #$FF
 STA DTW2
 LDA #128
 STA QQ17
 LDA #21
 STA YC
 LDA #1
 STA XC
 LDA #((SCBASE DIV 256)+$1A)
 STA SC+1
 LDA #$60
 STA SC
 LDX #3

.CLYLOOP2

 LDA #0
 TAY

.CLYLOOP

 STA (SC),Y
 DEY
 BNE CLYLOOP
 CLC
 LDA SC
 ADC #$40
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1
 DEX
 BNE CLYLOOP2

.SCR1

 RTS 

.^SCAN

 LDA QQ11
 BNE SCR1
 LDA INWK+31
 AND #16
 BEQ SCR1
 LDX TYPE
 BMI SCR1
 LDA scacol,X
 STA COL
 LDA INWK+1
 ORA INWK+4
 ORA INWK+7
 AND #$C0
 BNE SCR1
 LDA INWK+1
 CLC
 LDX INWK+2
 BPL SC2
 EOR #$FF
 ADC #1

.SC2

 ADC #123
 STA X1
 LDA INWK+7
 LSR A
 LSR A
 CLC
 LDX INWK+8
 BPL SC3
 EOR #$FF
 SEC

.SC3

 ADC #83 ;35
 EOR #$FF
 STA SC
 LDA INWK+4
 LSR A
 CLC
 LDX INWK+5
 BMI SCD6
 EOR #$FF
 SEC

.SCD6

 ADC SC
;BPL ld246
 CMP #146 ;194
 BCS P%+4
 LDA #146
 CMP #199 ;247
 BCC P%+4

.ld246

 LDA #198 ;246
 STA Y1
 SEC
 SBC SC
 PHP
;BCS SC48
;EOR #$FF
;ADC #1

.SC48

 PHA
 JSR CPIX4
 LDA CTWOS2+2,X
 AND COL
 STA X1
 PLA
 PLP
 TAX
 BEQ RTS
 BCC VL3

.VLL1

 DEY
 BPL VL1
 LDY #7
 LDA SC
 SEC
 SBC #$40
 STA SC
 LDA SC+1
 SBC #1
 STA SC+1

.VL1

 LDA X1
 EOR (SC),Y
 STA (SC),Y
 DEX
 BNE VLL1

.RTS

 RTS

.VL3

 INY
 CPY #8
 BNE VLL2
 LDY #0
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1

.VLL2

 INY
 CPY #8
 BNE VL2
 LDY #0
 LDA SC
 ADC #$3F
 STA SC
 LDA SC+1
 ADC #1
 STA SC+1

.VL2

 LDA X1
 EOR (SC),Y
 STA (SC),Y
 INX
 BNE VLL2
 RTS

}

; ******************************************************************************
;
; Save ELTJ.bin
;
; ******************************************************************************

 PRINT "ELITE J"
 PRINT "Assembled at ", ~CODE_J%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_J%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_J%

 PRINT "S.ELTJ ", ~CODE_J%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_J%
 SAVE "3-assembled-output/ELTJ.bin", CODE_J%, P%, LOAD%

; ******************************************************************************
;
; ELITE K FILE
;
; Produces the binary file ELTK.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_K% = P%

 LOAD_K% = LOAD% + P% - CODE%

; Music driver by Dave Dunn.
;
; BBC source code converted
; from Commodore disassembly
; extremely badly
; Jez. 13/4/85.
;
; Music system (c)1985 D.Dunn.
; Modified by IB,DB
;
; Storage locations...

.value0

 EQUB 0

.value1

 EQUB 0

.value2

 EQUB 0

.value3

 EQUB 0

.value4

 EQUB 0
 \ The IRQ routine points here...
 \........................

IF _GMA85_NTSC OR _GMA86_PAL

 EQUW $8888

ENDIF

.BDirqhere

 LDY  #0
 \........................
 CPY  counter
 BEQ  BDskip1
 DEC  counter
 JMP  BDlab1

.BDskip1

 LDA BDBUFF
 CMP #16
 BCS BDLABEL2
 TAX
 BNE BDLABEL
 JSR BDlab19
 STA BDBUFF

.BDLABEL2

 AND #$F
 TAX

.BDLABEL

 LDA BDBUFF
 LSR A
 LSR A
 LSR A
 LSR A
 STA BDBUFF
 LDA BDJMPTBL-1,X
 STA BDJMP+1
 LDA BDJMPTBH-1,X
 STA BDJMP+2

.BDJMP

 JMP BDskip1
 \......

.BDRO1

 JSR  BDlab3
 JSR  BDlab4
 JMP  BDskip1
 \

.BDRO2

 JSR  BDlab5
 JSR  BDlab6
 JMP  BDskip1
 \

.BDRO3

 JSR  BDlab7
 JSR  BDlab8
 JMP  BDskip1
 \

.BDRO4

 JSR  BDlab3
 JSR  BDlab5
 JSR  BDlab4
 JSR  BDlab6
 JMP  BDskip1
 \

.BDRO5

 JSR  BDlab3
 JSR  BDlab5
 JSR  BDlab7
 JSR  BDlab4
 JSR  BDlab6
 JSR  BDlab8
 JMP  BDskip1
 \

.BDRO6

 INC  value0
 JMP  BDskip1
 \

.BDRO15

 LDA BDBUFF
 SEC
 ROL A
 ASL A
 ASL A
 ASL A
 STA BDBUFF

.BDRO8

 LDA  value4
 STA  counter
 JMP  BDirqhere
 \

.BDRO7

 JSR  BDlab19
 STA  $D405
 JSR  BDlab19
 STA  $D40C
 JSR  BDlab19
 STA  $D413
 JSR  BDlab19
 STA  $D406
 JSR  BDlab19
 STA  $D40D
 JSR  BDlab19
 STA  $D414
 JMP  BDskip1
 \

.BDRO9

 LDA #0
 STA BDBUFF
 LDA  BDdataptr3   ;Repeat
 STA  BDdataptr1
 LDA  BDdataptr4
 STA  BDdataptr2
 JMP  BDskip1
 \

.BDRO10

 JSR  BDlab19
 STA  $D402
 JSR  BDlab19
 STA  $D403
 JSR  BDlab19
 STA  $D409
 JSR  BDlab19
 STA  $D40A
 JSR  BDlab19
 STA  $D410
 JSR  BDlab19
 STA  $D411
 JMP  BDskip1
 \...................................

.BDRO11

 JMP BDRO9
 \...................................

.BDRO12

 JSR  BDlab19
 STA  value4
 JMP  BDskip1
 \

.BDRO13

 JSR  BDlab19
 STA  value1
 JSR  BDlab19
 STA  value2
 JSR  BDlab19
 STA  value3
 JMP  BDskip1
 \

.BDRO14

 JSR  BDlab19
 STA  $D418
 JSR  BDlab19
 STA  $D417
 JSR  BDlab19
 STA  $D416
 JMP  BDskip1
 \

.BDlab4

 LDA  value1
 STY  $D404
 STA  $D404
 RTS

.BDlab6

 LDA  value2
 STY  $D40B
 STA  $D40B
 RTS

.BDlab8

 LDA  value3
 STY  $D412
 STA  $D412
 RTS

.BDlab19

 INC  BDdataptr1
 BNE  BDskipme1
 INC  BDdataptr1+1

.BDskipme1

 LDA  (BDdataptr1),Y
 RTS

.BDlab3

 JSR  BDlab19
 STA  $D401
 JSR  BDlab19
 STA  $D400
 RTS

.BDlab5

 JSR  BDlab19
 STA  $D408
 STA  voice2lo1
 STA  voice2lo2
 JSR  BDlab19
 STA  $D407
 STA  voice2hi1
 STA  voice2hi2
 CLC
 CLD
 LDA  #$20
 ADC  voice2hi2
 STA  voice2hi2
 BCC  BDruts1
 INC  voice2lo2

.BDruts1

 RTS

.BDlab7

 JSR  BDlab19
 STA  $D40F
 STA  voice3lo1
 STA  voice3lo2
 JSR  BDlab19
 STA  $D40E
 STA  voice3hi1
 STA  voice3hi2
 CLC
 CLD

IF _GMA85_NTSC OR _GMA86_PAL

 LDA  #$25

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDA  #$20

ENDIF

 ADC  voice3hi2
 STA  voice3hi2
 BCC  BDruts2
 INC  voice3lo2

.BDruts2

 RTS
 \.............................................

.BDENTRY

 \.............................................
 LDA  #0
 STA BDBUFF
 STA  counter
 STA  vibrato2
 STA  vibrato3
 LDX  #$18

.BDloop2

 STA  $D400,X
 DEX
 BNE  BDloop2

IF _GMA85_NTSC OR _GMA86_PAL

 LDA $B4D0

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDA  #musicstart MOD 256

ENDIF

 STA  BDdataptr1
 STA  BDdataptr3

IF _GMA85_NTSC OR _GMA86_PAL

 LDA $B4D1

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDA  #musicstart DIV 256

ENDIF

 STA  BDdataptr2
 STA  BDdataptr4
 LDA  #$0F
 STA  $D418
;SEI 
 RTS  ;<<
 \ point IRQ to start
;LDA  #BDirqhere MOD 256
;STA  $0314
;LDA  #BDirqhere DIV 256
;STA  $0315
;CLI 
;BRK  ; re enter monitor!
 \........
 LDA  #0
 STA  vibrato2
 LDA  #$AE
 STA  BDbeqmod1+1
 LDA  voice2lo2
 STA  $D408
 LDA  voice2hi2
 STA  $D407
 JMP  BDlab21

.BDlab24

 LDA  #0
 STA  vibrato2
 LDA  #$98
 STA  BDbeqmod1+1
 LDA  voice2lo1
 STA  $D408
 LDA  voice2hi1
 STA  $D407
 JMP  BDlab21
 LDA  #0
 STA  vibrato3
 LDA  #$E2
 STA  BDbeqmod2+1
 LDA  voice3lo2
 STA  $D40F
 lda  voice3hi2
 STA  $D40E
 JMP  BDlab21

.BDlab23

 LDA  #0
 STA  vibrato3
 LDA  #$CC
 STA  BDbeqmod2+1
 LDA  voice3lo1
 STA  $D40F
 LDA  voice3hi1
 STA  $D40E
 JMP  BDlab21

.BDlab1

 INC  vibrato3

IF _GMA85_NTSC OR _GMA86_PAL

 LDA  #5

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDA  #6

ENDIF

 CMP  vibrato3

.BDbeqmod2

 BEQ  BDlab23
 INC  vibrato2

IF _GMA85_NTSC OR _GMA86_PAL

 LDA  #4

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 LDA  #5

ENDIF

 CMP  vibrato2

.BDbeqmod1

 BEQ  BDlab24

.BDlab21

 LDX  counter

IF _GMA85_NTSC OR _GMA86_PAL

 CPX  #0

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 CPX  #2

ENDIF

 BNE  BDexitirq
 LDX  value1
 DEX
 STX  $D404
 LDX  value2
 DEX
 STX  $D40B
 LDX  value3
 DEX
 STX  $D412

.BDexitirq

 RTS
 RTS  ;JMP $EA31

.BDJMPTBL

 EQUB (BDRO1 MOD 256)
 EQUB (BDRO2 MOD 256)
 EQUB (BDRO3 MOD 256)
 EQUB (BDRO4 MOD 256)
 EQUB (BDRO5 MOD 256)
 EQUB (BDRO6 MOD 256)
 EQUB (BDRO7 MOD 256)
 EQUB (BDRO8 MOD 256)
 EQUB (BDRO9 MOD 256)
 EQUB (BDRO10 MOD 256)
 EQUB (BDRO11 MOD 256)
 EQUB (BDRO12 MOD 256)
 EQUB (BDRO13 MOD 256)
 EQUB (BDRO14 MOD 256)
 EQUB (BDRO15 MOD 256)

.BDJMPTBH

 EQUB (BDRO1 DIV 256)
 EQUB (BDRO2 DIV 256)
 EQUB (BDRO3 DIV 256)
 EQUB (BDRO4 DIV 256)
 EQUB (BDRO5 DIV 256)
 EQUB (BDRO6 DIV 256)
 EQUB (BDRO7 DIV 256)
 EQUB (BDRO8 DIV 256)
 EQUB (BDRO9 DIV 256)
 EQUB (BDRO10 DIV 256)
 EQUB (BDRO11 DIV 256)
 EQUB (BDRO12 DIV 256)
 EQUB (BDRO13 DIV 256)
 EQUB (BDRO14 DIV 256)
.musicstart
 EQUB (BDRO15 DIV 256)

;musicstart = P%-1
;IF Z>4 OSCLI("L.:2.COMUDAT "+STR$~O%)
;P% = P%+$A38

IF _GMA85_NTSC OR _GMA86_PAL

 INCBIN "1-source-files/music/gma/C.COMUDAT.bin"

ELIF _SOURCE_DISC_FILES OR _SOURCE_DISK_BUILD

 INCBIN "1-source-files/music/source-disk/C.COMUDAT.bin"

ENDIF

IF _SOURCE_DISK_BUILD OR _SOURCE_DISC_FILES

 EQUB $28               ; C.THEME is not included in the encrypted HICODE binary
                        ; in the source disk variant, unlike the GMA85 variant

ELIF _GMA85_NTSC OR _GMA86_PAL

 INCBIN "1-source-files/music/gma/C.THEME.bin"

ENDIF

.F%

; ******************************************************************************
;
; Save ELTK.bin
;
; ******************************************************************************

 PRINT "ELITE K"
 PRINT "Assembled at ", ~CODE_K%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_K%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_K%

 PRINT "S.ELTK ", ~CODE_K%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_J%
 SAVE "3-assembled-output/ELTK.bin", CODE_K%, P%, LOAD%

; Flag knowledge of F%
 PRINT ~C%, F%, S%, K%, " (Free: ", $CD00-F%, " ", $4000-R%, ")  ZP: ", ~ZP
 PRINT " ZP: ", ~ZP, ", WP: ", ~WP, ", UP: ", ~UP

 PRINT "Addresses for the scramble routines in elite-checksum.py"
 PRINT "B% = ", ~CODE%
 PRINT "G% = ", ~G%
 PRINT "NA2% = ", ~NA2%

; ******************************************************************************
;
; ELITE SHIP BLUEPRINTS FILE
;
; Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_SHIPS% = D%

 LOAD_SHIPS% = LOAD% + D% - CODE%

 ORG D%

; ******************************************************************************
;
;       Name: XX21
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprints lookup table
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.XX21

 EQUW SHIP_MISSILE      ; MSL  =  1 = Missile
 EQUW SHIP_CORIOLIS     ; SST  =  2 = Coriolis space station
 EQUW SHIP_ESCAPE_POD   ; ESC  =  3 = Escape pod
 EQUW SHIP_PLATE        ; PLT  =  4 = Alloy plate
 EQUW SHIP_CANISTER     ; OIL  =  5 = Cargo canister
 EQUW SHIP_BOULDER      ;         6 = Boulder
 EQUW SHIP_ASTEROID     ; AST  =  7 = Asteroid
 EQUW SHIP_SPLINTER     ; SPL  =  8 = Splinter
 EQUW SHIP_SHUTTLE      ; SHU  =  9 = Shuttle
 EQUW SHIP_TRANSPORTER  ;        10 = Transporter
 EQUW SHIP_COBRA_MK_3   ; CYL  = 11 = Cobra Mk III
 EQUW SHIP_PYTHON       ;        12 = Python
 EQUW SHIP_BOA          ;        13 = Boa
 EQUW SHIP_ANACONDA     ; ANA  = 14 = Anaconda
 EQUW SHIP_ROCK_HERMIT  ; HER  = 15 = Rock hermit (asteroid)
 EQUW SHIP_VIPER        ; COPS = 16 = Viper
 EQUW SHIP_SIDEWINDER   ; SH3  = 17 = Sidewinder
 EQUW SHIP_MAMBA        ;        18 = Mamba
 EQUW SHIP_KRAIT        ; KRA  = 19 = Krait
 EQUW SHIP_ADDER        ; ADA  = 20 = Adder
 EQUW SHIP_GECKO        ;        21 = Gecko
 EQUW SHIP_COBRA_MK_1   ;        22 = Cobra Mk I
 EQUW SHIP_WORM         ; WRM  = 23 = Worm
 EQUW SHIP_COBRA_MK_3_P ; CYL2 = 24 = Cobra Mk III (pirate)
 EQUW SHIP_ASP_MK_2     ; ASP  = 25 = Asp Mk II
 EQUW SHIP_PYTHON_P     ;        26 = Python (pirate)
 EQUW SHIP_FER_DE_LANCE ;        27 = Fer-de-lance
 EQUW SHIP_MORAY        ;        28 = Moray
 EQUW SHIP_THARGOID     ; THG  = 29 = Thargoid
 EQUW SHIP_THARGON      ; TGL  = 30 = Thargon
 EQUW SHIP_CONSTRICTOR  ; CON  = 31 = Constrictor
 EQUW SHIP_COUGAR       ; COU  = 32 = Cougar
 EQUW SHIP_DODO         ; DOD  = 33 = Dodecahedron ("Dodo") space station

; ******************************************************************************
;
;       Name: E%
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprints default NEWB flags
;  Deep dive: Ship blueprints
;             Advanced tactics with the NEWB flags
;
; ------------------------------------------------------------------------------
;
; When spawning a new ship, the bits from this table are applied to the new
; ship's NEWB flags in byte #36 (i.e. a set bit in this table will set that bit
; in the NEWB flags). In other words, if a ship blueprint is set to one of the
; following, then all spawned ships of that type will be too: trader, bounty
; hunter, hostile, pirate, innocent, cop.
;
; The NEWB flags are as follows:
;
;   * Bit 0: Trader flag (0 = not a trader, 1 = trader)
;   * Bit 1: Bounty hunter flag (0 = not a bounty hunter, 1 = bounty hunter)
;   * Bit 2: Hostile flag (0 = not hostile, 1 = hostile)
;   * Bit 3: Pirate flag (0 = not a pirate, 1 = pirate)
;   * Bit 4: Docking flag (0 = not docking, 1 = docking)
;   * Bit 5: Innocent bystander (0 = normal, 1 = innocent bystander)
;   * Bit 6: Cop flag (0 = not a cop, 1 = cop)
;   * Bit 7: For spawned ships: ship been scooped or has docked
;             For blueprints: this ship type has an escape pod fitted
;
; See the deep dive on "Advanced tactics with the NEWB flags" for details of
; how this works.
;
; ******************************************************************************

.E%

 EQUB %00000000         ; Missile
 EQUB %00000000         ; Coriolis space station
 EQUB %00000001         ; Escape pod                                      Trader
 EQUB %00000000         ; Alloy plate
 EQUB %00000000         ; Cargo canister
 EQUB %00000000         ; Boulder
 EQUB %00000000         ; Asteroid
 EQUB %00000000         ; Splinter
 EQUB %00100001         ; Shuttle                               Trader, innocent
 EQUB %01100001         ; Transporter                      Trader, innocent, cop
 EQUB %10100000         ; Cobra Mk III                      Innocent, escape pod
 EQUB %10100000         ; Python                            Innocent, escape pod
 EQUB %10100000         ; Boa                               Innocent, escape pod
 EQUB %10100001         ; Anaconda                  Trader, innocent, escape pod
 EQUB %10100001         ; Rock hermit (asteroid)    Trader, innocent, escape pod
 EQUB %11000010         ; Viper                   Bounty hunter, cop, escape pod
 EQUB %00001100         ; Sidewinder                             Hostile, pirate
 EQUB %10001100         ; Mamba                      Hostile, pirate, escape pod
 EQUB %10001100         ; Krait                      Hostile, pirate, escape pod
 EQUB %10001100         ; Adder                      Hostile, pirate, escape pod
 EQUB %00001100         ; Gecko                                  Hostile, pirate
 EQUB %10001100         ; Cobra Mk I                 Hostile, pirate, escape pod
 EQUB %00000101         ; Worm                                   Hostile, trader
 EQUB %10001100         ; Cobra Mk III (pirate)      Hostile, pirate, escape pod
 EQUB %10001100         ; Asp Mk II                  Hostile, pirate, escape pod
 EQUB %10001100         ; Python (pirate)            Hostile, pirate, escape pod
 EQUB %10000010         ; Fer-de-lance                 Bounty hunter, escape pod
 EQUB %00001100         ; Moray                                  Hostile, pirate
 EQUB %00001100         ; Thargoid                               Hostile, pirate
 EQUB %00000100         ; Thargon                                        Hostile
 EQUB %00000100         ; Constrictor                                    Hostile
 EQUB %00100000         ; Cougar                                        Innocent

 EQUB 0                 ; This byte appears to be unused

; ******************************************************************************
;
;       Name: KWL%
;       Type: Variable
;   Category: Status
;    Summary: Fractional number of kills awarded for destroying each type of
;             ship
;
; ------------------------------------------------------------------------------
;
; This figure contains the fractional part of the points that are added to the
; combat rank in TALLY when destroying a ship of this type. This is different to
; the original BBC Micro versions, where you always get a single combat point
; for everything you kill; in the Master version, it's more sophisticated.
;
; The integral part is stored in the KWH% table.
;
; Each fraction is stored as the numerator in a fraction with a denominator of
; 256, so 149 represents 149 / 256 = 0.58203125 points.
;
; ******************************************************************************

.KWL%

 EQUB 149               ; Missile                               0.58203125
 EQUB 0                 ; Coriolis space station                0.0
 EQUB 16                ; Escape pod                            0.0625
 EQUB 10                ; Alloy plate                           0.0390625
 EQUB 10                ; Cargo canister                        0.0390625
 EQUB 6                 ; Boulder                               0.0234375
 EQUB 8                 ; Asteroid                              0.03125
 EQUB 10                ; Splinter                              0.0390625
 EQUB 16                ; Shuttle                               0.0625
 EQUB 17                ; Transporter                           0.06640625
 EQUB 234               ; Cobra Mk III                          0.9140625
 EQUB 170               ; Python                                0.6640625
 EQUB 213               ; Boa                                   0.83203125
 EQUB 0                 ; Anaconda                              1.0
 EQUB 85                ; Rock hermit (asteroid)                0.33203125
 EQUB 26                ; Viper                                 0.1015625
 EQUB 85                ; Sidewinder                            0.33203125
 EQUB 128               ; Mamba                                 0.5
 EQUB 85                ; Krait                                 0.33203125
 EQUB 90                ; Adder                                 0.3515625
 EQUB 85                ; Gecko                                 0.33203125
 EQUB 170               ; Cobra Mk I                            0.6640625
 EQUB 50                ; Worm                                  0.1953125
 EQUB 42                ; Cobra Mk III (pirate)                 1.1640625
 EQUB 21                ; Asp Mk II                             1.08203125
 EQUB 42                ; Python (pirate)                       1.1640625
 EQUB 64                ; Fer-de-lance                          1.25
 EQUB 192               ; Moray                                 0.75
 EQUB 170               ; Thargoid                              2.6640625
 EQUB 33                ; Thargon                               0.12890625
 EQUB 85                ; Constrictor                           5.33203125
 EQUB 85                ; Cougar                                5.33203125
 EQUB 0                 ; Dodecahedron ("Dodo") space station   0.0

; ******************************************************************************
;
;       Name: KWH%
;       Type: Variable
;   Category: Status
;    Summary: Integer number of kills awarded for destroying each type of ship
;
; ------------------------------------------------------------------------------
;
; This figure contains the integer part of the points that are added to the
; combat rank in TALLY when destroying a ship of this type. This is different to
; the original BBC Micro versions, where you always get a single combat point
; for everything you kill; in the Master version, it's more sophisticated.
;
; The fractional part is stored in the KWL% table.
;
; ******************************************************************************

.KWH%

 EQUB 0                 ; Missile                               0.58203125
 EQUB 0                 ; Coriolis space station                0.0
 EQUB 0                 ; Escape pod                            0.0625
 EQUB 0                 ; Alloy plate                           0.0390625
 EQUB 0                 ; Cargo canister                        0.0390625
 EQUB 0                 ; Boulder                               0.0234375
 EQUB 0                 ; Asteroid                              0.03125
 EQUB 0                 ; Splinter                              0.0390625
 EQUB 0                 ; Shuttle                               0.0625
 EQUB 0                 ; Transporter                           0.06640625
 EQUB 0                 ; Cobra Mk III                          0.9140625
 EQUB 0                 ; Python                                0.6640625
 EQUB 0                 ; Boa                                   0.83203125
 EQUB 1                 ; Anaconda                              1.0
 EQUB 0                 ; Rock hermit (asteroid)                0.33203125
 EQUB 0                 ; Viper                                 0.1015625
 EQUB 0                 ; Sidewinder                            0.33203125
 EQUB 0                 ; Mamba                                 0.5
 EQUB 0                 ; Krait                                 0.33203125
 EQUB 0                 ; Adder                                 0.3515625
 EQUB 0                 ; Gecko                                 0.33203125
 EQUB 0                 ; Cobra Mk I                            0.6640625
 EQUB 0                 ; Worm                                  0.1953125
 EQUB 1                 ; Cobra Mk III (pirate)                 1.1640625
 EQUB 1                 ; Asp Mk II                             1.08203125
 EQUB 1                 ; Python (pirate)                       1.1640625
 EQUB 1                 ; Fer-de-lance                          1.25
 EQUB 0                 ; Moray                                 0.75
 EQUB 2                 ; Thargoid                              2.6640625
 EQUB 0                 ; Thargon                               0.12890625
 EQUB 5                 ; Constrictor                           5.33203125
 EQUB 5                 ; Cougar                                5.33203125
 EQUB 0                 ; Dodecahedron ("Dodo") space station   0.0

; ******************************************************************************
;
;       Name: VERTEX
;       Type: Macro
;   Category: Drawing ships
;    Summary: Macro definition for adding vertices to ship blueprints
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the ship blueprints:
;
;   VERTEX x, y, z, face1, face2, face3, face4, visibility
;
; See the deep dive on "Ship blueprints" for details of how vertices are stored
; in the ship blueprints, and the deep dive on "Drawing ships" for information
; on how vertices are used to draw 3D wireframe ships.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   x                   The vertex's x-coordinate
;
;   y                   The vertex's y-coordinate
;
;   z                   The vertex's z-coordinate
;
;   face1               The number of face 1 associated with this vertex
;
;   face2               The number of face 2 associated with this vertex
;
;   face3               The number of face 3 associated with this vertex
;
;   face4               The number of face 4 associated with this vertex
;
;   visibility          The visibility distance, beyond which the vertex is not
;                       shown
;
; ******************************************************************************

MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility

 IF x < 0
  s_x = 1 << 7
 ELSE
  s_x = 0
 ENDIF

 IF y < 0
  s_y = 1 << 6
 ELSE
  s_y = 0
 ENDIF

 IF z < 0
  s_z = 1 << 5
 ELSE
  s_z = 0
 ENDIF

 s = s_x + s_y + s_z + visibility
 f1 = face1 + (face2 << 4)
 f2 = face3 + (face4 << 4)
 ax = ABS(x)
 ay = ABS(y)
 az = ABS(z)

 EQUB ax, ay, az, s, f1, f2

ENDMACRO

; ******************************************************************************
;
;       Name: EDGE
;       Type: Macro
;   Category: Drawing ships
;    Summary: Macro definition for adding edges to ship blueprints
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the ship blueprints:
;
;   EDGE vertex1, vertex2, face1, face2, visibility
;
; See the deep dive on "Ship blueprints" for details of how edges are stored
; in the ship blueprints, and the deep dive on "Drawing ships" for information
; on how edges are used to draw 3D wireframe ships.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   vertex1             The number of the vertex at the start of the edge
;
;   vertex1             The number of the vertex at the end of the edge
;
;   face1               The number of face 1 associated with this edge
;
;   face2               The number of face 2 associated with this edge
;
;   visibility          The visibility distance, beyond which the edge is not
;                       shown
;
; ******************************************************************************

MACRO EDGE vertex1, vertex2, face1, face2, visibility

 f = face1 + (face2 << 4)
 EQUB visibility, f, vertex1 << 2, vertex2 << 2

ENDMACRO

; ******************************************************************************
;
;       Name: FACE
;       Type: Macro
;   Category: Drawing ships
;    Summary: Macro definition for adding faces to ship blueprints
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the ship blueprints:
;
;   FACE normal_x, normal_y, normal_z, visibility
;
; See the deep dive on "Ship blueprints" for details of how faces are stored
; in the ship blueprints, and the deep dive on "Drawing ships" for information
; on how faces are used to draw 3D wireframe ships.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   normal_x            The face normal's x-coordinate
;
;   normal_y            The face normal's y-coordinate
;
;   normal_z            The face normal's z-coordinate
;
;   visibility          The visibility distance, beyond which the edge is always
;                       shown
;
; ******************************************************************************

MACRO FACE normal_x, normal_y, normal_z, visibility

 IF normal_x < 0
  s_x = 1 << 7
 ELSE
  s_x = 0
 ENDIF

 IF normal_y < 0
  s_y = 1 << 6
 ELSE
  s_y = 0
 ENDIF

 IF normal_z < 0
  s_z = 1 << 5
 ELSE
  s_z = 0
 ENDIF

 s = s_x + s_y + s_z + visibility
 ax = ABS(normal_x)
 ay = ABS(normal_y)
 az = ABS(normal_z)

 EQUB s, ax, ay, az

ENDMACRO

; ******************************************************************************
;
;       Name: SHIP_MISSILE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a missile
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_MISSILE

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 40 * 40           ; Targetable area          = 40 * 40

 EQUB LO(SHIP_MISSILE_EDGES - SHIP_MISSILE)        ; Edges data offset (low)
 EQUB LO(SHIP_MISSILE_FACES - SHIP_MISSILE)        ; Faces data offset (low)

 EQUB 85                ; Max. edge count          = (85 - 1) / 4 = 21
 EQUB 0                 ; Gun vertex               = 0
 EQUB 10                ; Explosion count          = 1, as (4 * n) + 6 = 10
 EQUB 102               ; Number of vertices       = 102 / 6 = 17
 EQUB 24                ; Number of edges          = 24
 EQUW 0                 ; Bounty                   = 0
 EQUB 36                ; Number of faces          = 36 / 4 = 9
 EQUB 14                ; Visibility distance      = 14
 EQUB 2                 ; Max. energy              = 2
 EQUB 44                ; Max. speed               = 44

 EQUB HI(SHIP_MISSILE_EDGES - SHIP_MISSILE)        ; Edges data offset (high)
 EQUB HI(SHIP_MISSILE_FACES - SHIP_MISSILE)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_MISSILE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   68,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX    8,   -8,   36,     1,      2,    4,     5,         31    ; Vertex 1
 VERTEX    8,    8,   36,     2,      3,    4,     7,         31    ; Vertex 2
 VERTEX   -8,    8,   36,     0,      3,    6,     7,         31    ; Vertex 3
 VERTEX   -8,   -8,   36,     0,      1,    5,     6,         31    ; Vertex 4
 VERTEX    8,    8,  -44,     4,      7,    8,     8,         31    ; Vertex 5
 VERTEX    8,   -8,  -44,     4,      5,    8,     8,         31    ; Vertex 6
 VERTEX   -8,   -8,  -44,     5,      6,    8,     8,         31    ; Vertex 7
 VERTEX   -8,    8,  -44,     6,      7,    8,     8,         31    ; Vertex 8
 VERTEX   12,   12,  -44,     4,      7,    8,     8,          8    ; Vertex 9
 VERTEX   12,  -12,  -44,     4,      5,    8,     8,          8    ; Vertex 10
 VERTEX  -12,  -12,  -44,     5,      6,    8,     8,          8    ; Vertex 11
 VERTEX  -12,   12,  -44,     6,      7,    8,     8,          8    ; Vertex 12
 VERTEX   -8,    8,  -12,     6,      7,    7,     7,          8    ; Vertex 13
 VERTEX   -8,   -8,  -12,     5,      6,    6,     6,          8    ; Vertex 14
 VERTEX    8,    8,  -12,     4,      7,    7,     7,          8    ; Vertex 15
 VERTEX    8,   -8,  -12,     4,      5,    5,     5,          8    ; Vertex 16

.SHIP_MISSILE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     2,         31    ; Edge 0
 EDGE       0,       2,     2,     3,         31    ; Edge 1
 EDGE       0,       3,     0,     3,         31    ; Edge 2
 EDGE       0,       4,     0,     1,         31    ; Edge 3
 EDGE       1,       2,     4,     2,         31    ; Edge 4
 EDGE       1,       4,     1,     5,         31    ; Edge 5
 EDGE       3,       4,     0,     6,         31    ; Edge 6
 EDGE       2,       3,     3,     7,         31    ; Edge 7
 EDGE       2,       5,     4,     7,         31    ; Edge 8
 EDGE       1,       6,     4,     5,         31    ; Edge 9
 EDGE       4,       7,     5,     6,         31    ; Edge 10
 EDGE       3,       8,     6,     7,         31    ; Edge 11
 EDGE       7,       8,     6,     8,         31    ; Edge 12
 EDGE       5,       8,     7,     8,         31    ; Edge 13
 EDGE       5,       6,     4,     8,         31    ; Edge 14
 EDGE       6,       7,     5,     8,         31    ; Edge 15
 EDGE       6,      10,     5,     8,          8    ; Edge 16
 EDGE       5,       9,     7,     8,          8    ; Edge 17
 EDGE       8,      12,     7,     8,          8    ; Edge 18
 EDGE       7,      11,     5,     8,          8    ; Edge 19
 EDGE       9,      15,     4,     7,          8    ; Edge 20
 EDGE      10,      16,     4,     5,          8    ; Edge 21
 EDGE      12,      13,     6,     7,          8    ; Edge 22
 EDGE      11,      14,     5,     6,          8    ; Edge 23

.SHIP_MISSILE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -64,        0,       16,         31    ; Face 0
 FACE        0,      -64,       16,         31    ; Face 1
 FACE       64,        0,       16,         31    ; Face 2
 FACE        0,       64,       16,         31    ; Face 3
 FACE       32,        0,        0,         31    ; Face 4
 FACE        0,      -32,        0,         31    ; Face 5
 FACE      -32,        0,        0,         31    ; Face 6
 FACE        0,       32,        0,         31    ; Face 7
 FACE        0,        0,     -176,         31    ; Face 8

; ******************************************************************************
;
;       Name: SHIP_CORIOLIS
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Coriolis space station
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_CORIOLIS

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 160 * 160         ; Targetable area          = 160 * 160

 EQUB LO(SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)      ; Edges data offset (low)
 EQUB LO(SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)      ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 54                ; Explosion count          = 12, as (4 * n) + 6 = 54
 EQUB 96                ; Number of vertices       = 96 / 6 = 16
 EQUB 28                ; Number of edges          = 28
 EQUW 0                 ; Bounty                   = 0
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 120               ; Visibility distance      = 120
 EQUB 240               ; Max. energy              = 240
 EQUB 0                 ; Max. speed               = 0

 EQUB HI(SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)      ; Edges data offset (high)
 EQUB HI(SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)      ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00000110         ; Laser power              = 0
                        ; Missiles                 = 6

.SHIP_CORIOLIS_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  160,    0,  160,     0,      1,    2,     6,         31    ; Vertex 0
 VERTEX    0,  160,  160,     0,      2,    3,     8,         31    ; Vertex 1
 VERTEX -160,    0,  160,     0,      3,    4,     7,         31    ; Vertex 2
 VERTEX    0, -160,  160,     0,      1,    4,     5,         31    ; Vertex 3
 VERTEX  160, -160,    0,     1,      5,    6,    10,         31    ; Vertex 4
 VERTEX  160,  160,    0,     2,      6,    8,    11,         31    ; Vertex 5
 VERTEX -160,  160,    0,     3,      7,    8,    12,         31    ; Vertex 6
 VERTEX -160, -160,    0,     4,      5,    7,     9,         31    ; Vertex 7
 VERTEX  160,    0, -160,     6,     10,   11,    13,         31    ; Vertex 8
 VERTEX    0,  160, -160,     8,     11,   12,    13,         31    ; Vertex 9
 VERTEX -160,    0, -160,     7,      9,   12,    13,         31    ; Vertex 10
 VERTEX    0, -160, -160,     5,      9,   10,    13,         31    ; Vertex 11
 VERTEX   10,  -30,  160,     0,      0,    0,     0,         30    ; Vertex 12
 VERTEX   10,   30,  160,     0,      0,    0,     0,         30    ; Vertex 13
 VERTEX  -10,   30,  160,     0,      0,    0,     0,         30    ; Vertex 14
 VERTEX  -10,  -30,  160,     0,      0,    0,     0,         30    ; Vertex 15

.SHIP_CORIOLIS_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       3,     0,     1,         31    ; Edge 0
 EDGE       0,       1,     0,     2,         31    ; Edge 1
 EDGE       1,       2,     0,     3,         31    ; Edge 2
 EDGE       2,       3,     0,     4,         31    ; Edge 3
 EDGE       3,       4,     1,     5,         31    ; Edge 4
 EDGE       0,       4,     1,     6,         31    ; Edge 5
 EDGE       0,       5,     2,     6,         31    ; Edge 6
 EDGE       5,       1,     2,     8,         31    ; Edge 7
 EDGE       1,       6,     3,     8,         31    ; Edge 8
 EDGE       2,       6,     3,     7,         31    ; Edge 9
 EDGE       2,       7,     4,     7,         31    ; Edge 10
 EDGE       3,       7,     4,     5,         31    ; Edge 11
 EDGE       8,      11,    10,    13,         31    ; Edge 12
 EDGE       8,       9,    11,    13,         31    ; Edge 13
 EDGE       9,      10,    12,    13,         31    ; Edge 14
 EDGE      10,      11,     9,    13,         31    ; Edge 15
 EDGE       4,      11,     5,    10,         31    ; Edge 16
 EDGE       4,       8,     6,    10,         31    ; Edge 17
 EDGE       5,       8,     6,    11,         31    ; Edge 18
 EDGE       5,       9,     8,    11,         31    ; Edge 19
 EDGE       6,       9,     8,    12,         31    ; Edge 20
 EDGE       6,      10,     7,    12,         31    ; Edge 21
 EDGE       7,      10,     7,     9,         31    ; Edge 22
 EDGE       7,      11,     5,     9,         31    ; Edge 23
 EDGE      12,      13,     0,     0,         30    ; Edge 24
 EDGE      13,      14,     0,     0,         30    ; Edge 25
 EDGE      14,      15,     0,     0,         30    ; Edge 26
 EDGE      15,      12,     0,     0,         30    ; Edge 27

.SHIP_CORIOLIS_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,      160,         31    ; Face 0
 FACE      107,     -107,      107,         31    ; Face 1
 FACE      107,      107,      107,         31    ; Face 2
 FACE     -107,      107,      107,         31    ; Face 3
 FACE     -107,     -107,      107,         31    ; Face 4
 FACE        0,     -160,        0,         31    ; Face 5
 FACE      160,        0,        0,         31    ; Face 6
 FACE     -160,        0,        0,         31    ; Face 7
 FACE        0,      160,        0,         31    ; Face 8
 FACE     -107,     -107,     -107,         31    ; Face 9
 FACE      107,     -107,     -107,         31    ; Face 10
 FACE      107,      107,     -107,         31    ; Face 11
 FACE     -107,      107,     -107,         31    ; Face 12
 FACE        0,        0,     -160,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_ESCAPE_POD
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an escape pod
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ESCAPE_POD

 EQUB 0 + (2 << 4)      ; Max. canisters on demise = 0
                        ; Market item when scooped = 2 + 1 = 3 (slaves)
 EQUW 16 * 16           ; Targetable area          = 16 * 16

 EQUB LO(SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)  ; Edges data offset (low)
 EQUB LO(SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)  ; Faces data offset (low)

 EQUB 29                ; Max. edge count          = (29 - 1) / 4 = 7
 EQUB 0                 ; Gun vertex               = 0
 EQUB 22                ; Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 24                ; Number of vertices       = 24 / 6 = 4
 EQUB 6                 ; Number of edges          = 6
 EQUW 0                 ; Bounty                   = 0
 EQUB 16                ; Number of faces          = 16 / 4 = 4
 EQUB 8                 ; Visibility distance      = 8
 EQUB 17                ; Max. energy              = 17
 EQUB 8                 ; Max. speed               = 8

 EQUB HI(SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)  ; Edges data offset (high)
 EQUB HI(SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)  ; Faces data offset (high)

 EQUB 4                 ; Normals are scaled by    =  2^4 = 16
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_ESCAPE_POD_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   -7,    0,   36,     2,      1,    3,     3,         31    ; Vertex 0
 VERTEX   -7,  -14,  -12,     2,      0,    3,     3,         31    ; Vertex 1
 VERTEX   -7,   14,  -12,     1,      0,    3,     3,         31    ; Vertex 2
 VERTEX   21,    0,    0,     1,      0,    2,     2,         31    ; Vertex 3

.SHIP_ESCAPE_POD_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     2,         31    ; Edge 0
 EDGE       1,       2,     3,     0,         31    ; Edge 1
 EDGE       2,       3,     1,     0,         31    ; Edge 2
 EDGE       3,       0,     2,     1,         31    ; Edge 3
 EDGE       0,       2,     3,     1,         31    ; Edge 4
 EDGE       3,       1,     2,     0,         31    ; Edge 5

.SHIP_ESCAPE_POD_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       52,        0,     -122,         31    ; Face 0
 FACE       39,      103,       30,         31    ; Face 1
 FACE       39,     -103,       30,         31    ; Face 2
 FACE     -112,        0,        0,         31    ; Face 3

; ******************************************************************************
;
;       Name: SHIP_PLATE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an alloy plate
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_PLATE

 EQUB 0 + (8 << 4)      ; Max. canisters on demise = 0
                        ; Market item when scooped = 8 + 1 = 9 (Alloys)
 EQUW 10 * 10           ; Targetable area          = 10 * 10

 EQUB LO(SHIP_PLATE_EDGES - SHIP_PLATE)            ; Edges data offset (low)
 EQUB LO(SHIP_PLATE_FACES - SHIP_PLATE)            ; Faces data offset (low)

 EQUB 21                ; Max. edge count          = (21 - 1) / 4 = 5
 EQUB 0                 ; Gun vertex               = 0
 EQUB 10                ; Explosion count          = 1, as (4 * n) + 6 = 10
 EQUB 24                ; Number of vertices       = 24 / 6 = 4
 EQUB 4                 ; Number of edges          = 4
 EQUW 0                 ; Bounty                   = 0
 EQUB 4                 ; Number of faces          = 4 / 4 = 1
 EQUB 5                 ; Visibility distance      = 5
 EQUB 16                ; Max. energy              = 16
 EQUB 16                ; Max. speed               = 16

 EQUB HI(SHIP_PLATE_EDGES - SHIP_PLATE)            ; Edges data offset (high)
 EQUB HI(SHIP_PLATE_FACES - SHIP_PLATE)            ; Faces data offset (high)

 EQUB 3                 ; Normals are scaled by    = 2^3 = 8
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_PLATE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -15,  -22,   -9,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -15,   38,   -9,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX   19,   32,   11,    15,     15,   15,    15,         20    ; Vertex 2
 VERTEX   10,  -46,    6,    15,     15,   15,    15,         20    ; Vertex 3

.SHIP_PLATE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,    15,    15,         31    ; Edge 0
 EDGE       1,       2,    15,    15,         16    ; Edge 1
 EDGE       2,       3,    15,    15,         20    ; Edge 2
 EDGE       3,       0,    15,    15,         16    ; Edge 3

.SHIP_PLATE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,        0,          0    ; Face 0

; ******************************************************************************
;
;       Name: SHIP_CANISTER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a cargo canister
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_CANISTER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 20 * 20           ; Targetable area          = 20 * 20

 EQUB LO(SHIP_CANISTER_EDGES - SHIP_CANISTER)      ; Edges data offset (low)
 EQUB LO(SHIP_CANISTER_FACES - SHIP_CANISTER)      ; Faces data offset (low)

 EQUB 53                ; Max. edge count          = (53 - 1) / 4 = 13
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 15                ; Number of edges          = 15
 EQUW 0                 ; Bounty                   = 0
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 12                ; Visibility distance      = 12
 EQUB 17                ; Max. energy              = 17
 EQUB 15                ; Max. speed               = 15

 EQUB HI(SHIP_CANISTER_EDGES - SHIP_CANISTER)      ; Edges data offset (high)
 EQUB HI(SHIP_CANISTER_FACES - SHIP_CANISTER)      ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_CANISTER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   24,   16,    0,     0,      1,    5,     5,         31    ; Vertex 0
 VERTEX   24,    5,   15,     0,      1,    2,     2,         31    ; Vertex 1
 VERTEX   24,  -13,    9,     0,      2,    3,     3,         31    ; Vertex 2
 VERTEX   24,  -13,   -9,     0,      3,    4,     4,         31    ; Vertex 3
 VERTEX   24,    5,  -15,     0,      4,    5,     5,         31    ; Vertex 4
 VERTEX  -24,   16,    0,     1,      5,    6,     6,         31    ; Vertex 5
 VERTEX  -24,    5,   15,     1,      2,    6,     6,         31    ; Vertex 6
 VERTEX  -24,  -13,    9,     2,      3,    6,     6,         31    ; Vertex 7
 VERTEX  -24,  -13,   -9,     3,      4,    6,     6,         31    ; Vertex 8
 VERTEX  -24,    5,  -15,     4,      5,    6,     6,         31    ; Vertex 9

.SHIP_CANISTER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     1,         31    ; Edge 0
 EDGE       1,       2,     0,     2,         31    ; Edge 1
 EDGE       2,       3,     0,     3,         31    ; Edge 2
 EDGE       3,       4,     0,     4,         31    ; Edge 3
 EDGE       0,       4,     0,     5,         31    ; Edge 4
 EDGE       0,       5,     1,     5,         31    ; Edge 5
 EDGE       1,       6,     1,     2,         31    ; Edge 6
 EDGE       2,       7,     2,     3,         31    ; Edge 7
 EDGE       3,       8,     3,     4,         31    ; Edge 8
 EDGE       4,       9,     4,     5,         31    ; Edge 9
 EDGE       5,       6,     1,     6,         31    ; Edge 10
 EDGE       6,       7,     2,     6,         31    ; Edge 11
 EDGE       7,       8,     3,     6,         31    ; Edge 12
 EDGE       8,       9,     4,     6,         31    ; Edge 13
 EDGE       9,       5,     5,     6,         31    ; Edge 14

.SHIP_CANISTER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       96,        0,        0,         31    ; Face 0
 FACE        0,       41,       30,         31    ; Face 1
 FACE        0,      -18,       48,         31    ; Face 2
 FACE        0,      -51,        0,         31    ; Face 3
 FACE        0,      -18,      -48,         31    ; Face 4
 FACE        0,       41,      -30,         31    ; Face 5
 FACE      -96,        0,        0,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_BOULDER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a boulder
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_BOULDER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 30 * 30           ; Targetable area          = 30 * 30

 EQUB LO(SHIP_BOULDER_EDGES - SHIP_BOULDER)        ; Edges data offset (low)
 EQUB LO(SHIP_BOULDER_FACES - SHIP_BOULDER)        ; Faces data offset (low)

 EQUB 49                ; Max. edge count          = (49 - 1) / 4 = 12
 EQUB 0                 ; Gun vertex               = 0
 EQUB 14                ; Explosion count          = 2, as (4 * n) + 6 = 14
 EQUB 42                ; Number of vertices       = 42 / 6 = 7
 EQUB 15                ; Number of edges          = 15
 EQUW 1                 ; Bounty                   = 1
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 20                ; Visibility distance      = 20
 EQUB 20                ; Max. energy              = 20
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_BOULDER_EDGES - SHIP_BOULDER)        ; Edges data offset (high)
 EQUB HI(SHIP_BOULDER_FACES - SHIP_BOULDER)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_BOULDER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,   37,  -11,     1,      0,    9,     5,         31    ; Vertex 0
 VERTEX   30,    7,   12,     2,      1,    6,     5,         31    ; Vertex 1
 VERTEX   28,   -7,  -12,     3,      2,    7,     6,         31    ; Vertex 2
 VERTEX    2,    0,  -39,     4,      3,    8,     7,         31    ; Vertex 3
 VERTEX  -28,   34,  -30,     4,      0,    9,     8,         31    ; Vertex 4
 VERTEX    5,  -10,   13,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX   20,   17,  -30,    15,     15,   15,    15,         31    ; Vertex 6

.SHIP_BOULDER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     5,     1,         31    ; Edge 0
 EDGE       1,       2,     6,     2,         31    ; Edge 1
 EDGE       2,       3,     7,     3,         31    ; Edge 2
 EDGE       3,       4,     8,     4,         31    ; Edge 3
 EDGE       4,       0,     9,     0,         31    ; Edge 4
 EDGE       0,       5,     1,     0,         31    ; Edge 5
 EDGE       1,       5,     2,     1,         31    ; Edge 6
 EDGE       2,       5,     3,     2,         31    ; Edge 7
 EDGE       3,       5,     4,     3,         31    ; Edge 8
 EDGE       4,       5,     4,     0,         31    ; Edge 9
 EDGE       0,       6,     9,     5,         31    ; Edge 10
 EDGE       1,       6,     6,     5,         31    ; Edge 11
 EDGE       2,       6,     7,     6,         31    ; Edge 12
 EDGE       3,       6,     8,     7,         31    ; Edge 13
 EDGE       4,       6,     9,     8,         31    ; Edge 14

.SHIP_BOULDER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -15,       -3,        8,         31    ; Face 0
 FACE       -7,       12,       30,         31    ; Face 1
 FACE       32,      -47,       24,         31    ; Face 2
 FACE       -3,      -39,       -7,         31    ; Face 3
 FACE       -5,       -4,       -1,         31    ; Face 4
 FACE       49,       84,        8,         31    ; Face 5
 FACE      112,       21,      -21,         31    ; Face 6
 FACE       76,      -35,      -82,         31    ; Face 7
 FACE       22,       56,     -137,         31    ; Face 8
 FACE       40,      110,      -38,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_ASTEROID
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an asteroid
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ASTEROID

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_ASTEROID_EDGES - SHIP_ASTEROID)      ; Edges data offset (low)
 EQUB LO(SHIP_ASTEROID_FACES - SHIP_ASTEROID)      ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 34                ; Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 54                ; Number of vertices       = 54 / 6 = 9
 EQUB 21                ; Number of edges          = 21
 EQUW 5                 ; Bounty                   = 5
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 50                ; Visibility distance      = 50
 EQUB 60                ; Max. energy              = 60
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_ASTEROID_EDGES - SHIP_ASTEROID)      ; Edges data offset (high)
 EQUB HI(SHIP_ASTEROID_FACES - SHIP_ASTEROID)      ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_ASTEROID_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   80,    0,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -80,  -10,    0,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,  -80,    0,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX   70,  -40,    0,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX   60,   50,    0,     5,      6,   12,    13,         31    ; Vertex 4
 VERTEX   50,    0,   60,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX  -40,    0,   70,     0,      1,    2,     3,         31    ; Vertex 6
 VERTEX    0,   30,  -75,    15,     15,   15,    15,         31    ; Vertex 7
 VERTEX    0,  -50,  -60,     8,      9,   10,    11,         31    ; Vertex 8

.SHIP_ASTEROID_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     7,         31    ; Edge 0
 EDGE       0,       4,     6,    13,         31    ; Edge 1
 EDGE       3,       4,     5,    12,         31    ; Edge 2
 EDGE       2,       3,     4,    11,         31    ; Edge 3
 EDGE       1,       2,     3,    10,         31    ; Edge 4
 EDGE       1,       6,     2,     3,         31    ; Edge 5
 EDGE       2,       6,     1,     3,         31    ; Edge 6
 EDGE       2,       5,     1,     4,         31    ; Edge 7
 EDGE       5,       6,     0,     1,         31    ; Edge 8
 EDGE       0,       5,     0,     6,         31    ; Edge 9
 EDGE       3,       5,     4,     5,         31    ; Edge 10
 EDGE       0,       6,     0,     2,         31    ; Edge 11
 EDGE       4,       5,     5,     6,         31    ; Edge 12
 EDGE       1,       8,     8,    10,         31    ; Edge 13
 EDGE       1,       7,     7,     8,         31    ; Edge 14
 EDGE       0,       7,     7,    13,         31    ; Edge 15
 EDGE       4,       7,    12,    13,         31    ; Edge 16
 EDGE       3,       7,     9,    12,         31    ; Edge 17
 EDGE       3,       8,     9,    11,         31    ; Edge 18
 EDGE       2,       8,    10,    11,         31    ; Edge 19
 EDGE       7,       8,     8,     9,         31    ; Edge 20

.SHIP_ASTEROID_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        9,       66,       81,         31    ; Face 0
 FACE        9,      -66,       81,         31    ; Face 1
 FACE      -72,       64,       31,         31    ; Face 2
 FACE      -64,      -73,       47,         31    ; Face 3
 FACE       45,      -79,       65,         31    ; Face 4
 FACE      135,       15,       35,         31    ; Face 5
 FACE       38,       76,       70,         31    ; Face 6
 FACE      -66,       59,      -39,         31    ; Face 7
 FACE      -67,      -15,      -80,         31    ; Face 8
 FACE       66,      -14,      -75,         31    ; Face 9
 FACE      -70,      -80,      -40,         31    ; Face 10
 FACE       58,     -102,      -51,         31    ; Face 11
 FACE       81,        9,      -67,         31    ; Face 12
 FACE       47,       94,      -63,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_SPLINTER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a splinter
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The ship blueprint for the splinter reuses the edges data from the escape pod,
; so the edges data offset is negative.
;
; ******************************************************************************

.SHIP_SPLINTER

 EQUB 0 + (11 << 4)     ; Max. canisters on demise = 0
                        ; Market item when scooped = 11 + 1 = 12 (Minerals)
 EQUW 16 * 16           ; Targetable area          = 16 * 16

 EQUB LO(SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER)    ; Edges from escape pod
 EQUB LO(SHIP_SPLINTER_FACES - SHIP_SPLINTER) + 24 ; Faces data offset (low)

 EQUB 29                ; Max. edge count          = (29 - 1) / 4 = 7
 EQUB 0                 ; Gun vertex               = 0
 EQUB 22                ; Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 24                ; Number of vertices       = 24 / 6 = 4
 EQUB 6                 ; Number of edges          = 6
 EQUW 0                 ; Bounty                   = 0
 EQUB 16                ; Number of faces          = 16 / 4 = 4
 EQUB 8                 ; Visibility distance      = 8
 EQUB 20                ; Max. energy              = 20
 EQUB 10                ; Max. speed               = 10

 EQUB HI(SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER)    ; Edges from escape pod
 EQUB HI(SHIP_SPLINTER_FACES - SHIP_SPLINTER)      ; Faces data offset (low)

 EQUB 5                 ; Normals are scaled by    = 2^5 = 32
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_SPLINTER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -24,  -25,   16,     2,      1,    3,     3,         31    ; Vertex 0
 VERTEX    0,   12,  -10,     2,      0,    3,     3,         31    ; Vertex 1
 VERTEX   11,   -6,    2,     1,      0,    3,     3,         31    ; Vertex 2
 VERTEX   12,   42,    7,     1,      0,    2,     2,         31    ; Vertex 3

.SHIP_SPLINTER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       35,        0,        4,         31    ; Face 0
 FACE        3,        4,        8,         31    ; Face 1
 FACE        1,        8,       12,         31    ; Face 2
 FACE       18,       12,        0,         31    ; Face 3

; ******************************************************************************
;
;       Name: SHIP_SHUTTLE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Shuttle
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_SHUTTLE

 EQUB 15                ; Max. canisters on demise = 15
 EQUW 50 * 50           ; Targetable area          = 50 * 50

 EQUB LO(SHIP_SHUTTLE_EDGES - SHIP_SHUTTLE)        ; Edges data offset (low)
 EQUB LO(SHIP_SHUTTLE_FACES - SHIP_SHUTTLE)        ; Faces data offset (low)

 EQUB 113               ; Max. edge count          = (113 - 1) / 4 = 28
 EQUB 0                 ; Gun vertex               = 0
 EQUB 38                ; Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 30                ; Number of edges          = 30
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 22                ; Visibility distance      = 22
 EQUB 32                ; Max. energy              = 32
 EQUB 8                 ; Max. speed               = 8

 EQUB HI(SHIP_SHUTTLE_EDGES - SHIP_SHUTTLE)        ; Edges data offset (high)
 EQUB HI(SHIP_SHUTTLE_FACES - SHIP_SHUTTLE)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_SHUTTLE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -17,   23,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -17,    0,   23,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,   18,   23,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX   18,    0,   23,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX  -20,  -20,  -27,     2,      1,    9,     3,         31    ; Vertex 4
 VERTEX  -20,   20,  -27,     4,      3,    9,     5,         31    ; Vertex 5
 VERTEX   20,   20,  -27,     6,      5,    9,     7,         31    ; Vertex 6
 VERTEX   20,  -20,  -27,     7,      1,    9,     8,         31    ; Vertex 7
 VERTEX    5,    0,  -27,     9,      9,    9,     9,         16    ; Vertex 8
 VERTEX    0,   -2,  -27,     9,      9,    9,     9,         16    ; Vertex 9
 VERTEX   -5,    0,  -27,     9,      9,    9,     9,          9    ; Vertex 10
 VERTEX    0,    3,  -27,     9,      9,    9,     9,          9    ; Vertex 11
 VERTEX    0,   -9,   35,    10,      0,   12,    11,         16    ; Vertex 12
 VERTEX    3,   -1,   31,    15,     15,    2,     0,          7    ; Vertex 13
 VERTEX    4,   11,   25,     1,      0,    4,    15,          8    ; Vertex 14
 VERTEX   11,    4,   25,     1,     10,   15,     3,          8    ; Vertex 15
 VERTEX   -3,   -1,   31,    11,      6,    3,     2,          7    ; Vertex 16
 VERTEX   -3,   11,   25,     8,     15,    0,    12,          8    ; Vertex 17
 VERTEX  -10,    4,   25,    15,      4,    8,     1,          8    ; Vertex 18

.SHIP_SHUTTLE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     0,         31    ; Edge 0
 EDGE       1,       2,    10,     4,         31    ; Edge 1
 EDGE       2,       3,    11,     6,         31    ; Edge 2
 EDGE       0,       3,    12,     8,         31    ; Edge 3
 EDGE       0,       7,     8,     1,         31    ; Edge 4
 EDGE       0,       4,     2,     1,         24    ; Edge 5
 EDGE       1,       4,     3,     2,         31    ; Edge 6
 EDGE       1,       5,     4,     3,         24    ; Edge 7
 EDGE       2,       5,     5,     4,         31    ; Edge 8
 EDGE       2,       6,     6,     5,         12    ; Edge 9
 EDGE       3,       6,     7,     6,         31    ; Edge 10
 EDGE       3,       7,     8,     7,         24    ; Edge 11
 EDGE       4,       5,     9,     3,         31    ; Edge 12
 EDGE       5,       6,     9,     5,         31    ; Edge 13
 EDGE       6,       7,     9,     7,         31    ; Edge 14
 EDGE       4,       7,     9,     1,         31    ; Edge 15
 EDGE       0,      12,    12,     0,         16    ; Edge 16
 EDGE       1,      12,    10,     0,         16    ; Edge 17
 EDGE       2,      12,    11,    10,         16    ; Edge 18
 EDGE       3,      12,    12,    11,         16    ; Edge 19
 EDGE       8,       9,     9,     9,         16    ; Edge 20
 EDGE       9,      10,     9,     9,          7    ; Edge 21
 EDGE      10,      11,     9,     9,          9    ; Edge 22
 EDGE       8,      11,     9,     9,          7    ; Edge 23
 EDGE      13,      14,    11,    11,          5    ; Edge 24
 EDGE      14,      15,    11,    11,          8    ; Edge 25
 EDGE      13,      15,    11,    11,          7    ; Edge 26
 EDGE      16,      17,    10,    10,          5    ; Edge 27
 EDGE      17,      18,    10,    10,          8    ; Edge 28
 EDGE      16,      18,    10,    10,          7    ; Edge 29

.SHIP_SHUTTLE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -55,      -55,       40,         31    ; Face 0
 FACE        0,      -74,        4,         31    ; Face 1
 FACE      -51,      -51,       23,         31    ; Face 2
 FACE      -74,        0,        4,         31    ; Face 3
 FACE      -51,       51,       23,         31    ; Face 4
 FACE        0,       74,        4,         31    ; Face 5
 FACE       51,       51,       23,         31    ; Face 6
 FACE       74,        0,        4,         31    ; Face 7
 FACE       51,      -51,       23,         31    ; Face 8
 FACE        0,        0,     -107,         31    ; Face 9
 FACE      -41,       41,       90,         31    ; Face 10
 FACE       41,       41,       90,         31    ; Face 11
 FACE       55,      -55,       40,         31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_TRANSPORTER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Transporter
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_TRANSPORTER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 50 * 50           ; Targetable area          = 50 * 50

 EQUB LO(SHIP_TRANSPORTER_EDGES - SHIP_TRANSPORTER)   ; Edges data offset (low)
 EQUB LO(SHIP_TRANSPORTER_FACES - SHIP_TRANSPORTER)   ; Faces data offset (low)

 EQUB 149               ; Max. edge count          = (149 - 1) / 4 = 37
 EQUB 48                ; Gun vertex               = 48 / 4 = 12
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 222               ; Number of vertices       = 222 / 6 = 37
 EQUB 46                ; Number of edges          = 46
 EQUW 0                 ; Bounty                   = 0
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 16                ; Visibility distance      = 16
 EQUB 32                ; Max. energy              = 32
 EQUB 10                ; Max. speed               = 10

 EQUB HI(SHIP_TRANSPORTER_EDGES - SHIP_TRANSPORTER)   ; Edges data offset (high)
 EQUB HI(SHIP_TRANSPORTER_FACES - SHIP_TRANSPORTER)   ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_TRANSPORTER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   10,  -26,     6,      0,    7,     7,         31    ; Vertex 0
 VERTEX  -25,    4,  -26,     1,      0,    7,     7,         31    ; Vertex 1
 VERTEX  -28,   -3,  -26,     1,      0,    2,     2,         31    ; Vertex 2
 VERTEX  -25,   -8,  -26,     2,      0,    3,     3,         31    ; Vertex 3
 VERTEX   26,   -8,  -26,     3,      0,    4,     4,         31    ; Vertex 4
 VERTEX   29,   -3,  -26,     4,      0,    5,     5,         31    ; Vertex 5
 VERTEX   26,    4,  -26,     5,      0,    6,     6,         31    ; Vertex 6
 VERTEX    0,    6,   12,    15,     15,   15,    15,         19    ; Vertex 7
 VERTEX  -30,   -1,   12,     7,      1,    9,     8,         31    ; Vertex 8
 VERTEX  -33,   -8,   12,     2,      1,    9,     3,         31    ; Vertex 9
 VERTEX   33,   -8,   12,     4,      3,   10,     5,         31    ; Vertex 10
 VERTEX   30,   -1,   12,     6,      5,   11,    10,         31    ; Vertex 11
 VERTEX  -11,   -2,   30,     9,      8,   13,    12,         31    ; Vertex 12
 VERTEX  -13,   -8,   30,     9,      3,   13,    13,         31    ; Vertex 13
 VERTEX   14,   -8,   30,    10,      3,   13,    13,         31    ; Vertex 14
 VERTEX   11,   -2,   30,    11,     10,   13,    12,         31    ; Vertex 15
 VERTEX   -5,    6,    2,     7,      7,    7,     7,          7    ; Vertex 16
 VERTEX  -18,    3,    2,     7,      7,    7,     7,          7    ; Vertex 17
 VERTEX   -5,    7,   -7,     7,      7,    7,     7,          7    ; Vertex 18
 VERTEX  -18,    4,   -7,     7,      7,    7,     7,          7    ; Vertex 19
 VERTEX  -11,    6,  -14,     7,      7,    7,     7,          7    ; Vertex 20
 VERTEX  -11,    5,   -7,     7,      7,    7,     7,          7    ; Vertex 21
 VERTEX    5,    7,  -14,     6,      6,    6,     6,          7    ; Vertex 22
 VERTEX   18,    4,  -14,     6,      6,    6,     6,          7    ; Vertex 23
 VERTEX   11,    5,   -7,     6,      6,    6,     6,          7    ; Vertex 24
 VERTEX    5,    6,   -3,     6,      6,    6,     6,          7    ; Vertex 25
 VERTEX   18,    3,   -3,     6,      6,    6,     6,          7    ; Vertex 26
 VERTEX   11,    4,    8,     6,      6,    6,     6,          7    ; Vertex 27
 VERTEX   11,    5,   -3,     6,      6,    6,     6,          7    ; Vertex 28
 VERTEX  -16,   -8,  -13,     3,      3,    3,     3,          6    ; Vertex 29
 VERTEX  -16,   -8,   16,     3,      3,    3,     3,          6    ; Vertex 30
 VERTEX   17,   -8,  -13,     3,      3,    3,     3,          6    ; Vertex 31
 VERTEX   17,   -8,   16,     3,      3,    3,     3,          6    ; Vertex 32
 VERTEX  -13,   -3,  -26,     0,      0,    0,     0,          8    ; Vertex 33
 VERTEX   13,   -3,  -26,     0,      0,    0,     0,          8    ; Vertex 34
 VERTEX    9,    3,  -26,     0,      0,    0,     0,          5    ; Vertex 35
 VERTEX   -8,    3,  -26,     0,      0,    0,     0,          5    ; Vertex 36

.SHIP_TRANSPORTER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    ; Edge 0
 EDGE       1,       2,     1,     0,         31    ; Edge 1
 EDGE       2,       3,     2,     0,         31    ; Edge 2
 EDGE       3,       4,     3,     0,         31    ; Edge 3
 EDGE       4,       5,     4,     0,         31    ; Edge 4
 EDGE       5,       6,     5,     0,         31    ; Edge 5
 EDGE       0,       6,     6,     0,         31    ; Edge 6
 EDGE       0,       7,     7,     6,         16    ; Edge 7
 EDGE       1,       8,     7,     1,         31    ; Edge 8
 EDGE       2,       9,     2,     1,         11    ; Edge 9
 EDGE       3,       9,     3,     2,         31    ; Edge 10
 EDGE       4,      10,     4,     3,         31    ; Edge 11
 EDGE       5,      10,     5,     4,         11    ; Edge 12
 EDGE       6,      11,     6,     5,         31    ; Edge 13
 EDGE       7,       8,     8,     7,         17    ; Edge 14
 EDGE       8,       9,     9,     1,         17    ; Edge 15
 EDGE      10,      11,    10,     5,         17    ; Edge 16
 EDGE       7,      11,    11,     6,         17    ; Edge 17
 EDGE       7,      15,    12,    11,         19    ; Edge 18
 EDGE       7,      12,    12,     8,         19    ; Edge 19
 EDGE       8,      12,     9,     8,         16    ; Edge 20
 EDGE       9,      13,     9,     3,         31    ; Edge 21
 EDGE      10,      14,    10,     3,         31    ; Edge 22
 EDGE      11,      15,    11,    10,         16    ; Edge 23
 EDGE      12,      13,    13,     9,         31    ; Edge 24
 EDGE      13,      14,    13,     3,         31    ; Edge 25
 EDGE      14,      15,    13,    10,         31    ; Edge 26
 EDGE      12,      15,    13,    12,         31    ; Edge 27
 EDGE      16,      17,     7,     7,          7    ; Edge 28
 EDGE      18,      19,     7,     7,          7    ; Edge 29
 EDGE      19,      20,     7,     7,          7    ; Edge 30
 EDGE      18,      20,     7,     7,          7    ; Edge 31
 EDGE      20,      21,     7,     7,          7    ; Edge 32
 EDGE      22,      23,     6,     6,          7    ; Edge 33
 EDGE      23,      24,     6,     6,          7    ; Edge 34
 EDGE      24,      22,     6,     6,          7    ; Edge 35
 EDGE      25,      26,     6,     6,          7    ; Edge 36
 EDGE      26,      27,     6,     6,          7    ; Edge 37
 EDGE      25,      27,     6,     6,          7    ; Edge 38
 EDGE      27,      28,     6,     6,          7    ; Edge 39
 EDGE      29,      30,     3,     3,          6    ; Edge 40
 EDGE      31,      32,     3,     3,          6    ; Edge 41
 EDGE      33,      34,     0,     0,          8    ; Edge 42
 EDGE      34,      35,     0,     0,          5    ; Edge 43
 EDGE      35,      36,     0,     0,          5    ; Edge 44
 EDGE      36,      33,     0,     0,          5    ; Edge 45

.SHIP_TRANSPORTER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,     -103,         31    ; Face 0
 FACE     -111,       48,       -7,         31    ; Face 1
 FACE     -105,      -63,      -21,         31    ; Face 2
 FACE        0,      -34,        0,         31    ; Face 3
 FACE      105,      -63,      -21,         31    ; Face 4
 FACE      111,       48,       -7,         31    ; Face 5
 FACE        8,       32,        3,         31    ; Face 6
 FACE       -8,       32,        3,         31    ; Face 7
 FACE       -8,       34,       11,         19    ; Face 8
 FACE      -75,       32,       79,         31    ; Face 9
 FACE       75,       32,       79,         31    ; Face 10
 FACE        8,       34,       11,         19    ; Face 11
 FACE        0,       38,       17,         31    ; Face 12
 FACE        0,        0,      121,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_COBRA_MK_3
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cobra Mk III
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_COBRA_MK_3

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 95 * 95           ; Targetable area          = 95 * 95

 EQUB LO(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)  ; Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)  ; Faces data offset (low)

 EQUB 157               ; Max. edge count          = (157 - 1) / 4 = 39
 EQUB 84                ; Gun vertex               = 84 / 4 = 21
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 168               ; Number of vertices       = 168 / 6 = 28
 EQUB 38                ; Number of edges          = 38
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 50                ; Visibility distance      = 50
 EQUB 150               ; Max. energy              = 150
 EQUB 28                ; Max. speed               = 28

 EQUB HI(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)  ; Edges data offset (low)
 EQUB HI(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)  ; Faces data offset (low)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010011         ; Laser power              = 2
                        ; Missiles                 = 3

.SHIP_COBRA_MK_3_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,   26,   24,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX -120,   -3,   -8,     3,      7,   10,    10,         31    ; Vertex 3
 VERTEX  120,   -3,   -8,     4,      8,   12,    12,         31    ; Vertex 4
 VERTEX  -88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX   88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 6
 VERTEX  128,   -8,  -40,     8,      9,   12,    12,         31    ; Vertex 7
 VERTEX -128,   -8,  -40,     7,      9,   10,    10,         31    ; Vertex 8
 VERTEX    0,   26,  -40,     5,      6,    9,     9,         31    ; Vertex 9
 VERTEX  -32,  -24,  -40,     9,     10,   11,    11,         31    ; Vertex 10
 VERTEX   32,  -24,  -40,     9,     11,   12,    12,         31    ; Vertex 11
 VERTEX  -36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 12
 VERTEX   -8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 13
 VERTEX    8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 14
 VERTEX   36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 15
 VERTEX   36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 16
 VERTEX    8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 17
 VERTEX   -8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 18
 VERTEX  -36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 19
 VERTEX    0,    0,   76,     0,     11,   11,    11,          6    ; Vertex 20
 VERTEX    0,    0,   90,     0,     11,   11,    11,         31    ; Vertex 21
 VERTEX  -80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 22
 VERTEX  -80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 23
 VERTEX  -88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 24
 VERTEX   80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 25
 VERTEX   88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 26
 VERTEX   80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 27

.SHIP_COBRA_MK_3_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,    11,         31    ; Edge 0
 EDGE       0,       4,     4,    12,         31    ; Edge 1
 EDGE       1,       3,     3,    10,         31    ; Edge 2
 EDGE       3,       8,     7,    10,         31    ; Edge 3
 EDGE       4,       7,     8,    12,         31    ; Edge 4
 EDGE       6,       7,     8,     9,         31    ; Edge 5
 EDGE       6,       9,     6,     9,         31    ; Edge 6
 EDGE       5,       9,     5,     9,         31    ; Edge 7
 EDGE       5,       8,     7,     9,         31    ; Edge 8
 EDGE       2,       5,     1,     5,         31    ; Edge 9
 EDGE       2,       6,     2,     6,         31    ; Edge 10
 EDGE       3,       5,     3,     7,         31    ; Edge 11
 EDGE       4,       6,     4,     8,         31    ; Edge 12
 EDGE       1,       2,     0,     1,         31    ; Edge 13
 EDGE       0,       2,     0,     2,         31    ; Edge 14
 EDGE       8,      10,     9,    10,         31    ; Edge 15
 EDGE      10,      11,     9,    11,         31    ; Edge 16
 EDGE       7,      11,     9,    12,         31    ; Edge 17
 EDGE       1,      10,    10,    11,         31    ; Edge 18
 EDGE       0,      11,    11,    12,         31    ; Edge 19
 EDGE       1,       5,     1,     3,         29    ; Edge 20
 EDGE       0,       6,     2,     4,         29    ; Edge 21
 EDGE      20,      21,     0,    11,          6    ; Edge 22
 EDGE      12,      13,     9,     9,         20    ; Edge 23
 EDGE      18,      19,     9,     9,         20    ; Edge 24
 EDGE      14,      15,     9,     9,         20    ; Edge 25
 EDGE      16,      17,     9,     9,         20    ; Edge 26
 EDGE      15,      16,     9,     9,         19    ; Edge 27
 EDGE      14,      17,     9,     9,         17    ; Edge 28
 EDGE      13,      18,     9,     9,         19    ; Edge 29
 EDGE      12,      19,     9,     9,         19    ; Edge 30
 EDGE       2,       9,     5,     6,         30    ; Edge 31
 EDGE      22,      24,     9,     9,          6    ; Edge 32
 EDGE      23,      24,     9,     9,          6    ; Edge 33
 EDGE      22,      23,     9,     9,          8    ; Edge 34
 EDGE      25,      26,     9,     9,          6    ; Edge 35
 EDGE      26,      27,     9,     9,          6    ; Edge 36
 EDGE      25,      27,     9,     9,          8    ; Edge 37

.SHIP_COBRA_MK_3_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       62,       31,         31    ; Face 0
 FACE      -18,       55,       16,         31    ; Face 1
 FACE       18,       55,       16,         31    ; Face 2
 FACE      -16,       52,       14,         31    ; Face 3
 FACE       16,       52,       14,         31    ; Face 4
 FACE      -14,       47,        0,         31    ; Face 5
 FACE       14,       47,        0,         31    ; Face 6
 FACE      -61,      102,        0,         31    ; Face 7
 FACE       61,      102,        0,         31    ; Face 8
 FACE        0,        0,      -80,         31    ; Face 9
 FACE       -7,      -42,        9,         31    ; Face 10
 FACE        0,      -30,        6,         31    ; Face 11
 FACE        7,      -42,        9,         31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_PYTHON
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Python
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_PYTHON

 EQUB 5                 ; Max. canisters on demise = 5
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_PYTHON_EDGES - SHIP_PYTHON)          ; Edges data offset (low)
 EQUB LO(SHIP_PYTHON_FACES - SHIP_PYTHON)          ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 66                ; Number of vertices       = 66 / 6 = 11
 EQUB 26                ; Number of edges          = 26
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 40                ; Visibility distance      = 40
 EQUB 250               ; Max. energy              = 250
 EQUB 20                ; Max. speed               = 20

 EQUB HI(SHIP_PYTHON_EDGES - SHIP_PYTHON)          ; Edges data offset (high)
 EQUB HI(SHIP_PYTHON_FACES - SHIP_PYTHON)          ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00011011         ; Laser power              = 3
                        ; Missiles                 = 3

.SHIP_PYTHON_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,  224,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX    0,   48,   48,     0,      1,    4,     5,         31    ; Vertex 1
 VERTEX   96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX  -96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX    0,   48,  -32,     4,      5,    8,     9,         31    ; Vertex 4
 VERTEX    0,   24, -112,     9,      8,   12,    12,         31    ; Vertex 5
 VERTEX  -48,    0, -112,     8,     11,   12,    12,         31    ; Vertex 6
 VERTEX   48,    0, -112,     9,     10,   12,    12,         31    ; Vertex 7
 VERTEX    0,  -48,   48,     2,      3,    6,     7,         31    ; Vertex 8
 VERTEX    0,  -48,  -32,     6,      7,   10,    11,         31    ; Vertex 9
 VERTEX    0,  -24, -112,    10,     11,   12,    12,         31    ; Vertex 10

.SHIP_PYTHON_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       8,     2,     3,         31    ; Edge 0
 EDGE       0,       3,     0,     2,         31    ; Edge 1
 EDGE       0,       2,     1,     3,         31    ; Edge 2
 EDGE       0,       1,     0,     1,         31    ; Edge 3
 EDGE       2,       4,     9,     5,         31    ; Edge 4
 EDGE       1,       2,     1,     5,         31    ; Edge 5
 EDGE       2,       8,     7,     3,         31    ; Edge 6
 EDGE       1,       3,     0,     4,         31    ; Edge 7
 EDGE       3,       8,     2,     6,         31    ; Edge 8
 EDGE       2,       9,     7,    10,         31    ; Edge 9
 EDGE       3,       4,     4,     8,         31    ; Edge 10
 EDGE       3,       9,     6,    11,         31    ; Edge 11
 EDGE       3,       5,     8,     8,          7    ; Edge 12
 EDGE       3,      10,    11,    11,          7    ; Edge 13
 EDGE       2,       5,     9,     9,          7    ; Edge 14
 EDGE       2,      10,    10,    10,          7    ; Edge 15
 EDGE       2,       7,     9,    10,         31    ; Edge 16
 EDGE       3,       6,     8,    11,         31    ; Edge 17
 EDGE       5,       6,     8,    12,         31    ; Edge 18
 EDGE       5,       7,     9,    12,         31    ; Edge 19
 EDGE       7,      10,    12,    10,         31    ; Edge 20
 EDGE       6,      10,    11,    12,         31    ; Edge 21
 EDGE       4,       5,     8,     9,         31    ; Edge 22
 EDGE       9,      10,    10,    11,         31    ; Edge 23
 EDGE       1,       4,     4,     5,         31    ; Edge 24
 EDGE       8,       9,     6,     7,         31    ; Edge 25

.SHIP_PYTHON_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -27,       40,       11,        31    ; Face 0
 FACE       27,       40,       11,        31    ; Face 1
 FACE      -27,      -40,       11,        31    ; Face 2
 FACE       27,      -40,       11,        31    ; Face 3
 FACE      -19,       38,        0,        31    ; Face 4
 FACE       19,       38,        0,        31    ; Face 5
 FACE      -19,      -38,        0,        31    ; Face 6
 FACE       19,      -38,        0,        31    ; Face 7
 FACE      -25,       37,      -11,        31    ; Face 8
 FACE       25,       37,      -11,        31    ; Face 9
 FACE       25,      -37,      -11,        31    ; Face 10
 FACE      -25,      -37,      -11,        31    ; Face 11
 FACE        0,        0,     -112,        31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_BOA
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Boa
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_BOA

 EQUB 5                 ; Max. canisters on demise = 5
 EQUW 70 * 70           ; Targetable area          = 70 * 70

 EQUB LO(SHIP_BOA_EDGES - SHIP_BOA)                ; Edges data offset (low)
 EQUB LO(SHIP_BOA_FACES - SHIP_BOA)                ; Faces data offset (low)

 EQUB 93                ; Max. edge count          = (93 - 1) / 4 = 23
 EQUB 0                 ; Gun vertex               = 0
 EQUB 38                ; Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 78                ; Number of vertices       = 78 / 6 = 13
 EQUB 24                ; Number of edges          = 24
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 40                ; Visibility distance      = 40
 EQUB 250               ; Max. energy              = 250
 EQUB 24                ; Max. speed               = 24

 EQUB HI(SHIP_BOA_EDGES - SHIP_BOA)                ; Edges data offset (high)
 EQUB HI(SHIP_BOA_FACES - SHIP_BOA)                ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00011100         ; Laser power              = 3
                        ; Missiles                 = 4

.SHIP_BOA_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   93,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX    0,   40,  -87,     2,      0,    3,     3,         24    ; Vertex 1
 VERTEX   38,  -25,  -99,     1,      0,    4,     4,         24    ; Vertex 2
 VERTEX  -38,  -25,  -99,     2,      1,    5,     5,         24    ; Vertex 3
 VERTEX  -38,   40,  -59,     3,      2,    9,     6,         31    ; Vertex 4
 VERTEX   38,   40,  -59,     3,      0,   11,     6,         31    ; Vertex 5
 VERTEX   62,    0,  -67,     4,      0,   11,     8,         31    ; Vertex 6
 VERTEX   24,  -65,  -79,     4,      1,   10,     8,         31    ; Vertex 7
 VERTEX  -24,  -65,  -79,     5,      1,   10,     7,         31    ; Vertex 8
 VERTEX  -62,    0,  -67,     5,      2,    9,     7,         31    ; Vertex 9
 VERTEX    0,    7, -107,     2,      0,   10,    10,         22    ; Vertex 10
 VERTEX   13,   -9, -107,     1,      0,   10,    10,         22    ; Vertex 11
 VERTEX  -13,   -9, -107,     2,      1,   12,    12,         22    ; Vertex 12

.SHIP_BOA_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       5,    11,     6,         31    ; Edge 0
 EDGE       0,       7,    10,     8,         31    ; Edge 1
 EDGE       0,       9,     9,     7,         31    ; Edge 2
 EDGE       0,       4,     9,     6,         29    ; Edge 3
 EDGE       0,       6,    11,     8,         29    ; Edge 4
 EDGE       0,       8,    10,     7,         29    ; Edge 5
 EDGE       4,       5,     6,     3,         31    ; Edge 6
 EDGE       5,       6,    11,     0,         31    ; Edge 7
 EDGE       6,       7,     8,     4,         31    ; Edge 8
 EDGE       7,       8,    10,     1,         31    ; Edge 9
 EDGE       8,       9,     7,     5,         31    ; Edge 10
 EDGE       4,       9,     9,     2,         31    ; Edge 11
 EDGE       1,       4,     3,     2,         24    ; Edge 12
 EDGE       1,       5,     3,     0,         24    ; Edge 13
 EDGE       3,       9,     5,     2,         24    ; Edge 14
 EDGE       3,       8,     5,     1,         24    ; Edge 15
 EDGE       2,       6,     4,     0,         24    ; Edge 16
 EDGE       2,       7,     4,     1,         24    ; Edge 17
 EDGE       1,      10,     2,     0,         22    ; Edge 18
 EDGE       2,      11,     1,     0,         22    ; Edge 19
 EDGE       3,      12,     2,     1,         22    ; Edge 20
 EDGE      10,      11,    12,     0,         14    ; Edge 21
 EDGE      11,      12,    12,     1,         14    ; Edge 22
 EDGE      12,      10,    12,     2,         14    ; Edge 23

.SHIP_BOA_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       43,       37,      -60,         31    ; Face 0
 FACE        0,      -45,      -89,         31    ; Face 1
 FACE      -43,       37,      -60,         31    ; Face 2
 FACE        0,       40,        0,         31    ; Face 3
 FACE       62,      -32,      -20,         31    ; Face 4
 FACE      -62,      -32,      -20,         31    ; Face 5
 FACE        0,       23,        6,         31    ; Face 6
 FACE      -23,      -15,        9,         31    ; Face 7
 FACE       23,      -15,        9,         31    ; Face 8
 FACE      -26,       13,       10,         31    ; Face 9
 FACE        0,      -31,       12,         31    ; Face 10
 FACE       26,       13,       10,         31    ; Face 11
 FACE        0,        0,     -107,         14    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_ANACONDA
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an Anaconda
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ANACONDA

 EQUB 7                 ; Max. canisters on demise = 7
 EQUW 100 * 100         ; Targetable area          = 100 * 100

 EQUB LO(SHIP_ANACONDA_EDGES - SHIP_ANACONDA)      ; Edges data offset (low)
 EQUB LO(SHIP_ANACONDA_FACES - SHIP_ANACONDA)      ; Faces data offset (low)

 EQUB 93                ; Max. edge count          = (93 - 1) / 4 = 23
 EQUB 48                ; Gun vertex               = 48 / 4 = 12
 EQUB 46                ; Explosion count          = 10, as (4 * n) + 6 = 46
 EQUB 90                ; Number of vertices       = 90 / 6 = 15
 EQUB 25                ; Number of edges          = 25
 EQUW 0                 ; Bounty                   = 0
 EQUB 48                ; Number of faces          = 48 / 4 = 12
 EQUB 36                ; Visibility distance      = 36
 EQUB 252               ; Max. energy              = 252
 EQUB 14                ; Max. speed               = 14

 EQUB HI(SHIP_ANACONDA_EDGES - SHIP_ANACONDA)      ; Edges data offset (high)
 EQUB HI(SHIP_ANACONDA_FACES - SHIP_ANACONDA)      ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00111111         ; Laser power              = 7
                        ; Missiles                 = 7

.SHIP_ANACONDA_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    7,  -58,     1,      0,    5,     5,         30    ; Vertex 0
 VERTEX  -43,  -13,  -37,     1,      0,    2,     2,         30    ; Vertex 1
 VERTEX  -26,  -47,   -3,     2,      0,    3,     3,         30    ; Vertex 2
 VERTEX   26,  -47,   -3,     3,      0,    4,     4,         30    ; Vertex 3
 VERTEX   43,  -13,  -37,     4,      0,    5,     5,         30    ; Vertex 4
 VERTEX    0,   48,  -49,     5,      1,    6,     6,         30    ; Vertex 5
 VERTEX  -69,   15,  -15,     2,      1,    7,     7,         30    ; Vertex 6
 VERTEX  -43,  -39,   40,     3,      2,    8,     8,         31    ; Vertex 7
 VERTEX   43,  -39,   40,     4,      3,    9,     9,         31    ; Vertex 8
 VERTEX   69,   15,  -15,     5,      4,   10,    10,         30    ; Vertex 9
 VERTEX  -43,   53,  -23,    15,     15,   15,    15,         31    ; Vertex 10
 VERTEX  -69,   -1,   32,     7,      2,    8,     8,         31    ; Vertex 11
 VERTEX    0,    0,  254,    15,     15,   15,    15,         31    ; Vertex 12
 VERTEX   69,   -1,   32,     9,      4,   10,    10,         31    ; Vertex 13
 VERTEX   43,   53,  -23,    15,     15,   15,    15,         31    ; Vertex 14

.SHIP_ANACONDA_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         30    ; Edge 0
 EDGE       1,       2,     2,     0,         30    ; Edge 1
 EDGE       2,       3,     3,     0,         30    ; Edge 2
 EDGE       3,       4,     4,     0,         30    ; Edge 3
 EDGE       0,       4,     5,     0,         30    ; Edge 4
 EDGE       0,       5,     5,     1,         29    ; Edge 5
 EDGE       1,       6,     2,     1,         29    ; Edge 6
 EDGE       2,       7,     3,     2,         29    ; Edge 7
 EDGE       3,       8,     4,     3,         29    ; Edge 8
 EDGE       4,       9,     5,     4,         29    ; Edge 9
 EDGE       5,      10,     6,     1,         30    ; Edge 10
 EDGE       6,      10,     7,     1,         30    ; Edge 11
 EDGE       6,      11,     7,     2,         30    ; Edge 12
 EDGE       7,      11,     8,     2,         30    ; Edge 13
 EDGE       7,      12,     8,     3,         31    ; Edge 14
 EDGE       8,      12,     9,     3,         31    ; Edge 15
 EDGE       8,      13,     9,     4,         30    ; Edge 16
 EDGE       9,      13,    10,     4,         30    ; Edge 17
 EDGE       9,      14,    10,     5,         30    ; Edge 18
 EDGE       5,      14,     6,     5,         30    ; Edge 19
 EDGE      10,      14,    11,     6,         30    ; Edge 20
 EDGE      10,      12,    11,     7,         31    ; Edge 21
 EDGE      11,      12,     8,     7,         31    ; Edge 22
 EDGE      12,      13,    10,     9,         31    ; Edge 23
 EDGE      12,      14,    11,    10,         31    ; Edge 24

.SHIP_ANACONDA_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,      -51,      -49,         30    ; Face 0
 FACE      -51,       18,      -87,         30    ; Face 1
 FACE      -77,      -57,      -19,         30    ; Face 2
 FACE        0,      -90,       16,         31    ; Face 3
 FACE       77,      -57,      -19,         30    ; Face 4
 FACE       51,       18,      -87,         30    ; Face 5
 FACE        0,      111,      -20,         30    ; Face 6
 FACE      -97,       72,       24,         31    ; Face 7
 FACE     -108,      -68,       34,         31    ; Face 8
 FACE      108,      -68,       34,         31    ; Face 9
 FACE       97,       72,       24,         31    ; Face 10
 FACE        0,       94,       18,         31    ; Face 11

; ******************************************************************************
;
;       Name: SHIP_ROCK_HERMIT
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a rock hermit (asteroid)
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The ship blueprint for the rock hermit reuses the edges and faces data from
; the asteroid, so the edges and faces data offsets are negative.
;
; ******************************************************************************

.SHIP_ROCK_HERMIT

 EQUB 7                 ; Max. canisters on demise = 7
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_ROCK_HERMIT_EDGES - SHIP_ROCK_HERMIT)   ; Edges data offset (low)
 EQUB LO(SHIP_ROCK_HERMIT_FACES - SHIP_ROCK_HERMIT)   ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 50                ; Explosion count          = 11, as (4 * n) + 6 = 50
 EQUB 54                ; Number of vertices       = 54 / 6 = 9
 EQUB 21                ; Number of edges          = 21
 EQUW 0                 ; Bounty                   = 0
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 50                ; Visibility distance      = 50
 EQUB 180               ; Max. energy              = 180
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_ROCK_HERMIT_EDGES - SHIP_ROCK_HERMIT)   ; Edges data offset (high)
 EQUB HI(SHIP_ROCK_HERMIT_FACES - SHIP_ROCK_HERMIT)   ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00000010         ; Laser power              = 0
                        ; Missiles                 = 2

.SHIP_ROCK_HERMIT_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   80,    0,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -80,  -10,    0,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,  -80,    0,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX   70,  -40,    0,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX   60,   50,    0,     5,      6,   12,    13,         31    ; Vertex 4
 VERTEX   50,    0,   60,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX  -40,    0,   70,     0,      1,    2,     3,         31    ; Vertex 6
 VERTEX    0,   30,  -75,    15,     15,   15,    15,         31    ; Vertex 7
 VERTEX    0,  -50,  -60,     8,      9,   10,    11,         31    ; Vertex 8

.SHIP_ROCK_HERMIT_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     7,         31    ; Edge 0
 EDGE       0,       4,     6,    13,         31    ; Edge 1
 EDGE       3,       4,     5,    12,         31    ; Edge 2
 EDGE       2,       3,     4,    11,         31    ; Edge 3
 EDGE       1,       2,     3,    10,         31    ; Edge 4
 EDGE       1,       6,     2,     3,         31    ; Edge 5
 EDGE       2,       6,     1,     3,         31    ; Edge 6
 EDGE       2,       5,     1,     4,         31    ; Edge 7
 EDGE       5,       6,     0,     1,         31    ; Edge 8
 EDGE       0,       5,     0,     6,         31    ; Edge 9
 EDGE       3,       5,     4,     5,         31    ; Edge 10
 EDGE       0,       6,     0,     2,         31    ; Edge 11
 EDGE       4,       5,     5,     6,         31    ; Edge 12
 EDGE       1,       8,     8,    10,         31    ; Edge 13
 EDGE       1,       7,     7,     8,         31    ; Edge 14
 EDGE       0,       7,     7,    13,         31    ; Edge 15
 EDGE       4,       7,    12,    13,         31    ; Edge 16
 EDGE       3,       7,     9,    12,         31    ; Edge 17
 EDGE       3,       8,     9,    11,         31    ; Edge 18
 EDGE       2,       8,    10,    11,         31    ; Edge 19
 EDGE       7,       8,     8,     9,         31    ; Edge 20

.SHIP_ROCK_HERMIT_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        9,       66,       81,         31    ; Face 0
 FACE        9,      -66,       81,         31    ; Face 1
 FACE      -72,       64,       31,         31    ; Face 2
 FACE      -64,      -73,       47,         31    ; Face 3
 FACE       45,      -79,       65,         31    ; Face 4
 FACE      135,       15,       35,         31    ; Face 5
 FACE       38,       76,       70,         31    ; Face 6
 FACE      -66,       59,      -39,         31    ; Face 7
 FACE      -67,      -15,      -80,         31    ; Face 8
 FACE       66,      -14,      -75,         31    ; Face 9
 FACE      -70,      -80,      -40,         31    ; Face 10
 FACE       58,     -102,      -51,         31    ; Face 11
 FACE       81,        9,      -67,         31    ; Face 12
 FACE       47,       94,      -63,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_VIPER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Viper
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_VIPER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 75 * 75           ; Targetable area          = 75 * 75

 EQUB LO(SHIP_VIPER_EDGES - SHIP_VIPER)            ; Edges data offset (low)
 EQUB LO(SHIP_VIPER_FACES - SHIP_VIPER)            ; Faces data offset (low)

 EQUB 81                ; Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 90                ; Number of vertices       = 90 / 6 = 15
 EQUB 20                ; Number of edges          = 20
 EQUW 0                 ; Bounty                   = 0
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 23                ; Visibility distance      = 23
 EQUB 140               ; Max. energy              = 140
 EQUB 32                ; Max. speed               = 32

 EQUB HI(SHIP_VIPER_EDGES - SHIP_VIPER)            ; Edges data offset (high)
 EQUB HI(SHIP_VIPER_FACES - SHIP_VIPER)            ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010001         ; Laser power              = 2
                        ; Missiles                 = 1

.SHIP_VIPER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   72,     1,      2,    3,     4,         31    ; Vertex 0
 VERTEX    0,   16,   24,     0,      1,    2,     2,         30    ; Vertex 1
 VERTEX    0,  -16,   24,     3,      4,    5,     5,         30    ; Vertex 2
 VERTEX   48,    0,  -24,     2,      4,    6,     6,         31    ; Vertex 3
 VERTEX  -48,    0,  -24,     1,      3,    6,     6,         31    ; Vertex 4
 VERTEX   24,  -16,  -24,     4,      5,    6,     6,         30    ; Vertex 5
 VERTEX  -24,  -16,  -24,     5,      3,    6,     6,         30    ; Vertex 6
 VERTEX   24,   16,  -24,     0,      2,    6,     6,         31    ; Vertex 7
 VERTEX  -24,   16,  -24,     0,      1,    6,     6,         31    ; Vertex 8
 VERTEX  -32,    0,  -24,     6,      6,    6,     6,         19    ; Vertex 9
 VERTEX   32,    0,  -24,     6,      6,    6,     6,         19    ; Vertex 10
 VERTEX    8,    8,  -24,     6,      6,    6,     6,         19    ; Vertex 11
 VERTEX   -8,    8,  -24,     6,      6,    6,     6,         19    ; Vertex 12
 VERTEX   -8,   -8,  -24,     6,      6,    6,     6,         18    ; Vertex 13
 VERTEX    8,   -8,  -24,     6,      6,    6,     6,         18    ; Vertex 14

.SHIP_VIPER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       3,     2,     4,         31    ; Edge 0
 EDGE       0,       1,     1,     2,         30    ; Edge 1
 EDGE       0,       2,     3,     4,         30    ; Edge 2
 EDGE       0,       4,     1,     3,         31    ; Edge 3
 EDGE       1,       7,     0,     2,         30    ; Edge 4
 EDGE       1,       8,     0,     1,         30    ; Edge 5
 EDGE       2,       5,     4,     5,         30    ; Edge 6
 EDGE       2,       6,     3,     5,         30    ; Edge 7
 EDGE       7,       8,     0,     6,         31    ; Edge 8
 EDGE       5,       6,     5,     6,         30    ; Edge 9
 EDGE       4,       8,     1,     6,         31    ; Edge 10
 EDGE       4,       6,     3,     6,         30    ; Edge 11
 EDGE       3,       7,     2,     6,         31    ; Edge 12
 EDGE       3,       5,     6,     4,         30    ; Edge 13
 EDGE       9,      12,     6,     6,         19    ; Edge 14
 EDGE       9,      13,     6,     6,         18    ; Edge 15
 EDGE      10,      11,     6,     6,         19    ; Edge 16
 EDGE      10,      14,     6,     6,         18    ; Edge 17
 EDGE      11,      14,     6,     6,         16    ; Edge 18
 EDGE      12,      13,     6,     6,         16    ; Edge 19

.SHIP_VIPER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       32,        0,         31    ; Face 0
 FACE      -22,       33,       11,         31    ; Face 1
 FACE       22,       33,       11,         31    ; Face 2
 FACE      -22,      -33,       11,         31    ; Face 3
 FACE       22,      -33,       11,         31    ; Face 4
 FACE        0,      -32,        0,         31    ; Face 5
 FACE        0,        0,      -48,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_SIDEWINDER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Sidewinder
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_SIDEWINDER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 65 * 65           ; Targetable area          = 65 * 65

 EQUB LO(SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)  ; Edges data offset (low)
 EQUB LO(SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)  ; Faces data offset (low)

 EQUB 65                ; Max. edge count          = (65 - 1) / 4 = 16
 EQUB 0                 ; Gun vertex               = 0
 EQUB 30                ; Explosion count          = 6, as (4 * n) + 6 = 30
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 15                ; Number of edges          = 15
 EQUW 50                ; Bounty                   = 50
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 20                ; Visibility distance      = 20
 EQUB 70                ; Max. energy              = 70
 EQUB 37                ; Max. speed               = 37

 EQUB HI(SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)  ; Edges data offset (high)
 EQUB HI(SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)  ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_SIDEWINDER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -32,    0,   36,     0,      1,    4,     5,         31    ; Vertex 0
 VERTEX   32,    0,   36,     0,      2,    5,     6,         31    ; Vertex 1
 VERTEX   64,    0,  -28,     2,      3,    6,     6,         31    ; Vertex 2
 VERTEX  -64,    0,  -28,     1,      3,    4,     4,         31    ; Vertex 3
 VERTEX    0,   16,  -28,     0,      1,    2,     3,         31    ; Vertex 4
 VERTEX    0,  -16,  -28,     3,      4,    5,     6,         31    ; Vertex 5
 VERTEX  -12,    6,  -28,     3,      3,    3,     3,         15    ; Vertex 6
 VERTEX   12,    6,  -28,     3,      3,    3,     3,         15    ; Vertex 7
 VERTEX   12,   -6,  -28,     3,      3,    3,     3,         12    ; Vertex 8
 VERTEX  -12,   -6,  -28,     3,      3,    3,     3,         12    ; Vertex 9

.SHIP_SIDEWINDER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     5,         31    ; Edge 0
 EDGE       1,       2,     2,     6,         31    ; Edge 1
 EDGE       1,       4,     0,     2,         31    ; Edge 2
 EDGE       0,       4,     0,     1,         31    ; Edge 3
 EDGE       0,       3,     1,     4,         31    ; Edge 4
 EDGE       3,       4,     1,     3,         31    ; Edge 5
 EDGE       2,       4,     2,     3,         31    ; Edge 6
 EDGE       3,       5,     3,     4,         31    ; Edge 7
 EDGE       2,       5,     3,     6,         31    ; Edge 8
 EDGE       1,       5,     5,     6,         31    ; Edge 9
 EDGE       0,       5,     4,     5,         31    ; Edge 10
 EDGE       6,       7,     3,     3,         15    ; Edge 11
 EDGE       7,       8,     3,     3,         12    ; Edge 12
 EDGE       6,       9,     3,     3,         12    ; Edge 13
 EDGE       8,       9,     3,     3,         12    ; Edge 14

.SHIP_SIDEWINDER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       32,        8,         31    ; Face 0
 FACE      -12,       47,        6,         31    ; Face 1
 FACE       12,       47,        6,         31    ; Face 2
 FACE        0,        0,     -112,         31    ; Face 3
 FACE      -12,      -47,        6,         31    ; Face 4
 FACE        0,      -32,        8,         31    ; Face 5
 FACE       12,      -47,        6,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_MAMBA
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Mamba
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_MAMBA

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 70 * 70           ; Targetable area          = 70 * 70

 EQUB LO(SHIP_MAMBA_EDGES - SHIP_MAMBA)            ; Edges data offset (low)
 EQUB LO(SHIP_MAMBA_FACES - SHIP_MAMBA)            ; Faces data offset (low)

 EQUB 97                ; Max. edge count          = (97 - 1) / 4 = 24
 EQUB 0                 ; Gun vertex               = 0
 EQUB 34                ; Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 150               ; Number of vertices       = 150 / 6 = 25
 EQUB 28                ; Number of edges          = 28
 EQUW 150               ; Bounty                   = 150
 EQUB 20                ; Number of faces          = 20 / 4 = 5
 EQUB 25                ; Visibility distance      = 25
 EQUB 90                ; Max. energy              = 90
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_MAMBA_EDGES - SHIP_MAMBA)            ; Edges data offset (high)
 EQUB HI(SHIP_MAMBA_FACES - SHIP_MAMBA)            ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_MAMBA_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   64,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX  -64,   -8,  -32,     0,      2,    4,     4,         31    ; Vertex 1
 VERTEX  -32,    8,  -32,     1,      2,    4,     4,         30    ; Vertex 2
 VERTEX   32,    8,  -32,     1,      3,    4,     4,         30    ; Vertex 3
 VERTEX   64,   -8,  -32,     0,      3,    4,     4,         31    ; Vertex 4
 VERTEX   -4,    4,   16,     1,      1,    1,     1,         14    ; Vertex 5
 VERTEX    4,    4,   16,     1,      1,    1,     1,         14    ; Vertex 6
 VERTEX    8,    3,   28,     1,      1,    1,     1,         13    ; Vertex 7
 VERTEX   -8,    3,   28,     1,      1,    1,     1,         13    ; Vertex 8
 VERTEX  -20,   -4,   16,     0,      0,    0,     0,         20    ; Vertex 9
 VERTEX   20,   -4,   16,     0,      0,    0,     0,         20    ; Vertex 10
 VERTEX  -24,   -7,  -20,     0,      0,    0,     0,         20    ; Vertex 11
 VERTEX  -16,   -7,  -20,     0,      0,    0,     0,         16    ; Vertex 12
 VERTEX   16,   -7,  -20,     0,      0,    0,     0,         16    ; Vertex 13
 VERTEX   24,   -7,  -20,     0,      0,    0,     0,         20    ; Vertex 14
 VERTEX   -8,    4,  -32,     4,      4,    4,     4,         13    ; Vertex 15
 VERTEX    8,    4,  -32,     4,      4,    4,     4,         13    ; Vertex 16
 VERTEX    8,   -4,  -32,     4,      4,    4,     4,         14    ; Vertex 17
 VERTEX   -8,   -4,  -32,     4,      4,    4,     4,         14    ; Vertex 18
 VERTEX  -32,    4,  -32,     4,      4,    4,     4,          7    ; Vertex 19
 VERTEX   32,    4,  -32,     4,      4,    4,     4,          7    ; Vertex 20
 VERTEX   36,   -4,  -32,     4,      4,    4,     4,          7    ; Vertex 21
 VERTEX  -36,   -4,  -32,     4,      4,    4,     4,          7    ; Vertex 22
 VERTEX  -38,    0,  -32,     4,      4,    4,     4,          5    ; Vertex 23
 VERTEX   38,    0,  -32,     4,      4,    4,     4,          5    ; Vertex 24

.SHIP_MAMBA_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     2,         31    ; Edge 0
 EDGE       0,       4,     0,     3,         31    ; Edge 1
 EDGE       1,       4,     0,     4,         31    ; Edge 2
 EDGE       1,       2,     2,     4,         30    ; Edge 3
 EDGE       2,       3,     1,     4,         30    ; Edge 4
 EDGE       3,       4,     3,     4,         30    ; Edge 5
 EDGE       5,       6,     1,     1,         14    ; Edge 6
 EDGE       6,       7,     1,     1,         12    ; Edge 7
 EDGE       7,       8,     1,     1,         13    ; Edge 8
 EDGE       5,       8,     1,     1,         12    ; Edge 9
 EDGE       9,      11,     0,     0,         20    ; Edge 10
 EDGE       9,      12,     0,     0,         16    ; Edge 11
 EDGE      10,      13,     0,     0,         16    ; Edge 12
 EDGE      10,      14,     0,     0,         20    ; Edge 13
 EDGE      13,      14,     0,     0,         14    ; Edge 14
 EDGE      11,      12,     0,     0,         14    ; Edge 15
 EDGE      15,      16,     4,     4,         13    ; Edge 16
 EDGE      17,      18,     4,     4,         14    ; Edge 17
 EDGE      15,      18,     4,     4,         12    ; Edge 18
 EDGE      16,      17,     4,     4,         12    ; Edge 19
 EDGE      20,      21,     4,     4,          7    ; Edge 20
 EDGE      20,      24,     4,     4,          5    ; Edge 21
 EDGE      21,      24,     4,     4,          5    ; Edge 22
 EDGE      19,      22,     4,     4,          7    ; Edge 23
 EDGE      19,      23,     4,     4,          5    ; Edge 24
 EDGE      22,      23,     4,     4,          5    ; Edge 25
 EDGE       0,       2,     1,     2,         30    ; Edge 26
 EDGE       0,       3,     1,     3,         30    ; Edge 27

.SHIP_MAMBA_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,      -24,        2,         30    ; Face 0
 FACE        0,       24,        2,         30    ; Face 1
 FACE      -32,       64,       16,         30    ; Face 2
 FACE       32,       64,       16,         30    ; Face 3
 FACE        0,        0,     -127,         30    ; Face 4

; ******************************************************************************
;
;       Name: SHIP_KRAIT
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Krait
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_KRAIT

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 60 * 60           ; Targetable area          = 60 * 60

 EQUB LO(SHIP_KRAIT_EDGES - SHIP_KRAIT)            ; Edges data offset (low)
 EQUB LO(SHIP_KRAIT_FACES - SHIP_KRAIT)            ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 102               ; Number of vertices       = 102 / 6 = 17
 EQUB 21                ; Number of edges          = 21
 EQUW 100               ; Bounty                   = 100
 EQUB 24                ; Number of faces          = 24 / 4 = 6
 EQUB 20                ; Visibility distance      = 20
 EQUB 80                ; Max. energy              = 80
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_KRAIT_EDGES - SHIP_KRAIT)            ; Edges data offset (high)
 EQUB HI(SHIP_KRAIT_FACES - SHIP_KRAIT)            ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_KRAIT_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   96,     1,      0,    3,     2,         31    ; Vertex 0
 VERTEX    0,   18,  -48,     3,      0,    5,     4,         31    ; Vertex 1
 VERTEX    0,  -18,  -48,     2,      1,    5,     4,         31    ; Vertex 2
 VERTEX   90,    0,   -3,     1,      0,    4,     4,         31    ; Vertex 3
 VERTEX  -90,    0,   -3,     3,      2,    5,     5,         31    ; Vertex 4
 VERTEX   90,    0,   87,     1,      0,    1,     1,         30    ; Vertex 5
 VERTEX  -90,    0,   87,     3,      2,    3,     3,         30    ; Vertex 6
 VERTEX    0,    5,   53,     0,      0,    3,     3,          9    ; Vertex 7
 VERTEX    0,    7,   38,     0,      0,    3,     3,          6    ; Vertex 8
 VERTEX  -18,    7,   19,     3,      3,    3,     3,          9    ; Vertex 9
 VERTEX   18,    7,   19,     0,      0,    0,     0,          9    ; Vertex 10
 VERTEX   18,   11,  -39,     4,      4,    4,     4,          8    ; Vertex 11
 VERTEX   18,  -11,  -39,     4,      4,    4,     4,          8    ; Vertex 12
 VERTEX   36,    0,  -30,     4,      4,    4,     4,          8    ; Vertex 13
 VERTEX  -18,   11,  -39,     5,      5,    5,     5,          8    ; Vertex 14
 VERTEX  -18,  -11,  -39,     5,      5,    5,     5,          8    ; Vertex 15
 VERTEX  -36,    0,  -30,     5,      5,    5,     5,          8    ; Vertex 16

.SHIP_KRAIT_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     0,         31    ; Edge 0
 EDGE       0,       2,     2,     1,         31    ; Edge 1
 EDGE       0,       3,     1,     0,         31    ; Edge 2
 EDGE       0,       4,     3,     2,         31    ; Edge 3
 EDGE       1,       4,     5,     3,         31    ; Edge 4
 EDGE       4,       2,     5,     2,         31    ; Edge 5
 EDGE       2,       3,     4,     1,         31    ; Edge 6
 EDGE       3,       1,     4,     0,         31    ; Edge 7
 EDGE       3,       5,     1,     0,         30    ; Edge 8
 EDGE       4,       6,     3,     2,         30    ; Edge 9
 EDGE       1,       2,     5,     4,          8    ; Edge 10
 EDGE       7,      10,     0,     0,          9    ; Edge 11
 EDGE       8,      10,     0,     0,          6    ; Edge 12
 EDGE       7,       9,     3,     3,          9    ; Edge 13
 EDGE       8,       9,     3,     3,          6    ; Edge 14
 EDGE      11,      13,     4,     4,          8    ; Edge 15
 EDGE      13,      12,     4,     4,          8    ; Edge 16
 EDGE      12,      11,     4,     4,          7    ; Edge 17
 EDGE      14,      15,     5,     5,          7    ; Edge 18
 EDGE      15,      16,     5,     5,          8    ; Edge 19
 EDGE      16,      14,     5,     5,          8    ; Edge 20

.SHIP_KRAIT_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        3,       24,        3,         31    ; Face 0
 FACE        3,      -24,        3,         31    ; Face 1
 FACE       -3,      -24,        3,         31    ; Face 2
 FACE       -3,       24,        3,         31    ; Face 3
 FACE       38,        0,      -77,         31    ; Face 4
 FACE      -38,        0,      -77,         31    ; Face 5

; ******************************************************************************
;
;       Name: SHIP_ADDER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an Adder
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ADDER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 50 * 50           ; Targetable area          = 50 * 50

 EQUB LO(SHIP_ADDER_EDGES - SHIP_ADDER)            ; Edges data offset (low)
 EQUB LO(SHIP_ADDER_FACES - SHIP_ADDER)            ; Faces data offset (low)

 EQUB 101               ; Max. edge count          = (101 - 1) / 4 = 25
 EQUB 0                 ; Gun vertex               = 0
 EQUB 22                ; Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 108               ; Number of vertices       = 108 / 6 = 18
 EQUB 29                ; Number of edges          = 29
 EQUW 40                ; Bounty                   = 40
 EQUB 60                ; Number of faces          = 60 / 4 = 15
 EQUB 20                ; Visibility distance      = 20
 EQUB 85                ; Max. energy              = 85
 EQUB 24                ; Max. speed               = 24

 EQUB HI(SHIP_ADDER_EDGES - SHIP_ADDER)            ; Edges data offset (high)
 EQUB HI(SHIP_ADDER_FACES - SHIP_ADDER)            ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_ADDER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,    0,   40,     1,      0,   12,    11,         31    ; Vertex 0
 VERTEX   18,    0,   40,     1,      0,    3,     2,         31    ; Vertex 1
 VERTEX   30,    0,  -24,     3,      2,    5,     4,         31    ; Vertex 2
 VERTEX   30,    0,  -40,     5,      4,    6,     6,         31    ; Vertex 3
 VERTEX   18,   -7,  -40,     6,      5,   14,     7,         31    ; Vertex 4
 VERTEX  -18,   -7,  -40,     8,      7,   14,    10,         31    ; Vertex 5
 VERTEX  -30,    0,  -40,     9,      8,   10,    10,         31    ; Vertex 6
 VERTEX  -30,    0,  -24,    10,      9,   12,    11,         31    ; Vertex 7
 VERTEX  -18,    7,  -40,     8,      7,   13,     9,         31    ; Vertex 8
 VERTEX   18,    7,  -40,     6,      4,   13,     7,         31    ; Vertex 9
 VERTEX  -18,    7,   13,     9,      0,   13,    11,         31    ; Vertex 10
 VERTEX   18,    7,   13,     2,      0,   13,     4,         31    ; Vertex 11
 VERTEX  -18,   -7,   13,    10,      1,   14,    12,         31    ; Vertex 12
 VERTEX   18,   -7,   13,     3,      1,   14,     5,         31    ; Vertex 13
 VERTEX  -11,    3,   29,     0,      0,    0,     0,          5    ; Vertex 14
 VERTEX   11,    3,   29,     0,      0,    0,     0,          5    ; Vertex 15
 VERTEX   11,    4,   24,     0,      0,    0,     0,          4    ; Vertex 16
 VERTEX  -11,    4,   24,     0,      0,    0,     0,          4    ; Vertex 17

.SHIP_ADDER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    ; Edge 0
 EDGE       1,       2,     3,     2,          7    ; Edge 1
 EDGE       2,       3,     5,     4,         31    ; Edge 2
 EDGE       3,       4,     6,     5,         31    ; Edge 3
 EDGE       4,       5,    14,     7,         31    ; Edge 4
 EDGE       5,       6,    10,     8,         31    ; Edge 5
 EDGE       6,       7,    10,     9,         31    ; Edge 6
 EDGE       7,       0,    12,    11,          7    ; Edge 7
 EDGE       3,       9,     6,     4,         31    ; Edge 8
 EDGE       9,       8,    13,     7,         31    ; Edge 9
 EDGE       8,       6,     9,     8,         31    ; Edge 10
 EDGE       0,      10,    11,     0,         31    ; Edge 11
 EDGE       7,      10,    11,     9,         31    ; Edge 12
 EDGE       1,      11,     2,     0,         31    ; Edge 13
 EDGE       2,      11,     4,     2,         31    ; Edge 14
 EDGE       0,      12,    12,     1,         31    ; Edge 15
 EDGE       7,      12,    12,    10,         31    ; Edge 16
 EDGE       1,      13,     3,     1,         31    ; Edge 17
 EDGE       2,      13,     5,     3,         31    ; Edge 18
 EDGE      10,      11,    13,     0,         31    ; Edge 19
 EDGE      12,      13,    14,     1,         31    ; Edge 20
 EDGE       8,      10,    13,     9,         31    ; Edge 21
 EDGE       9,      11,    13,     4,         31    ; Edge 22
 EDGE       5,      12,    14,    10,         31    ; Edge 23
 EDGE       4,      13,    14,     5,         31    ; Edge 24
 EDGE      14,      15,     0,     0,          5    ; Edge 25
 EDGE      15,      16,     0,     0,          3    ; Edge 26
 EDGE      16,      17,     0,     0,          4    ; Edge 27
 EDGE      17,      14,     0,     0,          3    ; Edge 28

.SHIP_ADDER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       39,       10,         31    ; Face 0
 FACE        0,      -39,       10,         31    ; Face 1
 FACE       69,       50,       13,         31    ; Face 2
 FACE       69,      -50,       13,         31    ; Face 3
 FACE       30,       52,        0,         31    ; Face 4
 FACE       30,      -52,        0,         31    ; Face 5
 FACE        0,        0,     -160,         31    ; Face 6
 FACE        0,        0,     -160,         31    ; Face 7
 FACE        0,        0,     -160,         31    ; Face 8
 FACE      -30,       52,        0,         31    ; Face 9
 FACE      -30,      -52,        0,         31    ; Face 10
 FACE      -69,       50,       13,         31    ; Face 11
 FACE      -69,      -50,       13,         31    ; Face 12
 FACE        0,       28,        0,         31    ; Face 13
 FACE        0,      -28,        0,         31    ; Face 14

; ******************************************************************************
;
;       Name: SHIP_GECKO
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Gecko
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_GECKO

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_GECKO_EDGES - SHIP_GECKO)            ; Edges data offset (low)
 EQUB LO(SHIP_GECKO_FACES - SHIP_GECKO)            ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 72                ; Number of vertices       = 72 / 6 = 12
 EQUB 17                ; Number of edges          = 17
 EQUW 55                ; Bounty                   = 55
 EQUB 36                ; Number of faces          = 36 / 4 = 9
 EQUB 18                ; Visibility distance      = 18
 EQUB 70                ; Max. energy              = 70
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_GECKO_EDGES - SHIP_GECKO)            ; Edges data offset (high)
 EQUB HI(SHIP_GECKO_FACES - SHIP_GECKO)            ; Faces data offset (high)

 EQUB 3                 ; Normals are scaled by    = 2^3 = 8
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_GECKO_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -10,   -4,   47,     3,      0,    5,     4,         31    ; Vertex 0
 VERTEX   10,   -4,   47,     1,      0,    3,     2,         31    ; Vertex 1
 VERTEX  -16,    8,  -23,     5,      0,    7,     6,         31    ; Vertex 2
 VERTEX   16,    8,  -23,     1,      0,    8,     7,         31    ; Vertex 3
 VERTEX  -66,    0,   -3,     5,      4,    6,     6,         31    ; Vertex 4
 VERTEX   66,    0,   -3,     2,      1,    8,     8,         31    ; Vertex 5
 VERTEX  -20,  -14,  -23,     4,      3,    7,     6,         31    ; Vertex 6
 VERTEX   20,  -14,  -23,     3,      2,    8,     7,         31    ; Vertex 7
 VERTEX   -8,   -6,   33,     3,      3,    3,     3,         16    ; Vertex 8
 VERTEX    8,   -6,   33,     3,      3,    3,     3,         17    ; Vertex 9
 VERTEX   -8,  -13,  -16,     3,      3,    3,     3,         16    ; Vertex 10
 VERTEX    8,  -13,  -16,     3,      3,    3,     3,         17    ; Vertex 11

.SHIP_GECKO_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     0,         31    ; Edge 0
 EDGE       1,       5,     2,     1,         31    ; Edge 1
 EDGE       5,       3,     8,     1,         31    ; Edge 2
 EDGE       3,       2,     7,     0,         31    ; Edge 3
 EDGE       2,       4,     6,     5,         31    ; Edge 4
 EDGE       4,       0,     5,     4,         31    ; Edge 5
 EDGE       5,       7,     8,     2,         31    ; Edge 6
 EDGE       7,       6,     7,     3,         31    ; Edge 7
 EDGE       6,       4,     6,     4,         31    ; Edge 8
 EDGE       0,       2,     5,     0,         29    ; Edge 9
 EDGE       1,       3,     1,     0,         30    ; Edge 10
 EDGE       0,       6,     4,     3,         29    ; Edge 11
 EDGE       1,       7,     3,     2,         30    ; Edge 12
 EDGE       2,       6,     7,     6,         20    ; Edge 13
 EDGE       3,       7,     8,     7,         20    ; Edge 14
 EDGE       8,      10,     3,     3,         16    ; Edge 15
 EDGE       9,      11,     3,     3,         17    ; Edge 16

.SHIP_GECKO_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       31,        5,         31    ; Face 0
 FACE        4,       45,        8,         31    ; Face 1
 FACE       25,     -108,       19,         31    ; Face 2
 FACE        0,      -84,       12,         31    ; Face 3
 FACE      -25,     -108,       19,         31    ; Face 4
 FACE       -4,       45,        8,         31    ; Face 5
 FACE      -88,       16,     -214,         31    ; Face 6
 FACE        0,        0,     -187,         31    ; Face 7
 FACE       88,       16,     -214,         31    ; Face 8

; ******************************************************************************
;
;       Name: SHIP_COBRA_MK_1
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cobra Mk I
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_COBRA_MK_1

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_COBRA_MK_1_EDGES - SHIP_COBRA_MK_1)  ; Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_1_FACES - SHIP_COBRA_MK_1)  ; Faces data offset (low)

 EQUB 73                ; Max. edge count          = (73 - 1) / 4 = 18
 EQUB 40                ; Gun vertex               = 40 / 4 = 10
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 66                ; Number of vertices       = 66 / 6 = 11
 EQUB 18                ; Number of edges          = 18
 EQUW 75                ; Bounty                   = 75
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 19                ; Visibility distance      = 19
 EQUB 90                ; Max. energy              = 90
 EQUB 26                ; Max. speed               = 26

 EQUB HI(SHIP_COBRA_MK_1_EDGES - SHIP_COBRA_MK_1)  ; Edges data offset (high)
 EQUB HI(SHIP_COBRA_MK_1_FACES - SHIP_COBRA_MK_1)  ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_COBRA_MK_1_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,   -1,   50,     1,      0,    3,     2,         31    ; Vertex 0
 VERTEX   18,   -1,   50,     1,      0,    5,     4,         31    ; Vertex 1
 VERTEX  -66,    0,    7,     3,      2,    8,     8,         31    ; Vertex 2
 VERTEX   66,    0,    7,     5,      4,    9,     9,         31    ; Vertex 3
 VERTEX  -32,   12,  -38,     6,      2,    8,     7,         31    ; Vertex 4
 VERTEX   32,   12,  -38,     6,      4,    9,     7,         31    ; Vertex 5
 VERTEX  -54,  -12,  -38,     3,      1,    8,     7,         31    ; Vertex 6
 VERTEX   54,  -12,  -38,     5,      1,    9,     7,         31    ; Vertex 7
 VERTEX    0,   12,   -6,     2,      0,    6,     4,         20    ; Vertex 8
 VERTEX    0,   -1,   50,     1,      0,    1,     1,          2    ; Vertex 9
 VERTEX    0,   -1,   60,     1,      0,    1,     1,         31    ; Vertex 10

.SHIP_COBRA_MK_1_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       1,       0,     1,     0,         31    ; Edge 0
 EDGE       0,       2,     3,     2,         31    ; Edge 1
 EDGE       2,       6,     8,     3,         31    ; Edge 2
 EDGE       6,       7,     7,     1,         31    ; Edge 3
 EDGE       7,       3,     9,     5,         31    ; Edge 4
 EDGE       3,       1,     5,     4,         31    ; Edge 5
 EDGE       2,       4,     8,     2,         31    ; Edge 6
 EDGE       4,       5,     7,     6,         31    ; Edge 7
 EDGE       5,       3,     9,     4,         31    ; Edge 8
 EDGE       0,       8,     2,     0,         20    ; Edge 9
 EDGE       8,       1,     4,     0,         20    ; Edge 10
 EDGE       4,       8,     6,     2,         16    ; Edge 11
 EDGE       8,       5,     6,     4,         16    ; Edge 12
 EDGE       4,       6,     8,     7,         31    ; Edge 13
 EDGE       5,       7,     9,     7,         31    ; Edge 14
 EDGE       0,       6,     3,     1,         20    ; Edge 15
 EDGE       1,       7,     5,     1,         20    ; Edge 16
 EDGE      10,       9,     1,     0,          2    ; Edge 17

.SHIP_COBRA_MK_1_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       41,       10,         31    ; Face 0
 FACE        0,      -27,        3,         31    ; Face 1
 FACE       -8,       46,        8,         31    ; Face 2
 FACE      -12,      -57,       12,         31    ; Face 3
 FACE        8,       46,        8,         31    ; Face 4
 FACE       12,      -57,       12,         31    ; Face 5
 FACE        0,       49,        0,         31    ; Face 6
 FACE        0,        0,     -154,         31    ; Face 7
 FACE     -121,      111,      -62,         31    ; Face 8
 FACE      121,      111,      -62,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_WORM
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Worm
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_WORM

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_WORM_EDGES - SHIP_WORM)              ; Edges data offset (low)
 EQUB LO(SHIP_WORM_FACES - SHIP_WORM)              ; Faces data offset (low)

 EQUB 77                ; Max. edge count          = (77 - 1) / 4 = 19
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 16                ; Number of edges          = 16
 EQUW 0                 ; Bounty                   = 0
 EQUB 32                ; Number of faces          = 32 / 4 = 8
 EQUB 19                ; Visibility distance      = 19
 EQUB 30                ; Max. energy              = 30
 EQUB 23                ; Max. speed               = 23

 EQUB HI(SHIP_WORM_EDGES - SHIP_WORM)              ; Edges data offset (high)
 EQUB HI(SHIP_WORM_FACES - SHIP_WORM)              ; Faces data offset (high)

 EQUB 3                 ; Normals are scaled by    = 2^3 = 8
 EQUB %00001000         ; Laser power              = 1
                        ; Missiles                 = 0

.SHIP_WORM_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   10,  -10,   35,     2,      0,    7,     7,         31    ; Vertex 0
 VERTEX  -10,  -10,   35,     3,      0,    7,     7,         31    ; Vertex 1
 VERTEX    5,    6,   15,     1,      0,    4,     2,         31    ; Vertex 2
 VERTEX   -5,    6,   15,     1,      0,    5,     3,         31    ; Vertex 3
 VERTEX   15,  -10,   25,     4,      2,    7,     7,         31    ; Vertex 4
 VERTEX  -15,  -10,   25,     5,      3,    7,     7,         31    ; Vertex 5
 VERTEX   26,  -10,  -25,     6,      4,    7,     7,         31    ; Vertex 6
 VERTEX  -26,  -10,  -25,     6,      5,    7,     7,         31    ; Vertex 7
 VERTEX    8,   14,  -25,     4,      1,    6,     6,         31    ; Vertex 8
 VERTEX   -8,   14,  -25,     5,      1,    6,     6,         31    ; Vertex 9

.SHIP_WORM_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    ; Edge 0
 EDGE       1,       5,     7,     3,         31    ; Edge 1
 EDGE       5,       7,     7,     5,         31    ; Edge 2
 EDGE       7,       6,     7,     6,         31    ; Edge 3
 EDGE       6,       4,     7,     4,         31    ; Edge 4
 EDGE       4,       0,     7,     2,         31    ; Edge 5
 EDGE       0,       2,     2,     0,         31    ; Edge 6
 EDGE       1,       3,     3,     0,         31    ; Edge 7
 EDGE       4,       2,     4,     2,         31    ; Edge 8
 EDGE       5,       3,     5,     3,         31    ; Edge 9
 EDGE       2,       8,     4,     1,         31    ; Edge 10
 EDGE       8,       6,     6,     4,         31    ; Edge 11
 EDGE       3,       9,     5,     1,         31    ; Edge 12
 EDGE       9,       7,     6,     5,         31    ; Edge 13
 EDGE       2,       3,     1,     0,         31    ; Edge 14
 EDGE       8,       9,     6,     1,         31    ; Edge 15

.SHIP_WORM_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       88,       70,         31    ; Face 0
 FACE        0,       69,       14,         31    ; Face 1
 FACE       70,       66,       35,         31    ; Face 2
 FACE      -70,       66,       35,         31    ; Face 3
 FACE       64,       49,       14,         31    ; Face 4
 FACE      -64,       49,       14,         31    ; Face 5
 FACE        0,        0,     -200,         31    ; Face 6
 FACE        0,      -80,        0,         31    ; Face 7

; ******************************************************************************
;
;       Name: SHIP_COBRA_MK_3_P
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cobra Mk III (pirate)
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_COBRA_MK_3_P

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 95 * 95           ; Targetable area          = 95 * 95

 EQUB LO(SHIP_COBRA_MK_3_P_EDGES - SHIP_COBRA_MK_3_P) ; Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_3_P_FACES - SHIP_COBRA_MK_3_P) ; Faces data offset (low)

 EQUB 157               ; Max. edge count          = (157 - 1) / 4 = 39
 EQUB 84                ; Gun vertex               = 84 / 4 = 21
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 168               ; Number of vertices       = 168 / 6 = 28
 EQUB 38                ; Number of edges          = 38
 EQUW 175               ; Bounty                   = 175
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 50                ; Visibility distance      = 50
 EQUB 150               ; Max. energy              = 150
 EQUB 28                ; Max. speed               = 28

 EQUB HI(SHIP_COBRA_MK_3_P_EDGES - SHIP_COBRA_MK_3_P) ; Edges data offset (high)
 EQUB HI(SHIP_COBRA_MK_3_P_FACES - SHIP_COBRA_MK_3_P) ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_COBRA_MK_3_P_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,   26,   24,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX -120,   -3,   -8,     3,      7,   10,    10,         31    ; Vertex 3
 VERTEX  120,   -3,   -8,     4,      8,   12,    12,         31    ; Vertex 4
 VERTEX  -88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX   88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 6
 VERTEX  128,   -8,  -40,     8,      9,   12,    12,         31    ; Vertex 7
 VERTEX -128,   -8,  -40,     7,      9,   10,    10,         31    ; Vertex 8
 VERTEX    0,   26,  -40,     5,      6,    9,     9,         31    ; Vertex 9
 VERTEX  -32,  -24,  -40,     9,     10,   11,    11,         31    ; Vertex 10
 VERTEX   32,  -24,  -40,     9,     11,   12,    12,         31    ; Vertex 11
 VERTEX  -36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 12
 VERTEX   -8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 13
 VERTEX    8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 14
 VERTEX   36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 15
 VERTEX   36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 16
 VERTEX    8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 17
 VERTEX   -8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 18
 VERTEX  -36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 19
 VERTEX    0,    0,   76,     0,     11,   11,    11,          6    ; Vertex 20
 VERTEX    0,    0,   90,     0,     11,   11,    11,         31    ; Vertex 21
 VERTEX  -80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 22
 VERTEX  -80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 23
 VERTEX  -88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 24
 VERTEX   80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 25
 VERTEX   88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 26
 VERTEX   80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 27

.SHIP_COBRA_MK_3_P_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,    11,         31    ; Edge 0
 EDGE       0,       4,     4,    12,         31    ; Edge 1
 EDGE       1,       3,     3,    10,         31    ; Edge 2
 EDGE       3,       8,     7,    10,         31    ; Edge 3
 EDGE       4,       7,     8,    12,         31    ; Edge 4
 EDGE       6,       7,     8,     9,         31    ; Edge 5
 EDGE       6,       9,     6,     9,         31    ; Edge 6
 EDGE       5,       9,     5,     9,         31    ; Edge 7
 EDGE       5,       8,     7,     9,         31    ; Edge 8
 EDGE       2,       5,     1,     5,         31    ; Edge 9
 EDGE       2,       6,     2,     6,         31    ; Edge 10
 EDGE       3,       5,     3,     7,         31    ; Edge 11
 EDGE       4,       6,     4,     8,         31    ; Edge 12
 EDGE       1,       2,     0,     1,         31    ; Edge 13
 EDGE       0,       2,     0,     2,         31    ; Edge 14
 EDGE       8,      10,     9,    10,         31    ; Edge 15
 EDGE      10,      11,     9,    11,         31    ; Edge 16
 EDGE       7,      11,     9,    12,         31    ; Edge 17
 EDGE       1,      10,    10,    11,         31    ; Edge 18
 EDGE       0,      11,    11,    12,         31    ; Edge 19
 EDGE       1,       5,     1,     3,         29    ; Edge 20
 EDGE       0,       6,     2,     4,         29    ; Edge 21
 EDGE      20,      21,     0,    11,          6    ; Edge 22
 EDGE      12,      13,     9,     9,         20    ; Edge 23
 EDGE      18,      19,     9,     9,         20    ; Edge 24
 EDGE      14,      15,     9,     9,         20    ; Edge 25
 EDGE      16,      17,     9,     9,         20    ; Edge 26
 EDGE      15,      16,     9,     9,         19    ; Edge 27
 EDGE      14,      17,     9,     9,         17    ; Edge 28
 EDGE      13,      18,     9,     9,         19    ; Edge 29
 EDGE      12,      19,     9,     9,         19    ; Edge 30
 EDGE       2,       9,     5,     6,         30    ; Edge 31
 EDGE      22,      24,     9,     9,          6    ; Edge 32
 EDGE      23,      24,     9,     9,          6    ; Edge 33
 EDGE      22,      23,     9,     9,          8    ; Edge 34
 EDGE      25,      26,     9,     9,          6    ; Edge 35
 EDGE      26,      27,     9,     9,          6    ; Edge 36
 EDGE      25,      27,     9,     9,          8    ; Edge 37

.SHIP_COBRA_MK_3_P_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       62,       31,         31    ; Face 0
 FACE      -18,       55,       16,         31    ; Face 1
 FACE       18,       55,       16,         31    ; Face 2
 FACE      -16,       52,       14,         31    ; Face 3
 FACE       16,       52,       14,         31    ; Face 4
 FACE      -14,       47,        0,         31    ; Face 5
 FACE       14,       47,        0,         31    ; Face 6
 FACE      -61,      102,        0,         31    ; Face 7
 FACE       61,      102,        0,         31    ; Face 8
 FACE        0,        0,      -80,         31    ; Face 9
 FACE       -7,      -42,        9,         31    ; Face 10
 FACE        0,      -30,        6,         31    ; Face 11
 FACE        7,      -42,        9,         31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_ASP_MK_2
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an Asp Mk II
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ASP_MK_2

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 60 * 60           ; Targetable area          = 60 * 60

 EQUB LO(SHIP_ASP_MK_2_EDGES - SHIP_ASP_MK_2)      ; Edges data offset (low)
 EQUB LO(SHIP_ASP_MK_2_FACES - SHIP_ASP_MK_2)      ; Faces data offset (low)

 EQUB 105               ; Max. edge count          = (105 - 1) / 4 = 26
 EQUB 32                ; Gun vertex               = 32 / 4 = 8
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 28                ; Number of edges          = 28
 EQUW 200               ; Bounty                   = 200
 EQUB 48                ; Number of faces          = 48 / 4 = 12
 EQUB 40                ; Visibility distance      = 40
 EQUB 150               ; Max. energy              = 150
 EQUB 40                ; Max. speed               = 40

 EQUB HI(SHIP_ASP_MK_2_EDGES - SHIP_ASP_MK_2)      ; Edges data offset (high)
 EQUB HI(SHIP_ASP_MK_2_FACES - SHIP_ASP_MK_2)      ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00101001         ; Laser power              = 5
                        ; Missiles                 = 1

.SHIP_ASP_MK_2_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -18,    0,     1,      0,    2,     2,         22    ; Vertex 0
 VERTEX    0,   -9,  -45,     2,      1,   11,    11,         31    ; Vertex 1
 VERTEX   43,    0,  -45,     6,      1,   11,    11,         31    ; Vertex 2
 VERTEX   69,   -3,    0,     6,      1,    9,     7,         31    ; Vertex 3
 VERTEX   43,  -14,   28,     1,      0,    7,     7,         31    ; Vertex 4
 VERTEX  -43,    0,  -45,     5,      2,   11,    11,         31    ; Vertex 5
 VERTEX  -69,   -3,    0,     5,      2,   10,     8,         31    ; Vertex 6
 VERTEX  -43,  -14,   28,     2,      0,    8,     8,         31    ; Vertex 7
 VERTEX   26,   -7,   73,     4,      0,    9,     7,         31    ; Vertex 8
 VERTEX  -26,   -7,   73,     4,      0,   10,     8,         31    ; Vertex 9
 VERTEX   43,   14,   28,     4,      3,    9,     6,         31    ; Vertex 10
 VERTEX  -43,   14,   28,     4,      3,   10,     5,         31    ; Vertex 11
 VERTEX    0,    9,  -45,     5,      3,   11,     6,         31    ; Vertex 12
 VERTEX  -17,    0,  -45,    11,     11,   11,    11,         10    ; Vertex 13
 VERTEX   17,    0,  -45,    11,     11,   11,    11,          9    ; Vertex 14
 VERTEX    0,   -4,  -45,    11,     11,   11,    11,         10    ; Vertex 15
 VERTEX    0,    4,  -45,    11,     11,   11,    11,          8    ; Vertex 16
 VERTEX    0,   -7,   73,     4,      0,    4,     0,         10    ; Vertex 17
 VERTEX    0,   -7,   83,     4,      0,    4,     0,         10    ; Vertex 18

.SHIP_ASP_MK_2_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     1,         22    ; Edge 0
 EDGE       0,       4,     1,     0,         22    ; Edge 1
 EDGE       0,       7,     2,     0,         22    ; Edge 2
 EDGE       1,       2,    11,     1,         31    ; Edge 3
 EDGE       2,       3,     6,     1,         31    ; Edge 4
 EDGE       3,       8,     9,     7,         16    ; Edge 5
 EDGE       8,       9,     4,     0,         31    ; Edge 6
 EDGE       6,       9,    10,     8,         16    ; Edge 7
 EDGE       5,       6,     5,     2,         31    ; Edge 8
 EDGE       1,       5,    11,     2,         31    ; Edge 9
 EDGE       3,       4,     7,     1,         31    ; Edge 10
 EDGE       4,       8,     7,     0,         31    ; Edge 11
 EDGE       6,       7,     8,     2,         31    ; Edge 12
 EDGE       7,       9,     8,     0,         31    ; Edge 13
 EDGE       2,      12,    11,     6,         31    ; Edge 14
 EDGE       5,      12,    11,     5,         31    ; Edge 15
 EDGE      10,      12,     6,     3,         22    ; Edge 16
 EDGE      11,      12,     5,     3,         22    ; Edge 17
 EDGE      10,      11,     4,     3,         22    ; Edge 18
 EDGE       6,      11,    10,     5,         31    ; Edge 19
 EDGE       9,      11,    10,     4,         31    ; Edge 20
 EDGE       3,      10,     9,     6,         31    ; Edge 21
 EDGE       8,      10,     9,     4,         31    ; Edge 22
 EDGE      13,      15,    11,    11,         10    ; Edge 23
 EDGE      15,      14,    11,    11,          9    ; Edge 24
 EDGE      14,      16,    11,    11,          8    ; Edge 25
 EDGE      16,      13,    11,    11,          8    ; Edge 26
 EDGE      18,      17,     4,     0,         10    ; Edge 27

.SHIP_ASP_MK_2_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,      -35,        5,         31    ; Face 0
 FACE        8,      -38,       -7,         31    ; Face 1
 FACE       -8,      -38,       -7,         31    ; Face 2
 FACE        0,       24,       -1,         22    ; Face 3
 FACE        0,       43,       19,         31    ; Face 4
 FACE       -6,       28,       -2,         31    ; Face 5
 FACE        6,       28,       -2,         31    ; Face 6
 FACE       59,      -64,       31,         31    ; Face 7
 FACE      -59,      -64,       31,         31    ; Face 8
 FACE       80,       46,       50,         31    ; Face 9
 FACE      -80,       46,       50,         31    ; Face 10
 FACE        0,        0,      -90,         31    ; Face 11

 EQUB $59, $3A          ; These bytes appear to be unused
 EQUB $43, $4D

; ******************************************************************************
;
;       Name: SHIP_PYTHON_P
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Python (pirate)
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_PYTHON_P

 EQUB 2                 ; Max. canisters on demise = 2
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_PYTHON_P_EDGES - SHIP_PYTHON_P)      ; Edges data offset (low)
 EQUB LO(SHIP_PYTHON_P_FACES - SHIP_PYTHON_P)      ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 66                ; Number of vertices       = 66 / 6 = 11
 EQUB 26                ; Number of edges          = 26
 EQUW 200               ; Bounty                   = 200
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 40                ; Visibility distance      = 40
 EQUB 250               ; Max. energy              = 250
 EQUB 20                ; Max. speed               = 20

 EQUB HI(SHIP_PYTHON_P_EDGES - SHIP_PYTHON_P)      ; Edges data offset (high)
 EQUB HI(SHIP_PYTHON_P_FACES - SHIP_PYTHON_P)      ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00011011         ; Laser power              = 3
                        ; Missiles                 = 3

.SHIP_PYTHON_P_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,  224,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX    0,   48,   48,     0,      1,    4,     5,         31    ; Vertex 1
 VERTEX   96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX  -96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX    0,   48,  -32,     4,      5,    8,     9,         31    ; Vertex 4
 VERTEX    0,   24, -112,     9,      8,   12,    12,         31    ; Vertex 5
 VERTEX  -48,    0, -112,     8,     11,   12,    12,         31    ; Vertex 6
 VERTEX   48,    0, -112,     9,     10,   12,    12,         31    ; Vertex 7
 VERTEX    0,  -48,   48,     2,      3,    6,     7,         31    ; Vertex 8
 VERTEX    0,  -48,  -32,     6,      7,   10,    11,         31    ; Vertex 9
 VERTEX    0,  -24, -112,    10,     11,   12,    12,         31    ; Vertex 10

.SHIP_PYTHON_P_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       8,     2,     3,         31    ; Edge 0
 EDGE       0,       3,     0,     2,         31    ; Edge 1
 EDGE       0,       2,     1,     3,         31    ; Edge 2
 EDGE       0,       1,     0,     1,         31    ; Edge 3
 EDGE       2,       4,     9,     5,         31    ; Edge 4
 EDGE       1,       2,     1,     5,         31    ; Edge 5
 EDGE       2,       8,     7,     3,         31    ; Edge 6
 EDGE       1,       3,     0,     4,         31    ; Edge 7
 EDGE       3,       8,     2,     6,         31    ; Edge 8
 EDGE       2,       9,     7,    10,         31    ; Edge 9
 EDGE       3,       4,     4,     8,         31    ; Edge 10
 EDGE       3,       9,     6,    11,         31    ; Edge 11
 EDGE       3,       5,     8,     8,          7    ; Edge 12
 EDGE       3,      10,    11,    11,          7    ; Edge 13
 EDGE       2,       5,     9,     9,          7    ; Edge 14
 EDGE       2,      10,    10,    10,          7    ; Edge 15
 EDGE       2,       7,     9,    10,         31    ; Edge 16
 EDGE       3,       6,     8,    11,         31    ; Edge 17
 EDGE       5,       6,     8,    12,         31    ; Edge 18
 EDGE       5,       7,     9,    12,         31    ; Edge 19
 EDGE       7,      10,    12,    10,         31    ; Edge 20
 EDGE       6,      10,    11,    12,         31    ; Edge 21
 EDGE       4,       5,     8,     9,         31    ; Edge 22
 EDGE       9,      10,    10,    11,         31    ; Edge 23
 EDGE       1,       4,     4,     5,         31    ; Edge 24
 EDGE       8,       9,     6,     7,         31    ; Edge 25

.SHIP_PYTHON_P_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -27,       40,       11,         31    ; Face 0
 FACE       27,       40,       11,         31    ; Face 1
 FACE      -27,      -40,       11,         31    ; Face 2
 FACE       27,      -40,       11,         31    ; Face 3
 FACE      -19,       38,        0,         31    ; Face 4
 FACE       19,       38,        0,         31    ; Face 5
 FACE      -19,      -38,        0,         31    ; Face 6
 FACE       19,      -38,        0,         31    ; Face 7
 FACE      -25,       37,      -11,         31    ; Face 8
 FACE       25,       37,      -11,         31    ; Face 9
 FACE       25,      -37,      -11,         31    ; Face 10
 FACE      -25,      -37,      -11,         31    ; Face 11
 FACE        0,        0,     -112,         31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_FER_DE_LANCE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Fer-de-Lance
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_FER_DE_LANCE

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 40 * 40           ; Targetable area          = 40 * 40

 EQUB LO(SHIP_FER_DE_LANCE_EDGES - SHIP_FER_DE_LANCE) ; Edges data offset (low)
 EQUB LO(SHIP_FER_DE_LANCE_FACES - SHIP_FER_DE_LANCE) ; Faces data offset (low)

 EQUB 109               ; Max. edge count          = (109 - 1) / 4 = 27
 EQUB 0                 ; Gun vertex               = 0
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 27                ; Number of edges          = 27
 EQUW 0                 ; Bounty                   = 0
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 40                ; Visibility distance      = 40
 EQUB 160               ; Max. energy              = 160
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_FER_DE_LANCE_EDGES - SHIP_FER_DE_LANCE) ; Edges data offset (high)
 EQUB HI(SHIP_FER_DE_LANCE_FACES - SHIP_FER_DE_LANCE) ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_FER_DE_LANCE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -14,  108,     1,      0,    9,     5,         31    ; Vertex 0
 VERTEX  -40,  -14,   -4,     2,      1,    9,     9,         31    ; Vertex 1
 VERTEX  -12,  -14,  -52,     3,      2,    9,     9,         31    ; Vertex 2
 VERTEX   12,  -14,  -52,     4,      3,    9,     9,         31    ; Vertex 3
 VERTEX   40,  -14,   -4,     5,      4,    9,     9,         31    ; Vertex 4
 VERTEX  -40,   14,   -4,     1,      0,    6,     2,         28    ; Vertex 5
 VERTEX  -12,    2,  -52,     3,      2,    7,     6,         28    ; Vertex 6
 VERTEX   12,    2,  -52,     4,      3,    8,     7,         28    ; Vertex 7
 VERTEX   40,   14,   -4,     4,      0,    8,     5,         28    ; Vertex 8
 VERTEX    0,   18,  -20,     6,      0,    8,     7,         15    ; Vertex 9
 VERTEX   -3,  -11,   97,     0,      0,    0,     0,         11    ; Vertex 10
 VERTEX  -26,    8,   18,     0,      0,    0,     0,          9    ; Vertex 11
 VERTEX  -16,   14,   -4,     0,      0,    0,     0,         11    ; Vertex 12
 VERTEX    3,  -11,   97,     0,      0,    0,     0,         11    ; Vertex 13
 VERTEX   26,    8,   18,     0,      0,    0,     0,          9    ; Vertex 14
 VERTEX   16,   14,   -4,     0,      0,    0,     0,         11    ; Vertex 15
 VERTEX    0,  -14,  -20,     9,      9,    9,     9,         12    ; Vertex 16
 VERTEX  -14,  -14,   44,     9,      9,    9,     9,         12    ; Vertex 17
 VERTEX   14,  -14,   44,     9,      9,    9,     9,         12    ; Vertex 18

.SHIP_FER_DE_LANCE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     9,     1,         31    ; Edge 0
 EDGE       1,       2,     9,     2,         31    ; Edge 1
 EDGE       2,       3,     9,     3,         31    ; Edge 2
 EDGE       3,       4,     9,     4,         31    ; Edge 3
 EDGE       0,       4,     9,     5,         31    ; Edge 4
 EDGE       0,       5,     1,     0,         28    ; Edge 5
 EDGE       5,       6,     6,     2,         28    ; Edge 6
 EDGE       6,       7,     7,     3,         28    ; Edge 7
 EDGE       7,       8,     8,     4,         28    ; Edge 8
 EDGE       0,       8,     5,     0,         28    ; Edge 9
 EDGE       5,       9,     6,     0,         15    ; Edge 10
 EDGE       6,       9,     7,     6,         11    ; Edge 11
 EDGE       7,       9,     8,     7,         11    ; Edge 12
 EDGE       8,       9,     8,     0,         15    ; Edge 13
 EDGE       1,       5,     2,     1,         14    ; Edge 14
 EDGE       2,       6,     3,     2,         14    ; Edge 15
 EDGE       3,       7,     4,     3,         14    ; Edge 16
 EDGE       4,       8,     5,     4,         14    ; Edge 17
 EDGE      10,      11,     0,     0,          8    ; Edge 18
 EDGE      11,      12,     0,     0,          9    ; Edge 19
 EDGE      10,      12,     0,     0,         11    ; Edge 20
 EDGE      13,      14,     0,     0,          8    ; Edge 21
 EDGE      14,      15,     0,     0,          9    ; Edge 22
 EDGE      13,      15,     0,     0,         11    ; Edge 23
 EDGE      16,      17,     9,     9,         12    ; Edge 24
 EDGE      16,      18,     9,     9,         12    ; Edge 25
 EDGE      17,      18,     9,     9,          8    ; Edge 26

.SHIP_FER_DE_LANCE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       24,        6,         28    ; Face 0
 FACE      -68,        0,       24,         31    ; Face 1
 FACE      -63,        0,      -37,         31    ; Face 2
 FACE        0,        0,     -104,         31    ; Face 3
 FACE       63,        0,      -37,         31    ; Face 4
 FACE       68,        0,       24,         31    ; Face 5
 FACE      -12,       46,      -19,         28    ; Face 6
 FACE        0,       45,      -22,         28    ; Face 7
 FACE       12,       46,      -19,         28    ; Face 8
 FACE        0,      -28,        0,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_MORAY
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Moray
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_MORAY

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 30 * 30           ; Targetable area          = 30 * 30

 EQUB LO(SHIP_MORAY_EDGES - SHIP_MORAY)            ; Edges data offset (low)
 EQUB LO(SHIP_MORAY_FACES - SHIP_MORAY)            ; Faces data offset (low)

 EQUB 73                ; Max. edge count          = (73 - 1) / 4 = 18
 EQUB 0                 ; Gun vertex               = 0
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 84                ; Number of vertices       = 84 / 6 = 14
 EQUB 19                ; Number of edges          = 19
 EQUW 50                ; Bounty                   = 50
 EQUB 36                ; Number of faces          = 36 / 4 = 9
 EQUB 40                ; Visibility distance      = 40
 EQUB 100               ; Max. energy              = 100
 EQUB 25                ; Max. speed               = 25

 EQUB HI(SHIP_MORAY_EDGES - SHIP_MORAY)            ; Edges data offset (high)
 EQUB HI(SHIP_MORAY_FACES - SHIP_MORAY)            ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_MORAY_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   15,    0,   65,     2,      0,    8,     7,         31    ; Vertex 0
 VERTEX  -15,    0,   65,     1,      0,    7,     6,         31    ; Vertex 1
 VERTEX    0,   18,  -40,    15,     15,   15,    15,         17    ; Vertex 2
 VERTEX  -60,    0,    0,     3,      1,    6,     6,         31    ; Vertex 3
 VERTEX   60,    0,    0,     5,      2,    8,     8,         31    ; Vertex 4
 VERTEX   30,  -27,  -10,     5,      4,    8,     7,         24    ; Vertex 5
 VERTEX  -30,  -27,  -10,     4,      3,    7,     6,         24    ; Vertex 6
 VERTEX   -9,   -4,  -25,     4,      4,    4,     4,          7    ; Vertex 7
 VERTEX    9,   -4,  -25,     4,      4,    4,     4,          7    ; Vertex 8
 VERTEX    0,  -18,  -16,     4,      4,    4,     4,          7    ; Vertex 9
 VERTEX   13,    3,   49,     0,      0,    0,     0,          5    ; Vertex 10
 VERTEX    6,    0,   65,     0,      0,    0,     0,          5    ; Vertex 11
 VERTEX  -13,    3,   49,     0,      0,    0,     0,          5    ; Vertex 12
 VERTEX   -6,    0,   65,     0,      0,    0,     0,          5    ; Vertex 13

.SHIP_MORAY_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    ; Edge 0
 EDGE       1,       3,     6,     1,         31    ; Edge 1
 EDGE       3,       6,     6,     3,         24    ; Edge 2
 EDGE       5,       6,     7,     4,         24    ; Edge 3
 EDGE       4,       5,     8,     5,         24    ; Edge 4
 EDGE       0,       4,     8,     2,         31    ; Edge 5
 EDGE       1,       6,     7,     6,         15    ; Edge 6
 EDGE       0,       5,     8,     7,         15    ; Edge 7
 EDGE       0,       2,     2,     0,         15    ; Edge 8
 EDGE       1,       2,     1,     0,         15    ; Edge 9
 EDGE       2,       3,     3,     1,         17    ; Edge 10
 EDGE       2,       4,     5,     2,         17    ; Edge 11
 EDGE       2,       5,     5,     4,         13    ; Edge 12
 EDGE       2,       6,     4,     3,         13    ; Edge 13
 EDGE       7,       8,     4,     4,          5    ; Edge 14
 EDGE       7,       9,     4,     4,          7    ; Edge 15
 EDGE       8,       9,     4,     4,          7    ; Edge 16
 EDGE      10,      11,     0,     0,          5    ; Edge 17
 EDGE      12,      13,     0,     0,          5    ; Edge 18

.SHIP_MORAY_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       43,        7,         31    ; Face 0
 FACE      -10,       49,        7,         31    ; Face 1
 FACE       10,       49,        7,         31    ; Face 2
 FACE      -59,      -28,     -101,         24    ; Face 3
 FACE        0,      -52,      -78,         24    ; Face 4
 FACE       59,      -28,     -101,         24    ; Face 5
 FACE      -72,      -99,       50,         31    ; Face 6
 FACE        0,      -83,       30,         31    ; Face 7
 FACE       72,      -99,       50,         31    ; Face 8

; ******************************************************************************
;
;       Name: SHIP_THARGOID
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Thargoid mothership
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_THARGOID

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_THARGOID_EDGES - SHIP_THARGOID)      ; Edges data offset (low)
 EQUB LO(SHIP_THARGOID_FACES - SHIP_THARGOID)      ; Faces data offset (low)

 EQUB 105               ; Max. edge count          = (105 - 1) / 4 = 26
 EQUB 60                ; Gun vertex               = 60 / 4 = 15
 EQUB 38                ; Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 120               ; Number of vertices       = 120 / 6 = 20
 EQUB 26                ; Number of edges          = 26
 EQUW 500               ; Bounty                   = 500
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 55                ; Visibility distance      = 55
 EQUB 240               ; Max. energy              = 240
 EQUB 39                ; Max. speed               = 39

 EQUB HI(SHIP_THARGOID_EDGES - SHIP_THARGOID)      ; Edges data offset (high)
 EQUB HI(SHIP_THARGOID_FACES - SHIP_THARGOID)      ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010110         ; Laser power              = 2
                        ; Missiles                 = 6

.SHIP_THARGOID_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,  -48,   48,     0,      4,    8,     8,         31    ; Vertex 0
 VERTEX   32,  -68,    0,     0,      1,    4,     4,         31    ; Vertex 1
 VERTEX   32,  -48,  -48,     1,      2,    4,     4,         31    ; Vertex 2
 VERTEX   32,    0,  -68,     2,      3,    4,     4,         31    ; Vertex 3
 VERTEX   32,   48,  -48,     3,      4,    5,     5,         31    ; Vertex 4
 VERTEX   32,   68,    0,     4,      5,    6,     6,         31    ; Vertex 5
 VERTEX   32,   48,   48,     4,      6,    7,     7,         31    ; Vertex 6
 VERTEX   32,    0,   68,     4,      7,    8,     8,         31    ; Vertex 7
 VERTEX  -24, -116,  116,     0,      8,    9,     9,         31    ; Vertex 8
 VERTEX  -24, -164,    0,     0,      1,    9,     9,         31    ; Vertex 9
 VERTEX  -24, -116, -116,     1,      2,    9,     9,         31    ; Vertex 10
 VERTEX  -24,    0, -164,     2,      3,    9,     9,         31    ; Vertex 11
 VERTEX  -24,  116, -116,     3,      5,    9,     9,         31    ; Vertex 12
 VERTEX  -24,  164,    0,     5,      6,    9,     9,         31    ; Vertex 13
 VERTEX  -24,  116,  116,     6,      7,    9,     9,         31    ; Vertex 14
 VERTEX  -24,    0,  164,     7,      8,    9,     9,         31    ; Vertex 15
 VERTEX  -24,   64,   80,     9,      9,    9,     9,         30    ; Vertex 16
 VERTEX  -24,   64,  -80,     9,      9,    9,     9,         30    ; Vertex 17
 VERTEX  -24,  -64,  -80,     9,      9,    9,     9,         30    ; Vertex 18
 VERTEX  -24,  -64,   80,     9,      9,    9,     9,         30    ; Vertex 19

.SHIP_THARGOID_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       7,     4,     8,         31    ; Edge 0
 EDGE       0,       1,     0,     4,         31    ; Edge 1
 EDGE       1,       2,     1,     4,         31    ; Edge 2
 EDGE       2,       3,     2,     4,         31    ; Edge 3
 EDGE       3,       4,     3,     4,         31    ; Edge 4
 EDGE       4,       5,     4,     5,         31    ; Edge 5
 EDGE       5,       6,     4,     6,         31    ; Edge 6
 EDGE       6,       7,     4,     7,         31    ; Edge 7
 EDGE       0,       8,     0,     8,         31    ; Edge 8
 EDGE       1,       9,     0,     1,         31    ; Edge 9
 EDGE       2,      10,     1,     2,         31    ; Edge 10
 EDGE       3,      11,     2,     3,         31    ; Edge 11
 EDGE       4,      12,     3,     5,         31    ; Edge 12
 EDGE       5,      13,     5,     6,         31    ; Edge 13
 EDGE       6,      14,     6,     7,         31    ; Edge 14
 EDGE       7,      15,     7,     8,         31    ; Edge 15
 EDGE       8,      15,     8,     9,         31    ; Edge 16
 EDGE       8,       9,     0,     9,         31    ; Edge 17
 EDGE       9,      10,     1,     9,         31    ; Edge 18
 EDGE      10,      11,     2,     9,         31    ; Edge 19
 EDGE      11,      12,     3,     9,         31    ; Edge 20
 EDGE      12,      13,     5,     9,         31    ; Edge 21
 EDGE      13,      14,     6,     9,         31    ; Edge 22
 EDGE      14,      15,     7,     9,         31    ; Edge 23
 EDGE      16,      17,     9,     9,         30    ; Edge 24
 EDGE      18,      19,     9,     9,         30    ; Edge 25

.SHIP_THARGOID_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      103,      -60,       25,         31    ; Face 0
 FACE      103,      -60,      -25,         31    ; Face 1
 FACE      103,      -25,      -60,         31    ; Face 2
 FACE      103,       25,      -60,         31    ; Face 3
 FACE       64,        0,        0,         31    ; Face 4
 FACE      103,       60,      -25,         31    ; Face 5
 FACE      103,       60,       25,         31    ; Face 6
 FACE      103,       25,       60,         31    ; Face 7
 FACE      103,      -25,       60,         31    ; Face 8
 FACE      -48,        0,        0,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_THARGON
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Thargon
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The ship blueprint for the Thargon reuses the edges data from the cargo
; canister, so the edges data offset is negative.
;
; ******************************************************************************

.SHIP_THARGON

 EQUB 0 + (15 << 4)     ; Max. canisters on demise = 0
                        ; Market item when scooped = 15 + 1 = 16 (alien items)
 EQUW 40 * 40           ; Targetable area          = 40 * 40

 EQUB LO(SHIP_CANISTER_EDGES - SHIP_THARGON)       ; Edges from canister
 EQUB LO(SHIP_THARGON_FACES - SHIP_THARGON)        ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 15                ; Number of edges          = 15
 EQUW 50                ; Bounty                   = 50
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 20                ; Visibility distance      = 20
 EQUB 20                ; Max. energy              = 20
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_CANISTER_EDGES - SHIP_THARGON)       ; Edges from canister
 EQUB HI(SHIP_THARGON_FACES - SHIP_THARGON)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_THARGON_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   -9,    0,   40,     1,      0,    5,     5,         31    ; Vertex 0
 VERTEX   -9,  -38,   12,     1,      0,    2,     2,         31    ; Vertex 1
 VERTEX   -9,  -24,  -32,     2,      0,    3,     3,         31    ; Vertex 2
 VERTEX   -9,   24,  -32,     3,      0,    4,     4,         31    ; Vertex 3
 VERTEX   -9,   38,   12,     4,      0,    5,     5,         31    ; Vertex 4
 VERTEX    9,    0,   -8,     5,      1,    6,     6,         31    ; Vertex 5
 VERTEX    9,  -10,  -15,     2,      1,    6,     6,         31    ; Vertex 6
 VERTEX    9,   -6,  -26,     3,      2,    6,     6,         31    ; Vertex 7
 VERTEX    9,    6,  -26,     4,      3,    6,     6,         31    ; Vertex 8
 VERTEX    9,   10,  -15,     5,      4,    6,     6,         31    ; Vertex 9

.SHIP_THARGON_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -36,        0,        0,         31    ; Face 0
 FACE       20,       -5,        7,         31    ; Face 1
 FACE       46,      -42,      -14,         31    ; Face 2
 FACE       36,        0,     -104,         31    ; Face 3
 FACE       46,       42,      -14,         31    ; Face 4
 FACE       20,        5,        7,         31    ; Face 5
 FACE       36,        0,        0,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_CONSTRICTOR
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Constrictor
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_CONSTRICTOR

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 65 * 65           ; Targetable area          = 65 * 65

 EQUB LO(SHIP_CONSTRICTOR_EDGES - SHIP_CONSTRICTOR)   ; Edges data offset (low)
 EQUB LO(SHIP_CONSTRICTOR_FACES - SHIP_CONSTRICTOR)   ; Faces data offset (low)

 EQUB 81                ; Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 ; Gun vertex               = 0
 EQUB 46                ; Explosion count          = 10, as (4 * n) + 6 = 46
 EQUB 102               ; Number of vertices       = 102 / 6 = 17
 EQUB 24                ; Number of edges          = 24
 EQUW 0                 ; Bounty                   = 0
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 45                ; Visibility distance      = 45
 EQUB 252               ; Max. energy              = 252
 EQUB 36                ; Max. speed               = 36

 EQUB HI(SHIP_CONSTRICTOR_EDGES - SHIP_CONSTRICTOR)   ; Edges data offset (high)
 EQUB HI(SHIP_CONSTRICTOR_FACES - SHIP_CONSTRICTOR)   ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00110100         ; Laser power              = 6
                        ; Missiles                 = 4

.SHIP_CONSTRICTOR_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   20,   -7,   80,     2,      0,    9,     9,         31    ; Vertex 0
 VERTEX  -20,   -7,   80,     1,      0,    9,     9,         31    ; Vertex 1
 VERTEX  -54,   -7,   40,     4,      1,    9,     9,         31    ; Vertex 2
 VERTEX  -54,   -7,  -40,     5,      4,    9,     8,         31    ; Vertex 3
 VERTEX  -20,   13,  -40,     6,      5,    8,     8,         31    ; Vertex 4
 VERTEX   20,   13,  -40,     7,      6,    8,     8,         31    ; Vertex 5
 VERTEX   54,   -7,  -40,     7,      3,    9,     8,         31    ; Vertex 6
 VERTEX   54,   -7,   40,     3,      2,    9,     9,         31    ; Vertex 7
 VERTEX   20,   13,    5,    15,     15,   15,    15,         31    ; Vertex 8
 VERTEX  -20,   13,    5,    15,     15,   15,    15,         31    ; Vertex 9
 VERTEX   20,   -7,   62,     9,      9,    9,     9,         18    ; Vertex 10
 VERTEX  -20,   -7,   62,     9,      9,    9,     9,         18    ; Vertex 11
 VERTEX   25,   -7,  -25,     9,      9,    9,     9,         18    ; Vertex 12
 VERTEX  -25,   -7,  -25,     9,      9,    9,     9,         18    ; Vertex 13
 VERTEX   15,   -7,  -15,     9,      9,    9,     9,         10    ; Vertex 14
 VERTEX  -15,   -7,  -15,     9,      9,    9,     9,         10    ; Vertex 15
 VERTEX    0,   -7,    0,    15,      9,    1,     0,          0    ; Vertex 16

.SHIP_CONSTRICTOR_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     9,     0,         31    ; Edge 0
 EDGE       1,       2,     9,     1,         31    ; Edge 1
 EDGE       1,       9,     1,     0,         31    ; Edge 2
 EDGE       0,       8,     2,     0,         31    ; Edge 3
 EDGE       0,       7,     9,     2,         31    ; Edge 4
 EDGE       7,       8,     3,     2,         31    ; Edge 5
 EDGE       2,       9,     4,     1,         31    ; Edge 6
 EDGE       2,       3,     9,     4,         31    ; Edge 7
 EDGE       6,       7,     9,     3,         31    ; Edge 8
 EDGE       6,       8,     7,     3,         31    ; Edge 9
 EDGE       5,       8,     7,     6,         31    ; Edge 10
 EDGE       4,       9,     6,     5,         31    ; Edge 11
 EDGE       3,       9,     5,     4,         31    ; Edge 12
 EDGE       3,       4,     8,     5,         31    ; Edge 13
 EDGE       4,       5,     8,     6,         31    ; Edge 14
 EDGE       5,       6,     8,     7,         31    ; Edge 15
 EDGE       3,       6,     9,     8,         31    ; Edge 16
 EDGE       8,       9,     6,     0,         31    ; Edge 17
 EDGE      10,      12,     9,     9,         18    ; Edge 18
 EDGE      12,      14,     9,     9,          5    ; Edge 19
 EDGE      14,      10,     9,     9,         10    ; Edge 20
 EDGE      11,      15,     9,     9,         10    ; Edge 21
 EDGE      13,      15,     9,     9,          5    ; Edge 22
 EDGE      11,      13,     9,     9,         18    ; Edge 23

.SHIP_CONSTRICTOR_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       55,       15,         31    ; Face 0
 FACE      -24,       75,       20,         31    ; Face 1
 FACE       24,       75,       20,         31    ; Face 2
 FACE       44,       75,        0,         31    ; Face 3
 FACE      -44,       75,        0,         31    ; Face 4
 FACE      -44,       75,        0,         31    ; Face 5
 FACE        0,       53,        0,         31    ; Face 6
 FACE       44,       75,        0,         31    ; Face 7
 FACE        0,        0,     -160,         31    ; Face 8
 FACE        0,      -27,        0,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_COUGAR
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cougar
;  Deep dive: Ship blueprints
;             The elusive Cougar
;
; ******************************************************************************

.SHIP_COUGAR

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 70 * 70           ; Targetable area          = 70 * 70

 EQUB LO(SHIP_COUGAR_EDGES - SHIP_COUGAR)          ; Edges data offset (low)
 EQUB LO(SHIP_COUGAR_FACES - SHIP_COUGAR)          ; Faces data offset (low)

 EQUB 105               ; Max. edge count          = (105 - 1) / 4 = 26
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 25                ; Number of edges          = 25
 EQUW 0                 ; Bounty                   = 0
 EQUB 24                ; Number of faces          = 24 / 4 = 6
 EQUB 34                ; Visibility distance      = 34
 EQUB 252               ; Max. energy              = 252
 EQUB 40                ; Max. speed               = 40

 EQUB HI(SHIP_COUGAR_EDGES - SHIP_COUGAR)          ; Edges data offset (high)
 EQUB HI(SHIP_COUGAR_FACES - SHIP_COUGAR)          ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00110100         ; Laser power              = 6
                        ; Missiles                 = 4

.SHIP_COUGAR_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    5,   67,     2,      0,    4,     4,         31    ; Vertex 0
 VERTEX  -20,    0,   40,     1,      0,    2,     2,         31    ; Vertex 1
 VERTEX  -40,    0,  -40,     1,      0,    5,     5,         31    ; Vertex 2
 VERTEX    0,   14,  -40,     4,      0,    5,     5,         30    ; Vertex 3
 VERTEX    0,  -14,  -40,     2,      1,    5,     3,         30    ; Vertex 4
 VERTEX   20,    0,   40,     3,      2,    4,     4,         31    ; Vertex 5
 VERTEX   40,    0,  -40,     4,      3,    5,     5,         31    ; Vertex 6
 VERTEX  -36,    0,   56,     1,      0,    1,     1,         31    ; Vertex 7
 VERTEX  -60,    0,  -20,     1,      0,    1,     1,         31    ; Vertex 8
 VERTEX   36,    0,   56,     4,      3,    4,     4,         31    ; Vertex 9
 VERTEX   60,    0,  -20,     4,      3,    4,     4,         31    ; Vertex 10
 VERTEX    0,    7,   35,     0,      0,    4,     4,         18    ; Vertex 11
 VERTEX    0,    8,   25,     0,      0,    4,     4,         20    ; Vertex 12
 VERTEX  -12,    2,   45,     0,      0,    0,     0,         20    ; Vertex 13
 VERTEX   12,    2,   45,     4,      4,    4,     4,         20    ; Vertex 14
 VERTEX  -10,    6,  -40,     5,      5,    5,     5,         20    ; Vertex 15
 VERTEX  -10,   -6,  -40,     5,      5,    5,     5,         20    ; Vertex 16
 VERTEX   10,   -6,  -40,     5,      5,    5,     5,         20    ; Vertex 17
 VERTEX   10,    6,  -40,     5,      5,    5,     5,         20    ; Vertex 18

.SHIP_COUGAR_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     0,         31    ; Edge 0
 EDGE       1,       7,     1,     0,         31    ; Edge 1
 EDGE       7,       8,     1,     0,         31    ; Edge 2
 EDGE       8,       2,     1,     0,         31    ; Edge 3
 EDGE       2,       3,     5,     0,         30    ; Edge 4
 EDGE       3,       6,     5,     4,         30    ; Edge 5
 EDGE       2,       4,     5,     1,         30    ; Edge 6
 EDGE       4,       6,     5,     3,         30    ; Edge 7
 EDGE       6,      10,     4,     3,         31    ; Edge 8
 EDGE      10,       9,     4,     3,         31    ; Edge 9
 EDGE       9,       5,     4,     3,         31    ; Edge 10
 EDGE       5,       0,     4,     2,         31    ; Edge 11
 EDGE       0,       3,     4,     0,         27    ; Edge 12
 EDGE       1,       4,     2,     1,         27    ; Edge 13
 EDGE       5,       4,     3,     2,         27    ; Edge 14
 EDGE       1,       2,     1,     0,         26    ; Edge 15
 EDGE       5,       6,     4,     3,         26    ; Edge 16
 EDGE      12,      13,     0,     0,         20    ; Edge 17
 EDGE      13,      11,     0,     0,         18    ; Edge 18
 EDGE      11,      14,     4,     4,         18    ; Edge 19
 EDGE      14,      12,     4,     4,         20    ; Edge 20
 EDGE      15,      16,     5,     5,         18    ; Edge 21
 EDGE      16,      18,     5,     5,         20    ; Edge 22
 EDGE      18,      17,     5,     5,         18    ; Edge 23
 EDGE      17,      15,     5,     5,         20    ; Edge 24

.SHIP_COUGAR_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -16,       46,        4,         31    ; Face 0
 FACE      -16,      -46,        4,         31    ; Face 1
 FACE        0,      -27,        5,         31    ; Face 2
 FACE       16,      -46,        4,         31    ; Face 3
 FACE       16,       46,        4,         31    ; Face 4
 FACE        0,        0,     -160,         30    ; Face 5

; ******************************************************************************
;
;       Name: SHIP_DODO
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Dodecahedron ("Dodo") space station
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_DODO

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 180 * 180         ; Targetable area          = 180 * 180

 EQUB LO(SHIP_DODO_EDGES - SHIP_DODO)              ; Edges data offset (low)
 EQUB LO(SHIP_DODO_FACES - SHIP_DODO)              ; Faces data offset (low)

 EQUB 101               ; Max. edge count          = (101 - 1) / 4 = 25
 EQUB 0                 ; Gun vertex               = 0
 EQUB 54                ; Explosion count          = 12, as (4 * n) + 6 = 54
 EQUB 144               ; Number of vertices       = 144 / 6 = 24
 EQUB 34                ; Number of edges          = 34
 EQUW 0                 ; Bounty                   = 0
 EQUB 48                ; Number of faces          = 48 / 4 = 12
 EQUB 125               ; Visibility distance      = 125
 EQUB 240               ; Max. energy              = 240
 EQUB 0                 ; Max. speed               = 0

 EQUB HI(SHIP_DODO_EDGES - SHIP_DODO)              ; Edges data offset (high)
 EQUB HI(SHIP_DODO_FACES - SHIP_DODO)              ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_DODO_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  150,  196,     1,      0,    5,     5,         31    ; Vertex 0
 VERTEX  143,   46,  196,     1,      0,    2,     2,         31    ; Vertex 1
 VERTEX   88, -121,  196,     2,      0,    3,     3,         31    ; Vertex 2
 VERTEX  -88, -121,  196,     3,      0,    4,     4,         31    ; Vertex 3
 VERTEX -143,   46,  196,     4,      0,    5,     5,         31    ; Vertex 4
 VERTEX    0,  243,   46,     5,      1,    6,     6,         31    ; Vertex 5
 VERTEX  231,   75,   46,     2,      1,    7,     7,         31    ; Vertex 6
 VERTEX  143, -196,   46,     3,      2,    8,     8,         31    ; Vertex 7
 VERTEX -143, -196,   46,     4,      3,    9,     9,         31    ; Vertex 8
 VERTEX -231,   75,   46,     5,      4,   10,    10,         31    ; Vertex 9
 VERTEX  143,  196,  -46,     6,      1,    7,     7,         31    ; Vertex 10
 VERTEX  231,  -75,  -46,     7,      2,    8,     8,         31    ; Vertex 11
 VERTEX    0, -243,  -46,     8,      3,    9,     9,         31    ; Vertex 12
 VERTEX -231,  -75,  -46,     9,      4,   10,    10,         31    ; Vertex 13
 VERTEX -143,  196,  -46,     6,      5,   10,    10,         31    ; Vertex 14
 VERTEX   88,  121, -196,     7,      6,   11,    11,         31    ; Vertex 15
 VERTEX  143,  -46, -196,     8,      7,   11,    11,         31    ; Vertex 16
 VERTEX    0, -150, -196,     9,      8,   11,    11,         31    ; Vertex 17
 VERTEX -143,  -46, -196,    10,      9,   11,    11,         31    ; Vertex 18
 VERTEX  -88,  121, -196,    10,      6,   11,    11,         31    ; Vertex 19
 VERTEX  -16,   32,  196,     0,      0,    0,     0,         30    ; Vertex 20
 VERTEX  -16,  -32,  196,     0,      0,    0,     0,         30    ; Vertex 21
 VERTEX   16,   32,  196,     0,      0,    0,     0,         23    ; Vertex 22
 VERTEX   16,  -32,  196,     0,      0,    0,     0,         23    ; Vertex 23

.SHIP_DODO_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    ; Edge 0
 EDGE       1,       2,     2,     0,         31    ; Edge 1
 EDGE       2,       3,     3,     0,         31    ; Edge 2
 EDGE       3,       4,     4,     0,         31    ; Edge 3
 EDGE       4,       0,     5,     0,         31    ; Edge 4
 EDGE       5,      10,     6,     1,         31    ; Edge 5
 EDGE      10,       6,     7,     1,         31    ; Edge 6
 EDGE       6,      11,     7,     2,         31    ; Edge 7
 EDGE      11,       7,     8,     2,         31    ; Edge 8
 EDGE       7,      12,     8,     3,         31    ; Edge 9
 EDGE      12,       8,     9,     3,         31    ; Edge 10
 EDGE       8,      13,     9,     4,         31    ; Edge 11
 EDGE      13,       9,    10,     4,         31    ; Edge 12
 EDGE       9,      14,    10,     5,         31    ; Edge 13
 EDGE      14,       5,     6,     5,         31    ; Edge 14
 EDGE      15,      16,    11,     7,         31    ; Edge 15
 EDGE      16,      17,    11,     8,         31    ; Edge 16
 EDGE      17,      18,    11,     9,         31    ; Edge 17
 EDGE      18,      19,    11,    10,         31    ; Edge 18
 EDGE      19,      15,    11,     6,         31    ; Edge 19
 EDGE       0,       5,     5,     1,         31    ; Edge 20
 EDGE       1,       6,     2,     1,         31    ; Edge 21
 EDGE       2,       7,     3,     2,         31    ; Edge 22
 EDGE       3,       8,     4,     3,         31    ; Edge 23
 EDGE       4,       9,     5,     4,         31    ; Edge 24
 EDGE      10,      15,     7,     6,         31    ; Edge 25
 EDGE      11,      16,     8,     7,         31    ; Edge 26
 EDGE      12,      17,     9,     8,         31    ; Edge 27
 EDGE      13,      18,    10,     9,         31    ; Edge 28
 EDGE      14,      19,    10,     6,         31    ; Edge 29
 EDGE      20,      21,     0,     0,         30    ; Edge 30
 EDGE      21,      23,     0,     0,         20    ; Edge 31
 EDGE      23,      22,     0,     0,         23    ; Edge 32
 EDGE      22,      20,     0,     0,         20    ; Edge 33

.SHIP_DODO_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,      196,         31    ; Face 0
 FACE      103,      142,       88,         31    ; Face 1
 FACE      169,      -55,       89,         31    ; Face 2
 FACE        0,     -176,       88,         31    ; Face 3
 FACE     -169,      -55,       89,         31    ; Face 4
 FACE     -103,      142,       88,         31    ; Face 5
 FACE        0,      176,      -88,         31    ; Face 6
 FACE      169,       55,      -89,         31    ; Face 7
 FACE      103,     -142,      -88,         31    ; Face 8
 FACE     -103,     -142,      -88,         31    ; Face 9
 FACE     -169,       55,      -89,         31    ; Face 10
 FACE        0,        0,     -196,         31    ; Face 11

 EQUB $4C, $44          ; These bytes appear to be unused
 EQUB $41, $52

; ******************************************************************************
;
; Save SHIPS.bin
;
; ******************************************************************************

 PRINT "SHIPS"
 PRINT "Assembled at ", ~CODE_SHIPS%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_SHIPS%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_SHIPS%

 PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
 SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
